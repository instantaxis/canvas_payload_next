# Resolving TypeScript Compilation Errors in Payload CMS 3.0

This document addresses common TypeScript compilation errors in Payload CMS 3.0 projects, specifically focusing on import path issues and missing type annotations for Payload-specific functions.

## 1. Correct Import Patterns

In Payload CMS 3.0, many core types and utilities are now directly exported from the `payload` package, simplifying imports. The previous `payload/types` path is often no longer necessary for common types like `CollectionConfig`, `Field`, `Access`, `PayloadRequest`, etc.

**Incorrect Import (Payload 2.x style):**
```typescript
import { CollectionConfig } from 'payload/types';
import { Field } from 'payload/types';
```

**Correct Import (Payload 3.0 style):**
```typescript
import { CollectionConfig, Field, Access, PayloadRequest, BeforeChangeHook, AfterChangeHook, CollectionBeforeChangeHook, CollectionAfterChangeHook } from 'payload';
```

**Action:** Update all your collection files and other Payload-related files to import these types directly from `'payload'`.

## 2. Missing Type Annotations for Function Parameters

Payload CMS functions (access controls, hooks, field conditions) provide specific parameters that, when properly typed, eliminate many TypeScript errors and improve code clarity.

### A. Access Control Functions

Access control functions (e.g., `access.read`, `access.create`, `access.update`, `access.delete`) receive an object with properties like `req` (the Express request object, extended by Payload), `doc` (the document being accessed/modified), `id`, and `collection`.

**Correct Typing for Access Control:**

```typescript
import { Access, PayloadRequest } from 'payload';
import { User } from '../payload-types'; // Assuming you have a User type defined

export const isAdmin: Access<any, User> = ({ req }) => {
  // req.user will be typed as User if you extend PayloadRequest correctly
  return req.user?.role === 'admin';
};

export const isAdminOrSelf: Access<any, User> = ({ req, id, doc }) => {
  if (req.user?.role === 'admin') {
    return true;
  }

  // If the user is not an admin, they can only read/update their own document
  if (req.user && id === req.user.id) {
    return true;
  }

  // For read access, if no specific ID is provided, allow if the user is logged in
  // and the document's owner matches the current user (if applicable)
  if (req.user && doc && doc.owner === req.user.id) {
    return true;
  }

  return false;
};

// Example usage in a collection:
// access: {
//   read: isAdminOrSelf,
//   create: isAdmin,
//   update: isAdminOrSelf,
//   delete: isAdmin,
// },
```
**Note on `PayloadRequest` and Custom User Types:**
For `req.user` to be correctly typed, you often need to extend Payload's `PayloadRequest` interface to include your custom `User` type. This is typically done in a declaration file (e.g., `src/types/payload-custom.d.ts` or `src/payload-types.ts` if generated by Payload).

```typescript
// Example: src/payload-types.ts (or a custom .d.ts file)
// This is often generated by Payload, but if not, you might need to declare it.
declare module 'payload' {
  export interface PayloadRequest {
    user?: User; // Assuming 'User' is your custom user type
  }
}
```

### B. Hooks (e.g., `beforeChange`, `afterChange`)

Hooks receive specific parameters depending on their type (e.g., `BeforeChangeHook`, `AfterChangeHook`). These parameters should be typed for clarity and error prevention.

**Correct Typing for `beforeChange` Hook:**

```typescript
import { CollectionBeforeChangeHook, PayloadRequest } from 'payload';
import { Product, User } from '../payload-types'; // Assuming Product and User types

export const setProductOwner: CollectionBeforeChangeHook<Product> = async ({
  data, // The data being saved
  req,  // The PayloadRequest object
  operation, // 'create' | 'update'
  originalDoc, // The original document before the change (for 'update' operation)
}) => {
  if (operation === 'create' && req.user) {
    // Ensure 'owner' field exists on your Product type
    return {
      ...data,
      owner: req.user.id,
    };
  }
  return data;
};

// Example usage in a collection field:
// hooks: {
//   beforeChange: [setProductOwner],
// },
```

**Correct Typing for `afterChange` Hook:**

```typescript
import { CollectionAfterChangeHook, PayloadRequest } from 'payload';
import { Order, User } from '../payload-types'; // Assuming Order and User types

export const sendOrderConfirmation: CollectionAfterChangeHook<Order> = async ({
  doc, // The document after the change
  req, // The PayloadRequest object
  operation, // 'create' | 'update'
}) => {
  if (operation === 'create') {
    // Logic to send email, e.g., using a transactional email service
    console.log(`Order ${doc.id} created. Sending confirmation to ${doc.customerEmail}`);
  }
  return doc;
};

// Example usage in a collection:
// hooks: {
//   afterChange: [sendOrderConfirmation],
// },
```

### C. Condition Functions (e.g., `fields[].admin.condition`)

Field condition functions determine whether a field is shown or hidden in the admin UI based on other field values. They typically receive `data` (the entire document data) and `siblingData` (data of fields at the same level).

**Correct Typing for Condition Functions:**

```typescript
import { Field } from 'payload';
import { Product } from '../payload-types'; // Assuming Product type

const productTypeField: Field = {
  name: 'productType',
  type: 'select',
  options: ['food', 'drink'],
  required: true,
};

const drinkSizeField: Field = {
  name: 'drinkSize',
  type: 'select',
  options: ['small', 'medium', 'large'],
  admin: {
    condition: (data: Product, siblingData: any) => {
      // Show 'drinkSize' only if 'productType' is 'drink'
      return data.productType === 'drink';
    },
  },
};

// Example usage in a collection fields array:
// fields: [
//   productTypeField,
//   drinkSizeField,
//   // ... other fields
// ],
```

**Action:** Review all your access control, hook, and condition functions and apply the appropriate type annotations to their parameters. This will significantly reduce your TypeScript errors.