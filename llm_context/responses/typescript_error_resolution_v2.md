# Resolving Advanced TypeScript Errors in Payload CMS 3.0 Collections

This document provides guidance on fixing more advanced TypeScript errors in your Payload CMS 3.0 collection files, specifically addressing issues with extending User types, defining CollectionSlug unions, and implementing properly typed access control functions.

## 1. Extending User Types (Adding `roles` and `locations`)

Payload CMS automatically generates a `payload-types.ts` file (or similar) that contains the TypeScript interfaces for your collections. To add custom properties like `roles` and `locations` to your `User` type, you need to extend the generated `User` interface.

This is typically done by augmenting the `payload` module or by directly modifying the generated `payload-types.ts` if you have custom fields on your `Users` collection.

**Assumed `payload-types.ts` structure (generated by Payload):**
```typescript
// payload-types.ts (This file is often auto-generated by Payload)

export type User = {
  id: string;
  email: string;
  // ... other default Payload user fields
  createdAt: string;
  updatedAt: string;
};

// ... other collection types
```

**To extend the `User` type, you would typically add these fields to your `Users` collection definition in `src/collections/Users.ts` (or similar). Payload will then generate the `payload-types.ts` with these fields included.**

**Example `src/collections/Users.ts` with `roles` and `locations` fields:**

```typescript
import { CollectionConfig } from 'payload';

const Users: CollectionConfig = {
  slug: 'users',
  auth: true,
  admin: {
    use = 'email',
  },
  fields: [
    // Email added by default
    // Password added by default
    {
      name: 'roles',
      type: 'select',
      has  Many: true,
      defaultValue: ['employee'],
      options: [
        {
          label: 'Admin',
          value: 'admin',
        },
        {
          label: 'Employee',
          value: 'employee',
        },
        {
          label: 'Manager',
          value: 'manager',
        },
      ],
    },
    {
      name: 'locations',
      type: 'relationship',
      relationTo: 'locations', // Assuming you have a 'locations' collection
      hasMany: true,
    },
  ],
};

export default Users;
```

After adding these fields to your `Users` collection and running Payload (which triggers type generation), your `User` type in `payload-types.ts` should automatically include `roles` and `locations`:

```typescript
// payload-types.ts (After Payload generates types)

export type User = {
  id: string;
  email: string;
  roles?: ('admin' | 'employee' | 'manager')[]; // Now includes roles
  locations?: string[] | Location[]; // Now includes locations (adjust type based on your Location collection)
  createdAt: string;
  updatedAt: string;
};

// ... other collection types
```

**If you need to manually augment the `PayloadRequest` to ensure `req.user` is correctly typed with your custom fields, you can create a declaration file (e.g., `src/types/payload-custom.d.ts`):**

```typescript
// src/types/payload-custom.d.ts

import { User as PayloadUser } from '../payload-types'; // Import the generated User type

declare module 'payload' {
  export interface PayloadRequest {
    user?: PayloadUser; // Extend PayloadRequest to include your custom User type
  }
}
```

## 2. Defining CollectionSlug Unions

To ensure type safety when referring to collection slugs (names), you can create a union type that lists all your collection slugs. This is particularly useful for relationship fields or when dynamically referencing collections.

First, ensure your `payload-types.ts` (or similar generated file) exports a type that represents all your collection slugs. Payload 3.0 typically generates a `CollectionSlug` type.

**Example `payload-types.ts` (generated):**

```typescript
// payload-types.ts

export type CollectionSlug = 'users' | 'media' | 'contacts' | 'locations'; // Example

// ... rest of the generated types
```

If this `CollectionSlug` type is not automatically generated or doesn't include all your collections, you can define it manually:

```typescript
// src/types/collection-slugs.ts (or similar)

export type AppCollectionSlug =
  | 'users'
  | 'media'
  | 'contacts'
  | 'dietaryRestrictions'
  | 'drinkMenuItems'
  | 'drinkSubcategories'
  | 'employeeRatings'
  | 'features'
  | 'hotspotLogins'
  | 'incidents'
  | 'jobs'
  | 'locations'
  | 'managerReports'
  | 'messages'
  | 'messageTypes'
  | 'qrFeedback'
  | 'questions'
  | 'reviewKeywords'
  | 'reviews'
  | 'serverReports'
  | 'shiftTypes'
  | 'upgrades'
  | 'upgradeTypes';

// You can then use AppCollectionSlug in your code:
// const myCollection: AppCollectionSlug = 'users';
```

## 3. Implementing Proper Access Controls with TypeScript

Access control functions in Payload 3.0 should be strongly typed using the `Access` type imported from `payload`. This type takes two generic arguments: `CollectionType` (the type of the collection the access function is for) and `UserType` (your custom user type).

**Key points for typed access control:**
*   Import `Access` and `PayloadRequest` from `'payload'`.
*   Import your custom `User` type (e.g., from `../payload-types`).
*   Destructure `req` from the access context and use `req.user` which should now be correctly typed with your custom `User` properties (like `roles` and `locations`).

**Example Access Control Functions with `roles` and `locations`:**

```typescript
import { Access, PayloadRequest } from 'payload';
import { User, Location } from '../payload-types'; // Assuming User and Location types

// Access function to check if the user is an admin
export const isAdmin: Access<any, User> = ({ req }) => {
  return req.user?.roles?.includes('admin') || false;
};

// Access function to check if the user is an employee
export const isEmployee: Access<any, User> = ({ req }) => {
  return req.user?.roles?.includes('employee') || false;
};

// Access function to check if the user is a manager
export const isManager: Access<any, User> = ({ req }) => {
  return req.user?.roles?.includes('manager') || false;
};

// Access function to check if the user is an admin OR if the document belongs to one of their assigned locations
export const isAdminOrHasLocationAccess: Access<any, User> = ({ req, doc }) => {
  // Admins have full access
  if (req.user?.roles?.includes('admin')) {
    return true;
  }

  // If the user has locations assigned and the document has a 'location' field
  if (req.user?.locations && doc && doc.location) {
    // Ensure doc.location is a string (ID) or an object with an ID
    const docLocationId = typeof doc.location === 'object' ? doc.location.id : doc.location;

    // Check if the user's locations include the document's location
    return req.user.locations.some(userLocation => {
      const userLocationId = typeof userLocation === 'object' ? userLocation.id : userLocation;
      return userLocationId === docLocationId;
    });
  }

  return false;
};

// Example usage in a collection configuration (e.g., in src/collections/Orders.ts):

// export const Orders: CollectionConfig = {
//   slug: 'orders',
//   access: {
//     read: isAdminOrHasLocationAccess, // Only admins or users with matching location can read orders
//     create: isEmployee, // Only employees can create orders
//     update: isAdminOrHasLocationAccess, // Only admins or users with matching location can update orders
//     delete: isAdmin, // Only admins can delete orders
//   },
//   fields: [
//     {
//       name: 'location',
//       type: 'relationship',
//       relationTo: 'locations',
//       required: true,
//     },
//     // ... other fields
//   ],
// };
```

By implementing these patterns, you should be able to resolve the TypeScript errors related to User types, CollectionSlug unions, and access control functions in your Payload CMS 3.0 project.