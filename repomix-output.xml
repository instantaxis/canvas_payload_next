This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where line numbers have been added.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.ts, **/*.tsx, **/*.js, **/*.jsx, **/*.json, **/*.md, **/*.yml, **/*.yaml, **/*.env.example, **/*.config.*, **/*.mjs, **/*.mts
- Files matching these patterns are excluded: node_modules/**, .git/**, dist/**, build/**, .next/**, coverage/**, *.log, *.lock, pnpm-lock.yaml, yarn.lock, package-lock.json, .env, .env.local, .env.production, **/.DS_Store, **/Thumbs.db, **/*.min.js, **/*.min.css, **/payload-types.ts, **/*.d.ts, repomix-output.*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<user_provided_header>
Canvas Payload v3 Restaurant Management System - Complete Codebase
</user_provided_header>

<directory_structure>
.clinerules/
  cline_rules.md
  dev_workflow.md
  self_improve.md
  taskmaster.md
.cursor/
  mcp.json
.gemini/
  settings.json
.github/
  instructions/
    dev_workflow.md
    self_improve.md
    taskmaster.md
    vscode_rules.md
.roo/
  rules/
    dev_workflow.md
    roo_rules.md
    self_improve.md
    taskmaster.md
  mcp.json
.taskmaster/
  reports/
    task-complexity-report.json
  tasks/
    tasks.json
  config.json
  state.json
.trae/
  rules/
    dev_workflow.md
    self_improve.md
    taskmaster.md
    trae_rules.md
.windsurf/
  rules/
    dev_workflow.md
    self_improve.md
    taskmaster.md
    windsurf_rules.md
  mcp.json
llm_context/
  forms/
    README.md
  llm_agent_insights/
    README.md
  mcp_tools/
    context7_advanced.md
    README.md
    repomix_automation.md
  payload3/
    best_practices.md
    data_models.md
    README.md
    user_documentation.md
  responses/
    prompt_template.md
    setup_verification.md
    typescript_error_resolution_v2.md
    typescript_errors.md
  state_management/
    README.md
  tanstack/
    README.md
  ui_patterns/
    README.md
  README.md
  repomix_integration.md
payload-backend/
  src/
    access/
      index.ts
    app/
      (frontend)/
        layout.tsx
        page.tsx
      (payload)/
        admin/
          [[...segments]]/
            not-found.tsx
            page.tsx
          importMap.js
        api/
          [...slug]/
            route.ts
          graphql/
            route.ts
          graphql-playground/
            route.ts
        layout.tsx
      my-route/
        route.ts
    collections/
      Contacts.ts
      DietaryRestrictions.ts
      DrinkMenuItems.ts
      DrinkSubcategories.ts
      EmployeeRatings.ts
      Features.ts
      HotspotLogins.ts
      Incidents.ts
      Jobs.ts
      Locations.ts
      ManagerReports.ts
      Media.ts
      Messages.ts
      MessageTypes.ts
      QrFeedback.ts
      Questions.ts
      ReviewKeywords.ts
      Reviews.ts
      ServerReports.ts
      ShiftTypes.ts
      Upgrades.ts
      UpgradeTypes.ts
      Users.ts
    middleware/
      securityHeaders.ts
    types/
      auth.ts
      restaurant.ts
    utils/
      index.ts
    middleware.ts
    payload.config.ts
  tests/
    e2e/
      frontend.e2e.spec.ts
    int/
      api.int.spec.ts
  .env.example
  .prettierrc.json
  docker-compose.yml
  eslint.config.mjs
  next.config.mjs
  package.json
  playwright.config.ts
  README.md
  tsconfig.json
  vitest.config.mts
  vitest.setup.ts
prompts/
  architectural_review.md
  git_update.md
.env.example
AGENTS.md
CLAUDE.md
repomix.config.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="payload-backend/src/access/index.ts">
 1: import { Access, PayloadRequest } from 'payload';
 2: import { User } from '../payload-types'; // Adjust path as needed
 3: 
 4: type UserWithRoles = User & {
 5:   roles?: string[];
 6:   locations?: string[];
 7: };
 8: 
 9: export const isAdmin: Access<any, UserWithRoles> = ({ req }) => {
10:   return req.user?.roles?.includes('admin') || false;
11: };
12: 
13: export const isManager: Access<any, UserWithRoles> = ({ req }) => {
14:   return req.user?.roles?.includes('manager') || false;
15: };
16: 
17: export const isFohEmployee: Access<any, UserWithRoles> = ({ req }) => {
18:   return req.user?.roles?.includes('foh_employee') || false;
19: };
20: 
21: export const isStoreManager: Access<any, UserWithRoles> = ({ req }) => {
22:   return req.user?.roles?.includes('store_manager') || false;
23: };
24: 
25: export const isShiftManager: Access<any, UserWithRoles> = ({ req }) => {
26:   return req.user?.roles?.includes('shift_manager') || false;
27: };
28: 
29: export const isAdminOrManager: Access<any, UserWithRoles> = ({ req }) => {
30:   return isAdmin({ req }) || isManager({ req });
31: };
32: 
33: export const isAdminOrSelf: Access<any, UserWithRoles> = ({ req, id, doc }) => {
34:   if (isAdmin({ req })) return true;
35:   if (req.user && id === req.user.id) return true;
36:   if (req.user && doc && doc.id === req.user.id) return true; // Assuming doc.id is the user's ID
37:   return false;
38: };
39: 
40: export const isAdminOrHasLocationAccess: Access<any, UserWithRoles> = ({ req, doc }) => {
41:   if (isAdmin({ req })) return true;
42: 
43:   if (req.user?.locations && doc && doc.location) {
44:     const docLocationId = typeof doc.location === 'object' ? doc.location.id : doc.location;
45:     return req.user.locations.some(userLocation => {
46:       const userLocationId = typeof userLocation === 'object' ? userLocation.id : userLocation;
47:       return userLocationId === docLocationId;
48:     });
49:   }
50:   return false;
51: };
52: 
53: export const isAuthenticated: Access<any, UserWithRoles> = ({ req }) => {
54:   return !!req.user;
55: };
56: 
57: export const canManageUsers: Access<any, UserWithRoles> = ({ req }) => {
58:   return isAdmin({ req }) || isStoreManager({ req }) || isShiftManager({ req });
59: };
60: 
61: export const canReadEmployeeRatings: Access<any, UserWithRoles> = ({ req, id, doc }) => {
62:   if (isAdmin({ req })) return true;
63:   if (isManager({ req })) return true;
64: 
65:   // Employees can only see their own ratings
66:   if (req.user && doc && doc.employee_id && typeof doc.employee_id === 'object' && doc.employee_id.id === req.user.id) {
67:     return true;
68:   }
69:   return false;
70: };
71: 
72: export const isOwnerOrAdmin = (ownerField: string): Access<any, UserWithRoles> => ({ req, doc }) => {
73:   if (isAdmin({ req })) return true;
74: 
75:   if (req.user && doc && doc[ownerField]) {
76:     const ownerId = typeof doc[ownerField] === 'object' ? doc[ownerField].id : doc[ownerField];
77:     return ownerId === req.user.id;
78:   }
79:   return false;
80: };
</file>

<file path="payload-backend/src/app/(frontend)/layout.tsx">
 1: import React from 'react'
 2: import './styles.css'
 3: 
 4: export const metadata = {
 5:   description: 'A blank template using Payload in a Next.js app.',
 6:   title: 'Payload Blank Template',
 7: }
 8: 
 9: export default async function RootLayout(props: { children: React.ReactNode }) {
10:   const { children } = props
11: 
12:   return (
13:     <html lang="en">
14:       <body>
15:         <main>{children}</main>
16:       </body>
17:     </html>
18:   )
19: }
</file>

<file path="payload-backend/src/app/(frontend)/page.tsx">
 1: import { headers as getHeaders } from 'next/headers.js'
 2: import Image from 'next/image'
 3: import { getPayload } from 'payload'
 4: import React from 'react'
 5: import { fileURLToPath } from 'url'
 6: 
 7: import config from '@/payload.config'
 8: import './styles.css'
 9: 
10: export default async function HomePage() {
11:   const headers = await getHeaders()
12:   const payloadConfig = await config
13:   const payload = await getPayload({ config: payloadConfig })
14:   const { user } = await payload.auth({ headers })
15: 
16:   const fileURL = `vscode://file/${fileURLToPath(import.meta.url)}`
17: 
18:   return (
19:     <div className="home">
20:       <div className="content">
21:         <picture>
22:           <source srcSet="https://raw.githubusercontent.com/payloadcms/payload/main/packages/ui/src/assets/payload-favicon.svg" />
23:           <Image
24:             alt="Payload Logo"
25:             height={65}
26:             src="https://raw.githubusercontent.com/payloadcms/payload/main/packages/ui/src/assets/payload-favicon.svg"
27:             width={65}
28:           />
29:         </picture>
30:         {!user && <h1>Welcome to your new project.</h1>}
31:         {user && <h1>Welcome back, {user.email}</h1>}
32:         <div className="links">
33:           <a
34:             className="admin"
35:             href={payloadConfig.routes.admin}
36:             rel="noopener noreferrer"
37:             target="_blank"
38:           >
39:             Go to admin panel
40:           </a>
41:           <a
42:             className="docs"
43:             href="https://payloadcms.com/docs"
44:             rel="noopener noreferrer"
45:             target="_blank"
46:           >
47:             Documentation
48:           </a>
49:         </div>
50:       </div>
51:       <div className="footer">
52:         <p>Update this page by editing</p>
53:         <a className="codeLink" href={fileURL}>
54:           <code>app/(frontend)/page.tsx</code>
55:         </a>
56:       </div>
57:     </div>
58:   )
59: }
</file>

<file path="payload-backend/src/app/(payload)/admin/[[...segments]]/not-found.tsx">
 1: /* THIS FILE WAS GENERATED AUTOMATICALLY BY PAYLOAD. */
 2: /* DO NOT MODIFY IT BECAUSE IT COULD BE REWRITTEN AT ANY TIME. */
 3: import type { Metadata } from 'next'
 4: 
 5: import config from '@payload-config'
 6: import { NotFoundPage, generatePageMetadata } from '@payloadcms/next/views'
 7: import { importMap } from '../importMap'
 8: 
 9: type Args = {
10:   params: Promise<{
11:     segments: string[]
12:   }>
13:   searchParams: Promise<{
14:     [key: string]: string | string[]
15:   }>
16: }
17: 
18: export const generateMetadata = ({ params, searchParams }: Args): Promise<Metadata> =>
19:   generatePageMetadata({ config, params, searchParams })
20: 
21: const NotFound = ({ params, searchParams }: Args) =>
22:   NotFoundPage({ config, params, searchParams, importMap })
23: 
24: export default NotFound
</file>

<file path="payload-backend/src/app/(payload)/admin/[[...segments]]/page.tsx">
 1: /* THIS FILE WAS GENERATED AUTOMATICALLY BY PAYLOAD. */
 2: /* DO NOT MODIFY IT BECAUSE IT COULD BE REWRITTEN AT ANY TIME. */
 3: import type { Metadata } from 'next'
 4: 
 5: import config from '@payload-config'
 6: import { RootPage, generatePageMetadata } from '@payloadcms/next/views'
 7: import { importMap } from '../importMap'
 8: 
 9: type Args = {
10:   params: Promise<{
11:     segments: string[]
12:   }>
13:   searchParams: Promise<{
14:     [key: string]: string | string[]
15:   }>
16: }
17: 
18: export const generateMetadata = ({ params, searchParams }: Args): Promise<Metadata> =>
19:   generatePageMetadata({ config, params, searchParams })
20: 
21: const Page = ({ params, searchParams }: Args) =>
22:   RootPage({ config, params, searchParams, importMap })
23: 
24: export default Page
</file>

<file path="payload-backend/src/app/(payload)/admin/importMap.js">
1: export const importMap = {}
</file>

<file path="payload-backend/src/app/(payload)/api/[...slug]/route.ts">
 1: /* THIS FILE WAS GENERATED AUTOMATICALLY BY PAYLOAD. */
 2: /* DO NOT MODIFY IT BECAUSE IT COULD BE REWRITTEN AT ANY TIME. */
 3: import config from '@payload-config'
 4: import '@payloadcms/next/css'
 5: import {
 6:   REST_DELETE,
 7:   REST_GET,
 8:   REST_OPTIONS,
 9:   REST_PATCH,
10:   REST_POST,
11:   REST_PUT,
12: } from '@payloadcms/next/routes'
13: 
14: export const GET = REST_GET(config)
15: export const POST = REST_POST(config)
16: export const DELETE = REST_DELETE(config)
17: export const PATCH = REST_PATCH(config)
18: export const PUT = REST_PUT(config)
19: export const OPTIONS = REST_OPTIONS(config)
</file>

<file path="payload-backend/src/app/(payload)/api/graphql/route.ts">
1: /* THIS FILE WAS GENERATED AUTOMATICALLY BY PAYLOAD. */
2: /* DO NOT MODIFY IT BECAUSE IT COULD BE REWRITTEN AT ANY TIME. */
3: import config from '@payload-config'
4: import { GRAPHQL_POST, REST_OPTIONS } from '@payloadcms/next/routes'
5: 
6: export const POST = GRAPHQL_POST(config)
7: 
8: export const OPTIONS = REST_OPTIONS(config)
</file>

<file path="payload-backend/src/app/(payload)/api/graphql-playground/route.ts">
1: /* THIS FILE WAS GENERATED AUTOMATICALLY BY PAYLOAD. */
2: /* DO NOT MODIFY IT BECAUSE IT COULD BE REWRITTEN AT ANY TIME. */
3: import config from '@payload-config'
4: import '@payloadcms/next/css'
5: import { GRAPHQL_PLAYGROUND_GET } from '@payloadcms/next/routes'
6: 
7: export const GET = GRAPHQL_PLAYGROUND_GET(config)
</file>

<file path="payload-backend/src/app/(payload)/layout.tsx">
 1: /* THIS FILE WAS GENERATED AUTOMATICALLY BY PAYLOAD. */
 2: /* DO NOT MODIFY IT BECAUSE IT COULD BE REWRITTEN AT ANY TIME. */
 3: import config from '@payload-config'
 4: import '@payloadcms/next/css'
 5: import type { ServerFunctionClient } from 'payload'
 6: import { handleServerFunctions, RootLayout } from '@payloadcms/next/layouts'
 7: import React from 'react'
 8: 
 9: import { importMap } from './admin/importMap.js'
10: import './custom.scss'
11: 
12: type Args = {
13:   children: React.ReactNode
14: }
15: 
16: const serverFunction: ServerFunctionClient = async function (args) {
17:   'use server'
18:   return handleServerFunctions({
19:     ...args,
20:     config,
21:     importMap,
22:   })
23: }
24: 
25: const Layout = ({ children }: Args) => (
26:   <RootLayout config={config} importMap={importMap} serverFunction={serverFunction}>
27:     {children}
28:   </RootLayout>
29: )
30: 
31: export default Layout
</file>

<file path="payload-backend/src/app/my-route/route.ts">
 1: import configPromise from '@payload-config'
 2: import { getPayload } from 'payload'
 3: 
 4: export const GET = async (request: Request) => {
 5:   const payload = await getPayload({
 6:     config: configPromise,
 7:   })
 8: 
 9:   return Response.json({
10:     message: 'This is an example of a custom route.',
11:   })
12: }
</file>

<file path="payload-backend/src/collections/Contacts.ts">
  1: import { CollectionConfig } from 'payload';
  2: import { isAdmin, isStoreManager, isShiftManager, isFohEmployee } from '../access';
  3: 
  4: export const Contacts: CollectionConfig = {
  5:   slug: 'contacts',
  6:   admin: {
  7:     useAsTitle: 'first_name',
  8:     defaultColumns: ['first_name', 'last_name', 'email', 'phone', 'visit_frequency'],
  9:   },
 10:   access: {
 11:     create: ({ req: { user } }) => !!user, // Any authenticated user can create contacts
 12:     read: ({ req: { user } }) => !!user, // Any authenticated user can read contacts (as per current effective logic)
 13:     update: ({ req: { user } }) => isAdmin({ req: { user } }) || isStoreManager({ req: { user } }) || isShiftManager({ req: { user } }) || isFohEmployee({ req: { user } }),
 14:     delete: ({ req: { user } }) => isAdmin({ req: { user } }) || isStoreManager({ req: { user } }) || isShiftManager({ req: { user } }),
 15:   },
 16:   fields: [
 17:     {
 18:       name: 'first_name',
 19:       type: 'text',
 20:       required: true,
 21:       maxLength: 50,
 22:     },
 23:     {
 24:       name: 'last_name',
 25:       type: 'text',
 26:       required: true,
 27:       maxLength: 50,
 28:     },
 29:     {
 30:       name: 'email',
 31:       type: 'email',
 32:       unique: true,
 33:       index: true,
 34:     },
 35:     {
 36:       name: 'phone',
 37:       type: 'text',
 38:       maxLength: 20,
 39:     },
 40:     {
 41:       name: 'company',
 42:       type: 'text',
 43:       maxLength: 100,
 44:     },
 45:     {
 46:       name: 'contact_type',
 47:       type: 'select',
 48:       options: [
 49:         { label: 'Customer', value: 'customer' },
 50:         { label: 'Vendor', value: 'vendor' },
 51:         { label: 'Contractor', value: 'contractor' },
 52:         { label: 'Other', value: 'other' },
 53:       ],
 54:       defaultValue: 'customer',
 55:       required: true,
 56:     },
 57:     {
 58:       name: 'toast_id',
 59:       type: 'text',
 60:       maxLength: 50,
 61:       admin: {
 62:         position: 'sidebar',
 63:       },
 64:     },
 65:     {
 66:       name: 'brevo_id',
 67:       type: 'text',
 68:       maxLength: 50,
 69:       admin: {
 70:         position: 'sidebar',
 71:       },
 72:     },
 73:     {
 74:       name: 'vip_id',
 75:       type: 'number',
 76:       unique: true,
 77:       admin: {
 78:         position: 'sidebar',
 79:       },
 80:     },
 81:     {
 82:       name: 'associated_locations',
 83:       type: 'relationship',
 84:       relationTo: 'locations',
 85:       hasMany: true,
 86:       admin: {
 87:         position: 'sidebar',
 88:       },
 89:     },
 90:     {
 91:       name: 'associated_messages',
 92:       type: 'relationship',
 93:       relationTo: 'messages',
 94:       hasMany: true,
 95:       admin: {
 96:         position: 'sidebar',
 97:       },
 98:     },
 99:     {
100:       name: 'visit_frequency',
101:       type: 'select',
102:       options: [
103:         {
104:           label: 'First Time',
105:           value: 'first_time',
106:         },
107:         {
108:           label: 'Occasional',
109:           value: 'occasional',
110:         },
111:         {
112:           label: 'Regular',
113:           value: 'regular',
114:         },
115:         {
116:           label: 'VIP',
117:           value: 'vip',
118:         },
119:       ],
120:       admin: {
121:         position: 'sidebar',
122:       },
123:     },
124:     {
125:       name: 'last_visit',
126:       type: 'date',
127:       admin: {
128:         position: 'sidebar',
129:       },
130:     },
131:     {
132:       name: 'total_visits',
133:       type: 'number',
134:       min: 0,
135:       defaultValue: 0,
136:       admin: {
137:         position: 'sidebar',
138:       },
139:     },
140:     {
141:       name: 'average_spend',
142:       type: 'number',
143:       min: 0,
144:       admin: {
145:         step: 0.01,
146:         position: 'sidebar',
147:       },
148:     },
149:     {
150:       name: 'preferred_location',
151:       type: 'relationship',
152:       relationTo: 'locations',
153:       admin: {
154:         position: 'sidebar',
155:       },
156:     },
157:     {
158:       name: 'notes',
159:       type: 'textarea',
160:       maxLength: 1000,
161:     },
162:     {
163:       name: 'marketing_consent',
164:       type: 'checkbox',
165:       defaultValue: false,
166:       admin: {
167:         position: 'sidebar',
168:       },
169:     },
170:     {
171:       name: 'birthday',
172:       type: 'date',
173:       admin: {
174:         position: 'sidebar',
175:       },
176:     },
177:     {
178:       name: 'anniversary',
179:       type: 'date',
180:       admin: {
181:         position: 'sidebar',
182:       },
183:     },
184:   ],
185:   hooks: {
186:     beforeChange: [
187:       async ({ data, operation, req }) => {
188:         if (operation === 'create') {
189:           // Set default values for new contacts
190:           if (data.total_visits === undefined) {
191:             data.total_visits = 1; // First visit
192:           }
193:           if (!data.visit_frequency) {
194:             data.visit_frequency = 'first_time';
195:           }
196: 
197:           // Generate vip_id if not provided
198:           if (!data.vip_id) {
199:             const contacts = await req.payload.find({
200:               collection: 'contacts',
201:               sort: '-vip_id',
202:               limit: 1,
203:             });
204:             const maxVipId = contacts.docs.length > 0 ? (contacts.docs[0].vip_id as number) : 9999;
205:             data.vip_id = maxVipId + 1;
206:           }
207:         }
208:         return data;
209:       },
210:     ],
211:     afterChange: [
212:       ({ doc, operation }) => {
213:         // Log contact creation/updates for analytics
214:         if (operation === 'create') {
215:           console.log(`New contact created: ${doc.first_name} ${doc.last_name}`);
216:         }
217:       },
218:     ],
219:   },
220: };
</file>

<file path="payload-backend/src/collections/DietaryRestrictions.ts">
 1: import { CollectionConfig } from 'payload';
 2: import { isAdmin, isAdminOrManager } from '../access';
 3: 
 4: export const DietaryRestrictions: CollectionConfig = {
 5:   slug: 'dietary-restrictions',
 6:   admin: {
 7:     useAsTitle: 'name',
 8:     defaultColumns: ['name', 'description'],
 9:     description: 'Manage common dietary restrictions and allergies.',
10:   },
11:   access: {
12:     create: isAdminOrManager,
13:     read: () => true, // Public read access for menu display, etc.
14:     update: isAdminOrManager,
15:     delete: isAdmin,
16:   },
17:   fields: [
18:     {
19:       name: 'name',
20:       label: 'Restriction Name',
21:       type: 'text',
22:       required: true,
23:       unique: true,
24:       index: true,
25:       maxLength: 100,
26:       admin: {
27:         description: 'e.g., Gluten-Free, Vegan, Nut Allergy, Dairy-Free',
28:       },
29:     },
30:     {
31:       name: 'description',
32:       label: 'Description',
33:       type: 'textarea',
34:       maxLength: 500,
35:       admin: {
36:         description: 'Optional: Provide more details about this restriction.',
37:       },
38:     },
39:   ],
40: };
</file>

<file path="payload-backend/src/collections/DrinkMenuItems.ts">
 1: import { CollectionConfig } from 'payload';
 2: import { isAdmin, isAdminOrManager } from '../access';
 3: 
 4: export const DrinkMenuItems: CollectionConfig = {
 5:   slug: 'drinkMenuItems',
 6:   admin: {
 7:     useAsTitle: 'name',
 8:   },
 9:   access: {
10:     create: isAdminOrManager,
11:     read: () => true,
12:     update: isAdminOrManager,
13:     delete: isAdmin,
14:   },
15:   fields: [
16:     {
17:       name: 'name',
18:       type: 'text',
19:       required: true,
20:     },
21:     {
22:       name: 'description',
23:       type: 'textarea',
24:     },
25:     {
26:       name: 'price',
27:       type: 'number',
28:       min: 0,
29:       required: true,
30:     },
31:     {
32:       name: 'category',
33:       type: 'relationship',
34:       relationTo: 'drinkSubcategories',
35:       required: true,
36:     },
37:     {
38:       name: 'active',
39:       type: 'checkbox',
40:       defaultValue: true,
41:     },
42:   ],
43: };
</file>

<file path="payload-backend/src/collections/DrinkSubcategories.ts">
 1: import { CollectionConfig } from 'payload';
 2: import { isAdmin, isAdminOrManager } from '../access';
 3: 
 4: export const DrinkSubcategories: CollectionConfig = {
 5:   slug: 'drinkSubcategories',
 6:   admin: {
 7:     useAsTitle: 'name',
 8:   },
 9:   access: {
10:     read: () => true,
11:   },
12:   fields: [
13:     {
14:       name: 'name',
15:       type: 'text',
16:       required: true,
17:       unique: true,
18:     },
19:   ],
20: };
</file>

<file path="payload-backend/src/collections/EmployeeRatings.ts">
 1: import type { CollectionConfig } from 'payload'
 2: import { isAdmin, isAdminOrManager, canReadEmployeeRatings } from '../access';
 3: 
 4: export const EmployeeRatings: CollectionConfig = {
 5:   slug: 'employee-ratings',
 6:   admin: {
 7:     useAsTitle: 'employee_id',
 8:     defaultColumns: ['employee_id', 'location_id', 'data_date', 'rating'],
 9:     group: 'Reports',
10:     description: 'Employee performance ratings from managers'
11:   },
12:   access: {
13:     read: canReadEmployeeRatings,
14:     create: isAdminOrManager,
15:     update: isAdminOrManager,
16:     delete: isAdmin,
17:   },
18:   fields: [
19:     {
20:       name: 'employee_id',
21:       type: 'relationship',
22:       relationTo: 'users',
23:       required: true,
24:       admin: {
25:         description: 'Employee being rated'
26:       }
27:     },
28:     {
29:       name: 'location_id',
30:       type: 'relationship',
31:       relationTo: 'locations',
32:       required: true,
33:       admin: {
34:         position: 'sidebar'
35:       }
36:     },
37:     {
38:       name: 'data_date',
39:       type: 'date',
40:       required: true,
41:       admin: {
42:         date: {
43:           pickerAppearance: 'dayOnly',
44:           displayFormat: 'MMM d, yyyy'
45:         }
46:       }
47:     },
48:     {
49:       name: 'rating',
50:       type: 'number',
51:       min: 1,
52:       max: 5,
53:       required: true,
54:       admin: {
55:         description: 'Rating from 1-5 stars',
56:         step: 1
57:       }
58:     },
59:     {
60:       name: 'manager_report_id',
61:       type: 'relationship',
62:       relationTo: 'managerReports',
63:       admin: {
64:         description: 'Associated manager report (if applicable)'
65:       }
66:     },
67:     {
68:       name: 'employee_notes',
69:       type: 'richText',
70:       admin: {
71:         description: 'Notes about employee performance'
72:       }
73:     },
74:     {
75:       name: 'internal_notes',
76:       type: 'textarea',
77:       admin: {
78:         description: 'Internal management notes (not visible to employee)'
79:       }
80:     }
81:   ],
82:   timestamps: true,
83:   hooks: {
84:     beforeChange: [
85:       ({ data, req }) => {
86:         // Ensure rating is within valid range
87:         if (data.rating && (data.rating < 1 || data.rating > 5)) {
88:           throw new Error('Rating must be between 1 and 5')
89:         }
90:         return data
91:       }
92:     ]
93:   }
94: }
</file>

<file path="payload-backend/src/collections/Features.ts">
 1: import { CollectionConfig } from 'payload';
 2: import { isAdmin } from '../access';
 3: 
 4: export const Features: CollectionConfig = {
 5:   slug: 'features',
 6:   admin: {
 7:     useAsTitle: 'name',
 8:   },
 9:   access: {
10:     read: () => true,
11:     update: isAdmin,
12:   },
13:   fields: [
14:     {
15:       name: 'name',
16:       type: 'text',
17:       required: true,
18:       unique: true,
19:     },
20:     {
21:       name: 'enabled',
22:       type: 'checkbox',
23:       defaultValue: false,
24:     },
25:   ],
26: };
</file>

<file path="payload-backend/src/collections/HotspotLogins.ts">
 1: import type { CollectionConfig } from 'payload'
 2: import { isAdmin, isAdminOrManager, isAdminOrHasLocationAccess } from '../access';
 3: 
 4: export const HotspotLogins: CollectionConfig = {
 5:   slug: 'hotspot-logins',
 6:   admin: {
 7:     useAsTitle: 'customer_name',
 8:     defaultColumns: ['customer_name', 'customer_email', 'location', 'date_created'],
 9:     group: 'Data',
10:     description: 'WiFi hotspot login data and customer information'
11:   },
12:   access: {
13:     read: isAdminOrHasLocationAccess,
14:     create: () => true, // Public creation for hotspot logins
15:     update: isAdminOrManager,
16:     delete: isAdmin,
17:   },
18:   fields: [
19:     {
20:       name: 'location',
21:       type: 'relationship',
22:       relationTo: 'locations',
23:       required: true,
24:       admin: {
25:         position: 'sidebar',
26:         description: 'Location where the login occurred'
27:       }
28:     },
29:     {
30:       name: 'customer_name',
31:       type: 'text',
32:       required: false,
33:       admin: {
34:         description: 'Customer name provided during login (optional)'
35:       }
36:     },
37:     {
38:       name: 'customer_email',
39:       type: 'email',
40:       required: false,
41:       admin: {
42:         description: 'Customer email provided during login (optional)'
43:       }
44:     },
45:     {
46:       name: 'marketing_consent',
47:       type: 'checkbox',
48:       defaultValue: false,
49:       admin: {
50:         position: 'sidebar',
51:         description: 'Customer consented to marketing communications'
52:       }
53:     }
54:   ],
55:   timestamps: true,
56:   hooks: {
57:     beforeChange: [
58:       ({ data }) => {
59:         // Validate email format if provided
60:         if (data.customer_email && !data.customer_email.includes('@')) {
61:           throw new Error('Invalid email format')
62:         }
63:         
64:         return data
65:       }
66:     ]
67:   }
68: }
</file>

<file path="payload-backend/src/collections/Incidents.ts">
 1: import { CollectionConfig } from 'payload';
 2: import { isAdmin, isAdminOrManager } from '../access';
 3: 
 4: export const Incidents: CollectionConfig = {
 5:   slug: 'incidents',
 6:   admin: {
 7:     useAsTitle: 'title',
 8:   },
 9:   access: {
10:     create: isAdminOrManager,
11:     read: isAdminOrManager,
12:     update: isAdminOrManager,
13:     delete: isAdmin,
14:   },
15:   fields: [
16:     {
17:       name: 'title',
18:       type: 'text',
19:       required: true,
20:     },
21:     {
22:       name: 'description',
23:       type: 'textarea',
24:     },
25:     {
26:       name: 'date',
27:       type: 'date',
28:       required: true,
29:     },
30:     {
31:       name: 'location',
32:       type: 'relationship',
33:       relationTo: 'locations',
34:       required: true,
35:     },
36:     {
37:       name: 'reportedBy',
38:       type: 'relationship',
39:       relationTo: 'users',
40:       required: true,
41:     },
42:     {
43:       name: 'status',
44:       type: 'select',
45:       options: [
46:         { label: 'Open', value: 'open' },
47:         { label: 'In Progress', value: 'in_progress' },
48:         { label: 'Closed', value: 'closed' },
49:       ],
50:       defaultValue: 'open',
51:     },
52:   ],
53: };
</file>

<file path="payload-backend/src/collections/Jobs.ts">
 1: import { CollectionConfig } from 'payload';
 2: import { isAdmin, isAdminOrManager } from '../access';
 3: 
 4: export const Jobs: CollectionConfig = {
 5:   slug: 'jobs',
 6:   admin: {
 7:     useAsTitle: 'name',
 8:   },
 9:   access: {
10:     read: () => true,
11:   },
12:   fields: [
13:     {
14:       name: 'name',
15:       type: 'text',
16:       required: true,
17:       unique: true,
18:     },
19:   ],
20: };
</file>

<file path="payload-backend/src/collections/Locations.ts">
 1: import { CollectionConfig } from 'payload';
 2: import { isAdmin, isAdminOrManager } from '../access';
 3: 
 4: export const Locations: CollectionConfig = {
 5:   slug: 'locations',
 6:   admin: {
 7:     useAsTitle: 'name',
 8:     defaultColumns: ['name', 'city', 'state', 'phone'],
 9:   },
10:   access: {
11:     create: isAdminOrManager,
12:     read: () => true, // All authenticated users can read locations
13:     update: isAdminOrManager,
14:     delete: isAdmin,
15:   },
16:   fields: [
17:     {
18:       name: 'name',
19:       type: 'text',
20:       required: true,
21:       unique: true,
22:     },
23:     {
24:       name: 'address',
25:       type: 'text',
26:       required: true,
27:     },
28:     {
29:       name: 'city',
30:       type: 'text',
31:       required: true,
32:     },
33:     {
34:       name: 'state',
35:       type: 'text',
36:       required: true,
37:     },
38:     {
39:       name: 'zip',
40:       type: 'text',
41:       required: true,
42:     },
43:     {
44:       name: 'phone',
45:       type: 'text',
46:     },
47:     {
48:       name: 'email',
49:       type: 'email',
50:     },
51:   ],
52: };
</file>

<file path="payload-backend/src/collections/ManagerReports.ts">
 1: import { CollectionConfig } from 'payload';
 2: import { isAdmin, isAdminOrManager } from '../access';
 3: 
 4: export const ManagerReports: CollectionConfig = {
 5:   slug: 'managerReports',
 6:   admin: {
 7:     useAsTitle: 'title',
 8:   },
 9:   access: {
10:     create: isAdminOrManager,
11:     read: isAdminOrManager,
12:     update: isAdminOrManager,
13:     delete: isAdmin,
14:   },
15:   fields: [
16:     {
17:       name: 'title',
18:       type: 'text',
19:       required: true,
20:     },
21:     {
22:       name: 'date',
23:       type: 'date',
24:       required: true,
25:     },
26:     {
27:       name: 'manager',
28:       type: 'relationship',
29:       relationTo: 'users',
30:       required: true,
31:     },
32:     {
33:       name: 'location',
34:       type: 'relationship',
35:       relationTo: 'locations',
36:       required: true,
37:     },
38:     {
39:       name: 'notes',
40:       type: 'textarea',
41:     },
42:   ],
43: };
</file>

<file path="payload-backend/src/collections/Media.ts">
 1: import { CollectionConfig } from 'payload';
 2: import { isAuthenticated, isOwnerOrAdmin } from '../access';
 3: 
 4: export const Media: CollectionConfig = {
 5:   slug: 'media',
 6:   upload: {
 7:     staticDir: 'media',
 8:     imageSizes: [
 9:       {
10:         name: 'thumbnail',
11:         width: 400,
12:         height: 300,
13:         position: 'centre',
14:       },
15:       {
16:         name: 'card',
17:         width: 768,
18:         height: 1024,
19:         position: 'centre',
20:       },
21:       {
22:         name: 'tablet',
23:         width: 1024,
24:         height: undefined,
25:         position: 'centre',
26:       },
27:     ],
28:     adminThumbnail: 'thumbnail',
29:     mimeTypes: ['image/*', 'application/pdf', 'video/*'],
30:   },
31:   access: {
32:     create: isAuthenticated,
33:     read: () => true, // Public read access for media
34:     update: isOwnerOrAdmin('uploadedBy'),
35:     delete: isOwnerOrAdmin('uploadedBy'),
36:   },
37:   fields: [
38:     {
39:       name: 'alt',
40:       type: 'text',
41:       label: 'Alt Text',
42:       required: false,
43:     },
44:     {
45:       name: 'caption',
46:       type: 'textarea',
47:       label: 'Caption',
48:       required: false,
49:     },
50:     {
51:       name: 'uploadedBy',
52:       type: 'relationship',
53:       relationTo: 'users',
54:       required: true,
55:       admin: {
56:         position: 'sidebar',
57:       },
58:     },
59:   ],
60:   hooks: {
61:     beforeChange: [
62:       ({ data, req }) => {
63:         // Automatically set uploadedBy to current user
64:         if (req.user && !data.uploadedBy) {
65:           data.uploadedBy = req.user.id;
66:         }
67:         return data;
68:       },
69:     ],
70:   },
71: };
</file>

<file path="payload-backend/src/collections/Messages.ts">
  1: import type { CollectionConfig } from 'payload'
  2: import { isAdmin, isAdminOrManager } from '../access';
  3: 
  4: export const Messages: CollectionConfig = {
  5:   slug: 'messages',
  6:   admin: {
  7:     useAsTitle: 'subject',
  8:     defaultColumns: ['subject', 'from_name', 'from_email', 'status', 'date_created'],
  9:     group: 'Communications',
 10:     description: 'Customer messages and inquiries'
 11:   },
 12:   access: {
 13:     read: isAdminOrManager,
 14:     create: () => true, // Public can create (contact form submissions)
 15:     update: isAdminOrManager,
 16:     delete: isAdmin,
 17:   },
 18:   fields: [
 19:     {
 20:       name: 'status',
 21:       type: 'select',
 22:       options: [
 23:         { label: 'New', value: 'new' },
 24:         { label: 'In Progress', value: 'in_progress' },
 25:         { label: 'Resolved', value: 'resolved' },
 26:         { label: 'Archived', value: 'archived' }
 27:       ],
 28:       defaultValue: 'new',
 29:       admin: {
 30:         position: 'sidebar'
 31:       }
 32:     },
 33:     {
 34:       name: 'priority',
 35:       type: 'select',
 36:       options: [
 37:         { label: 'Low', value: 'low' },
 38:         { label: 'Normal', value: 'normal' },
 39:         { label: 'High', value: 'high' },
 40:         { label: 'Urgent', value: 'urgent' }
 41:       ],
 42:       defaultValue: 'normal',
 43:       admin: {
 44:         position: 'sidebar'
 45:       }
 46:     },
 47:     {
 48:       name: 'subject',
 49:       type: 'text',
 50:       required: true,
 51:       admin: {
 52:         description: 'Message subject line'
 53:       }
 54:     },
 55:     {
 56:       type: 'row',
 57:       fields: [
 58:         {
 59:           name: 'from_name',
 60:           type: 'text',
 61:           required: true,
 62:           admin: {
 63:             width: '50%'
 64:           }
 65:         },
 66:         {
 67:           name: 'from_email',
 68:           type: 'email',
 69:           required: true,
 70:           admin: {
 71:             width: '50%'
 72:           }
 73:         }
 74:       ]
 75:     },
 76:     {
 77:       type: 'row',
 78:       fields: [
 79:         {
 80:           name: 'from_phone',
 81:           type: 'text',
 82:           admin: {
 83:             width: '50%'
 84:           }
 85:         },
 86:         {
 87:           name: 'location',
 88:           type: 'relationship',
 89:           relationTo: 'locations',
 90:           admin: {
 91:             width: '50%',
 92:             description: 'Related location (if applicable)'
 93:           }
 94:         }
 95:       ]
 96:     },
 97:     {
 98:       name: 'message_type',
 99:       type: 'relationship',
100:       relationTo: 'message-types',
101:       required: true,
102:       admin: {
103:         description: 'Type of message (e.g., General Inquiry, Complaint).',
104:       },
105:     },
106:     {
107:       name: 'message',
108:       type: 'richText',
109:       required: true,
110:       admin: {
111:         description: 'Customer message content'
112:       }
113:     },
114:     {
115:       name: 'internal_notes',
116:       type: 'richText',
117:       admin: {
118:         description: 'Internal staff notes (not visible to customer)'
119:       }
120:     },
121:     {
122:       name: 'assigned_to',
123:       type: 'relationship',
124:       relationTo: 'users',
125:       admin: {
126:         description: 'Staff member assigned to handle this message'
127:       }
128:     },
129:     {
130:       name: 'response_sent',
131:       type: 'checkbox',
132:       defaultValue: false,
133:       admin: {
134:         position: 'sidebar'
135:       }
136:     },
137:     {
138:       name: 'response_date',
139:       type: 'date',
140:       admin: {
141:         position: 'sidebar',
142:         date: {
143:           pickerAppearance: 'dayAndTime'
144:         }
145:       }
146:     },
147:     {
148:       name: 'attachments',
149:       type: 'relationship',
150:       relationTo: 'media',
151:       hasMany: true,
152:       admin: {
153:         description: 'Files attached to the message'
154:       }
155:     }
156:   ],
157:   timestamps: true,
158:   hooks: {
159:     beforeChange: [
160:       ({ data, operation }) => {
161:         // Auto-set response_date when response_sent is marked true
162:         if (data.response_sent && !data.response_date) {
163:           data.response_date = new Date().toISOString()
164:         }
165:         
166:         // Validate email format
167:         if (data.from_email && !data.from_email.includes('@')) {
168:           throw new Error('Invalid email format')
169:         }
170:         
171:         return data
172:       }
173:     ],
174:     afterChange: [
175:       ({ doc, operation }) => {
176:         // Send notification to assigned staff member
177:         if (operation === 'create' && doc.assigned_to) {
178:           // TODO: Implement email notification system
179:           console.log(`New message assigned to user ${doc.assigned_to}`)
180:         }
181:       }
182:     ]
183:   }
184: }
</file>

<file path="payload-backend/src/collections/MessageTypes.ts">
 1: import { CollectionConfig } from 'payload';
 2: import { isAdmin, isAdminOrManager } from '../access';
 3: 
 4: export const MessageTypes: CollectionConfig = {
 5:   slug: 'message-types',
 6:   admin: {
 7:     useAsTitle: 'name',
 8:     defaultColumns: ['name'],
 9:     description: 'Manage different types of customer messages (e.g., General Inquiry, Complaint).',
10:   },
11:   access: {
12:     create: isAdminOrManager,
13:     read: () => true, // Public read access
14:     update: isAdminOrManager,
15:     delete: isAdmin,
16:   },
17:   fields: [
18:     {
19:       name: 'name',
20:       label: 'Message Type Name',
21:       type: 'text',
22:       required: true,
23:       unique: true,
24:       index: true,
25:       maxLength: 100,
26:     },
27:   ],
28: };
</file>

<file path="payload-backend/src/collections/QrFeedback.ts">
 1: import { CollectionConfig } from 'payload';
 2: import { isAdmin, isAdminOrManager } from '../access';
 3: 
 4: export const QrFeedback: CollectionConfig = {
 5:   slug: 'qrFeedback',
 6:   admin: {
 7:     useAsTitle: 'id',
 8:   },
 9:   access: {
10:     create: () => true,
11:     read: isAdminOrManager,
12:     update: isAdminOrManager,
13:     delete: isAdmin,
14:   },
15:   fields: [
16:     {
17:       name: 'rating',
18:       type: 'number',
19:       min: 1,
20:       max: 5,
21:       required: true,
22:     },
23:     {
24:       name: 'comment',
25:       type: 'textarea',
26:     },
27:     {
28:       name: 'location',
29:       type: 'relationship',
30:       relationTo: 'locations',
31:       required: true,
32:     },
33:     {
34:       name: 'user',
35:       type: 'relationship',
36:       relationTo: 'users',
37:     },
38:   ],
39: };
</file>

<file path="payload-backend/src/collections/Questions.ts">
  1: import type { CollectionConfig } from 'payload'
  2: import { isAdmin, isAdminOrManager, isAuthenticated } from '../access';
  3: 
  4: export const Questions: CollectionConfig = {
  5:   slug: 'questions',
  6:   labels: {
  7:     singular: 'Custom Question',
  8:     plural: 'Custom Questions'
  9:   },
 10:   admin: {
 11:     useAsTitle: 'question',
 12:     defaultColumns: ['question', 'shift_timing', 'shift_selection', 'status', 'sort'],
 13:     group: 'Reports',
 14:     description: 'Custom questions to be displayed on server and manager reports'
 15:   },
 16:   access: {
 17:     read: isAuthenticated,
 18:     create: isAdminOrManager,
 19:     update: isAdminOrManager,
 20:     delete: isAdmin,
 21:   },
 22:   fields: [
 23:     {
 24:       name: 'status',
 25:       type: 'select',
 26:       options: [
 27:         { label: 'Active', value: 'active' },
 28:         { label: 'Inactive', value: 'inactive' },
 29:         { label: 'Archived', value: 'archived' }
 30:       ],
 31:       defaultValue: 'active',
 32:       admin: {
 33:         position: 'sidebar'
 34:       }
 35:     },
 36:     {
 37:       name: 'sort',
 38:       type: 'number',
 39:       admin: {
 40:         position: 'sidebar',
 41:         description: 'Sort order for display'
 42:       }
 43:     },
 44:     {
 45:       name: 'question',
 46:       type: 'text',
 47:       required: true,
 48:       admin: {
 49:         description: 'The question text to display'
 50:       }
 51:     },
 52:     {
 53:       name: 'shift_timing',
 54:       type: 'select',
 55:       options: [
 56:         { label: 'AM Only', value: 'am' },
 57:         { label: 'PM Only', value: 'pm' },
 58:         { label: 'Any Shift Time', value: 'any' }
 59:       ],
 60:       defaultValue: 'any',
 61:       admin: {
 62:         description: 'When this question should be displayed'
 63:       }
 64:     },
 65:     {
 66:       name: 'shift_selection',
 67:       type: 'select',
 68:       hasMany: true,
 69:       options: [
 70:         { label: 'Bartender', value: 'bartender' },
 71:         { label: 'Server', value: 'server' },
 72:         { label: 'FOH Support', value: 'foh_support' },
 73:         { label: 'Shift Manager', value: 'shift_manager' },
 74:         { label: 'Store Manager', value: 'store_manager' }
 75:       ],
 76:       admin: {
 77:         description: 'Which roles should see this question'
 78:       }
 79:     },
 80:     {
 81:       name: 'min_characters',
 82:       type: 'number',
 83:       min: 0,
 84:       admin: {
 85:         description: 'Minimum character count for answers'
 86:       }
 87:     },
 88:     {
 89:       name: 'locations',
 90:       type: 'relationship',
 91:       relationTo: 'locations',
 92:       hasMany: true,
 93:       admin: {
 94:         description: 'Locations where this question should appear (leave empty for all locations)'
 95:       }
 96:     }
 97:   ],
 98:   timestamps: true,
 99:   hooks: {
100:     beforeChange: [
101:       ({ data }) => {
102:         // Validate minimum characters
103:         if (data.min_characters && data.min_characters < 0) {
104:           throw new Error('Minimum characters cannot be negative')
105:         }
106:         
107:         return data
108:       }
109:     ]
110:   }
111: }
</file>

<file path="payload-backend/src/collections/ReviewKeywords.ts">
 1: import { CollectionConfig } from 'payload';
 2: import { isAdmin, isAdminOrManager } from '../access';
 3: 
 4: export const ReviewKeywords: CollectionConfig = {
 5:   slug: 'reviewKeywords',
 6:   admin: {
 7:     useAsTitle: 'keyword',
 8:   },
 9:   access: {
10:     create: isAdminOrManager,
11:     read: () => true,
12:     update: isAdminOrManager,
13:     delete: isAdmin,
14:   },
15:   fields: [
16:     {
17:       name: 'keyword',
18:       type: 'text',
19:       required: true,
20:       unique: true,
21:     },
22:   ],
23: };
</file>

<file path="payload-backend/src/collections/Reviews.ts">
 1: import { CollectionConfig } from 'payload';
 2: import { isAdmin, isAdminOrManager } from '../access';
 3: 
 4: export const Reviews: CollectionConfig = {
 5:   slug: 'reviews',
 6:   admin: {
 7:     useAsTitle: 'title',
 8:   },
 9:   access: {
10:     create: () => true,
11:     read: () => true,
12:     update: isAdminOrManager,
13:     delete: isAdmin,
14:   },
15:   fields: [
16:     {
17:       name: 'title',
18:       type: 'text',
19:       required: true,
20:     },
21:     {
22:       name: 'rating',
23:       type: 'number',
24:       min: 1,
25:       max: 5,
26:       required: true,
27:     },
28:     {
29:       name: 'comment',
30:       type: 'textarea',
31:     },
32:     {
33:       name: 'user',
34:       type: 'relationship',
35:       relationTo: 'users',
36:       required: true,
37:     },
38:     {
39:       name: 'location',
40:       type: 'relationship',
41:       relationTo: 'locations',
42:       required: true,
43:     },
44:     {
45:       name: 'keywords',
46:       type: 'relationship',
47:       relationTo: 'reviewKeywords',
48:       hasMany: true,
49:     },
50:   ],
51: };
</file>

<file path="payload-backend/src/collections/ServerReports.ts">
 1: import { CollectionConfig } from 'payload';
 2: import { isAdmin, isAdminOrManager, isFohEmployee } from '../access';
 3: 
 4: export const ServerReports: CollectionConfig = {
 5:   slug: 'serverReports',
 6:   admin: {
 7:     useAsTitle: 'title',
 8:   },
 9:   access: {
10:     create: ({ req: { user } }) => isAdminOrManager({ req: { user } }) || isFohEmployee({ req: { user } }),
11:     read: ({ req: { user } }) => isAdminOrManager({ req: { user } }) || isFohEmployee({ req: { user } }),
12:     update: ({ req: { user } }) => isAdminOrManager({ req: { user } }) || isFohEmployee({ req: { user } }),
13:     delete: isAdmin,
14:   },
15:   fields: [
16:     {
17:       name: 'title',
18:       type: 'text',
19:       required: true,
20:     },
21:     {
22:       name: 'date',
23:       type: 'date',
24:       required: true,
25:     },
26:     {
27:       name: 'server',
28:       type: 'relationship',
29:       relationTo: 'users',
30:       required: true,
31:     },
32:     {
33:       name: 'location',
34:       type: 'relationship',
35:       relationTo: 'locations',
36:       required: true,
37:     },
38:     {
39:       name: 'notes',
40:       type: 'textarea',
41:     },
42:   ],
43: };
</file>

<file path="payload-backend/src/collections/ShiftTypes.ts">
 1: import { CollectionConfig } from 'payload';
 2: import { isAdmin, isAdminOrManager } from '../access';
 3: 
 4: export const ShiftTypes: CollectionConfig = {
 5:   slug: 'shiftTypes',
 6:   admin: {
 7:     useAsTitle: 'name',
 8:   },
 9:   access: {
10:     read: () => true,
11:   },
12:   fields: [
13:     {
14:       name: 'name',
15:       type: 'text',
16:       required: true,
17:       unique: true,
18:     },
19:   ],
20: };
</file>

<file path="payload-backend/src/collections/Upgrades.ts">
  1: import type { CollectionConfig } from 'payload'
  2: import { isAdmin, isAdminOrManager, isAdminOrHasLocationAccess } from '../access';
  3: 
  4: export const Upgrades: CollectionConfig = {
  5:   slug: 'upgrades',
  6:   admin: {
  7:     useAsTitle: 'name',
  8:     defaultColumns: ['name', 'location', 'upgrade_type', 'status', 'date_created'],
  9:     group: 'Data',
 10:     description: 'System and facility upgrades tracking'
 11:   },
 12:   access: {
 13:     read: isAdminOrHasLocationAccess,
 14:     create: isAdminOrManager,
 15:     update: isAdminOrManager,
 16:     delete: isAdmin,
 17:   },
 18:   fields: [
 19:     {
 20:       name: 'name',
 21:       type: 'text',
 22:       required: true,
 23:       admin: {
 24:         description: 'Name or title of the upgrade'
 25:       }
 26:     },
 27:     {
 28:       name: 'location',
 29:       type: 'relationship',
 30:       relationTo: 'locations',
 31:       admin: {
 32:         position: 'sidebar',
 33:         description: 'Location where upgrade is being implemented'
 34:       }
 35:     },
 36:     {
 37:       name: 'upgrade_type',
 38:       type: 'relationship',
 39:       relationTo: 'upgrade-types',
 40:       required: true,
 41:       admin: {
 42:         description: 'Type of upgrade being performed'
 43:       }
 44:     },
 45:     {
 46:       name: 'status',
 47:       type: 'select',
 48:       options: [
 49:         { label: 'Planned', value: 'planned' },
 50:         { label: 'In Progress', value: 'in_progress' },
 51:         { label: 'Completed', value: 'completed' },
 52:         { label: 'On Hold', value: 'on_hold' },
 53:         { label: 'Cancelled', value: 'cancelled' }
 54:       ],
 55:       defaultValue: 'planned',
 56:       admin: {
 57:         position: 'sidebar'
 58:       }
 59:     },
 60:     {
 61:       name: 'description',
 62:       type: 'richText',
 63:       admin: {
 64:         description: 'Detailed description of the upgrade'
 65:       }
 66:     },
 67:     {
 68:       name: 'cost',
 69:       type: 'number',
 70:       min: 0,
 71:       admin: {
 72:         description: 'Estimated or actual cost of the upgrade'
 73:       }
 74:     },
 75:     {
 76:       name: 'vendor',
 77:       type: 'relationship',
 78:       relationTo: 'contacts',
 79:       admin: {
 80:         description: 'Vendor or contractor performing the upgrade',
 81:       },
 82:     },
 83:     {
 84:       name: 'scheduled_date',
 85:       type: 'date',
 86:       admin: {
 87:         description: 'Scheduled start date for the upgrade',
 88:         date: {
 89:           pickerAppearance: 'dayOnly'
 90:         }
 91:       }
 92:     },
 93:     {
 94:       name: 'completion_date',
 95:       type: 'date',
 96:       admin: {
 97:         description: 'Actual completion date',
 98:         date: {
 99:           pickerAppearance: 'dayOnly'
100:         },
101:         condition: (data) => data.status === 'completed'
102:       }
103:     },
104:     {
105:       name: 'notes',
106:       type: 'richText',
107:       admin: {
108:         description: 'Additional notes and updates about the upgrade'
109:       }
110:     },
111:     {
112:       name: 'attachments',
113:       type: 'relationship',
114:       relationTo: 'media',
115:       hasMany: true,
116:       admin: {
117:         description: 'Related documents, photos, or files'
118:       }
119:     }
120:   ],
121:   timestamps: true,
122:   hooks: {
123:     beforeChange: [
124:       ({ data }: { data: any }) => {
125:         // Auto-set completion date when status changes to completed
126:         if (data.status === 'completed' && !data.completion_date) {
127:           data.completion_date = new Date().toISOString().split('T')[0]
128:         }
129:         
130:         // Validate cost
131:         if (data.cost && data.cost < 0) {
132:           throw new Error('Cost cannot be negative')
133:         }
134:         
135:         return data
136:       }
137:     ]
138:   }
139: }
</file>

<file path="payload-backend/src/collections/UpgradeTypes.ts">
 1: import { CollectionConfig } from 'payload';
 2: 
 3: export const UpgradeTypes: CollectionConfig = {
 4:   slug: 'upgrade-types',
 5:   admin: {
 6:     useAsTitle: 'name',
 7:     defaultColumns: ['name'],
 8:     description: 'Manage different types of upgrades (e.g., POS System, Kitchen Equipment).',
 9:   },
10:   access: {
11:     create: ({ req: { user } }) => {
12:       return (user?.roles as string[])?.includes('admin') || (user?.roles as string[])?.includes('manager') || false;
13:     },
14:     read: () => true, // Public read access
15:     update: ({ req: { user } }) => {
16:       return (user?.roles as string[])?.includes('admin') || (user?.roles as string[])?.includes('manager') || false;
17:     },
18:     delete: ({ req: { user } }) => {
19:       return (user?.roles as string[])?.includes('admin') || false;
20:     },
21:   },
22:   fields: [
23:     {
24:       name: 'name',
25:       label: 'Upgrade Type Name',
26:       type: 'text',
27:       required: true,
28:       unique: true,
29:       index: true,
30:       maxLength: 100,
31:     },
32:   ],
33: };
</file>

<file path="payload-backend/src/collections/Users.ts">
  1: import { CollectionConfig } from 'payload';
  2: import { Access, PayloadRequest } from 'payload';
  3: import { User } from '../payload-types';
  4: import { isAdmin, isAdminOrSelf, canManageUsers } from '../access';
  5: 
  6: const Users: CollectionConfig = {
  7:   slug: 'users',
  8:   auth: {
  9:     tokenExpiration: 7200, // 2 hours
 10:     verify: false,
 11:     maxLoginAttempts: 5,
 12:     lockTime: 600 * 1000, // 10 minutes
 13:   },
 14:   admin: {
 15:     useAsTitle: 'email',
 16:     defaultColumns: ['email', 'first_name', 'last_name', 'roles'],
 17:   },
 18:   access: {
 19:     create: isAdmin, // Only admins can create users
 20:     read: isAdminOrSelf,
 21:     update: isAdminOrSelf, // Simplified for now, managers can update all users except admins would need custom logic
 22:     delete: isAdmin,
 23:   },
 24:   fields: [
 25:     {
 26:       name: 'first_name',
 27:       type: 'text',
 28:       required: true,
 29:       maxLength: 50,
 30:     },
 31:     {
 32:       name: 'last_name',
 33:       type: 'text',
 34:       required: true,
 35:       maxLength: 50,
 36:     },
 37:     {
 38:       name: 'phone',
 39:       type: 'text',
 40:       required: false,
 41:       maxLength: 20,
 42:     },
 43:     {
 44:       name: 'employee_id',
 45:       type: 'text',
 46:       required: false,
 47:       unique: true,
 48:       maxLength: 20,
 49:     },
 50:     {
 51:       name: 'roles',
 52:       type: 'select',
 53:       hasMany: true,
 54:       defaultValue: ['user'],
 55:       options: [
 56:         {
 57:           label: 'Admin',
 58:           value: 'admin',
 59:         },
 60:         {
 61:           label: 'Store Manager',
 62:           value: 'store_manager',
 63:         },
 64:         {
 65:           label: 'Shift Manager',
 66:           value: 'shift_manager',
 67:         },
 68:         {
 69:           label: 'FOH Employee',
 70:           value: 'foh_employee',
 71:         },
 72:         {
 73:           label: 'BOH Employee',
 74:           value: 'boh_employee',
 75:         },
 76:         {
 77:           label: 'User',
 78:           value: 'user',
 79:         },
 80:       ],
 81:       access: {
 82:         create: canManageUsers,
 83:         update: canManageUsers,
 84:       },
 85:     },
 86:     {
 87:       name: 'status',
 88:       type: 'select',
 89:       defaultValue: 'active',
 90:       options: [
 91:         {
 92:           label: 'Active',
 93:           value: 'active',
 94:         },
 95:         {
 96:           label: 'Inactive',
 97:           value: 'inactive',
 98:         },
 99:         {
100:           label: 'On Leave',
101:           value: 'on_leave',
102:         },
103:         {
104:           label: 'Terminated',
105:           value: 'terminated',
106:         },
107:       ],
108:       access: {
109:         create: canManageUsers,
110:         update: canManageUsers,
111:       },
112:     },
113:     {
114:       name: 'locations',
115:       type: 'relationship',
116:       relationTo: 'locations',
117:       hasMany: true,
118:       admin: {
119:         position: 'sidebar',
120:       },
121:     },
122:     {
123:       name: 'primary_location',
124:       type: 'relationship',
125:       relationTo: 'locations',
126:       admin: {
127:         position: 'sidebar',
128:       },
129:     },
130:     {
131:       name: 'employment_details',
132:       type: 'group',
133:       fields: [
134:         {
135:           name: 'hire_date',
136:           type: 'date',
137:         },
138:         {
139:           name: 'termination_date',
140:           type: 'date',
141:         },
142:         {
143:           name: 'employment_type',
144:           type: 'select',
145:           options: [
146:             { label: 'Full Time', value: 'full_time' },
147:             { label: 'Part Time', value: 'part_time' },
148:             { label: 'Seasonal', value: 'seasonal' },
149:             { label: 'Contract', value: 'contract' },
150:           ],
151:         },
152:         {
153:           name: 'hourly_rate',
154:           type: 'number',
155:           min: 0,
156:           admin: {
157:             step: 0.01,
158:           },
159:         },
160:       ],
161:       admin: {
162:         condition: (data, siblingData, { user }) => {
163:           return (user?.roles as string[])?.includes('admin') || (user?.roles as string[])?.includes('store_manager') || (user?.roles as string[])?.includes('shift_manager');
164:         },
165:       },
166:     },
167:     {
168:       name: 'profile_photo',
169:       type: 'relationship',
170:       relationTo: 'media',
171:       admin: {
172:         position: 'sidebar',
173:       },
174:     },
175:     {
176:       name: 'jobs',
177:       type: 'relationship',
178:       relationTo: 'jobs',
179:       hasMany: true,
180:       admin: {
181:         position: 'sidebar',
182:       },
183:     },
184:   ],
185:   hooks: {
186:     beforeChange: [
187:       ({ data, req, operation }) => {
188:         if (operation === 'create') {
189:           // Set default role for new users
190:           if (!data.roles || data.roles.length === 0) {
191:             data.roles = ['user'];
192:           }
193:         }
194:         return data;
195:       },
196:     ],
197:   },
198: };
199: 
200: export default Users;
</file>

<file path="payload-backend/src/middleware/securityHeaders.ts">
1: import { NextRequest, NextResponse } from 'next/server';
2: 
3: export function setSecurityHeaders(response: NextResponse) {
4:   response.headers.set('X-Frame-Options', 'DENY');
5:   response.headers.set('X-Content-Type-Options', 'nosniff');
6:   response.headers.set('Referrer-Policy', 'origin-when-cross-origin');
7:   response.headers.set('X-XSS-Protection', '1; mode=block');
8: }
</file>

<file path="payload-backend/src/types/auth.ts">
 1: export interface RestaurantUser {
 2:   id: string
 3:   email: string
 4:   first_name?: string
 5:   last_name?: string
 6:   phone?: string
 7:   employee_id?: string
 8:   roles?: string[]
 9:   status?: 'active' | 'inactive' | 'on_leave' | 'terminated'
10:   locations?: string[] | any[]
11:   primary_location?: string | any
12:   employment_details?: {
13:     hire_date?: string
14:     termination_date?: string
15:     employment_type?: 'full_time' | 'part_time' | 'seasonal' | 'contract'
16:     hourly_rate?: number
17:   }
18:   profile_photo?: string | any
19:   jobs?: string[] | any[]
20:   collection: 'users'
21:   createdAt: string
22:   updatedAt: string
23: }
24: 
25: export type UserRole = 'admin' | 'store_manager' | 'shift_manager' | 'foh_employee' | 'boh_employee' | 'user'
26: export type UserStatus = 'active' | 'inactive' | 'on_leave' | 'terminated'
27: export type EmploymentType = 'full_time' | 'part_time' | 'seasonal' | 'contract'
</file>

<file path="payload-backend/src/types/restaurant.ts">
  1: /**
  2:  * Restaurant Management System - Core Type Definitions
  3:  * Defines TypeScript interfaces for restaurant operations, employee management, and ratings
  4:  */
  5: 
  6: // Base types for all entities
  7: export interface BaseEntity {
  8:   id: string
  9:   createdAt: string
 10:   updatedAt: string
 11: }
 12: 
 13: // User and Authentication Types
 14: export interface User extends BaseEntity {
 15:   email: string
 16:   firstName: string
 17:   lastName: string
 18:   role: UserRole
 19:   isActive: boolean
 20:   lastLogin?: string
 21:   profileImage?: string
 22: }
 23: 
 24: export type UserRole = 'admin' | 'manager' | 'employee'
 25: 
 26: export interface AuthSession {
 27:   user: User
 28:   token: string
 29:   expiresAt: string
 30: }
 31: 
 32: // Employee Management Types
 33: export interface Employee extends BaseEntity {
 34:   userId: string
 35:   employeeId: string
 36:   position: string
 37:   department: string
 38:   hireDate: string
 39:   hourlyRate?: number
 40:   isActive: boolean
 41:   emergencyContact?: EmergencyContact
 42:   schedule?: WorkSchedule[]
 43: }
 44: 
 45: export interface EmergencyContact {
 46:   name: string
 47:   relationship: string
 48:   phone: string
 49:   email?: string
 50: }
 51: 
 52: export interface WorkSchedule {
 53:   dayOfWeek: number // 0-6 (Sunday-Saturday)
 54:   startTime: string // HH:MM format
 55:   endTime: string // HH:MM format
 56:   isActive: boolean
 57: }
 58: 
 59: // Rating and Performance Types
 60: export interface EmployeeRating extends BaseEntity {
 61:   employeeId: string
 62:   raterId: string // Manager or admin who gave the rating
 63:   ratingPeriod: RatingPeriod
 64:   overallScore: number // 1-10 scale
 65:   categories: RatingCategory[]
 66:   comments?: string
 67:   improvementAreas?: string[]
 68:   strengths?: string[]
 69:   goals?: string[]
 70: }
 71: 
 72: export interface RatingPeriod {
 73:   startDate: string
 74:   endDate: string
 75:   type: 'weekly' | 'monthly' | 'quarterly' | 'annual'
 76: }
 77: 
 78: export interface RatingCategory {
 79:   name: string
 80:   score: number // 1-10 scale
 81:   weight: number // Percentage weight in overall score
 82:   comments?: string
 83: }
 84: 
 85: // Standard rating categories for restaurant employees
 86: export const RATING_CATEGORIES = {
 87:   CUSTOMER_SERVICE: 'Customer Service',
 88:   TEAMWORK: 'Teamwork & Collaboration',
 89:   PUNCTUALITY: 'Punctuality & Attendance',
 90:   FOOD_SAFETY: 'Food Safety & Hygiene',
 91:   EFFICIENCY: 'Work Efficiency',
 92:   COMMUNICATION: 'Communication Skills',
 93:   LEADERSHIP: 'Leadership (if applicable)',
 94:   PROBLEM_SOLVING: 'Problem Solving',
 95:   ADAPTABILITY: 'Adaptability',
 96:   INITIATIVE: 'Initiative & Proactivity'
 97: } as const
 98: 
 99: // Report Types
100: export interface ManagerReport extends BaseEntity {
101:   managerId: string
102:   reportType: ReportType
103:   period: RatingPeriod
104:   summary: string
105:   metrics: ReportMetric[]
106:   recommendations?: string[]
107:   attachments?: string[]
108: }
109: 
110: export type ReportType = 
111:   | 'performance_summary'
112:   | 'team_analysis'
113:   | 'improvement_plan'
114:   | 'incident_report'
115:   | 'training_needs'
116: 
117: export interface ReportMetric {
118:   name: string
119:   value: number
120:   unit: string
121:   trend?: 'up' | 'down' | 'stable'
122:   comparison?: {
123:     period: string
124:     value: number
125:   }
126: }
127: 
128: // Location and Restaurant Types
129: export interface Location extends BaseEntity {
130:   name: string
131:   address: string
132:   city: string
133:   state: string
134:   zipCode: string
135:   phone: string
136:   email?: string
137:   managerId?: string
138:   isActive: boolean
139:   operatingHours: OperatingHours[]
140: }
141: 
142: export interface OperatingHours {
143:   dayOfWeek: number
144:   openTime: string
145:   closeTime: string
146:   isClosed: boolean
147: }
148: 
149: // API Response Types
150: export interface ApiResponse<T = any> {
151:   success: boolean
152:   data?: T
153:   error?: string
154:   message?: string
155:   pagination?: {
156:     page: number
157:     limit: number
158:     total: number
159:     totalPages: number
160:   }
161: }
162: 
163: export interface PaginationParams {
164:   page?: number
165:   limit?: number
166:   sortBy?: string
167:   sortOrder?: 'asc' | 'desc'
168:   search?: string
169: }
170: 
171: // Form and Validation Types
172: export interface ValidationError {
173:   field: string
174:   message: string
175:   code?: string
176: }
177: 
178: export interface FormState<T = any> {
179:   data: T
180:   errors: ValidationError[]
181:   isSubmitting: boolean
182:   isValid: boolean
183: }
184: 
185: // Notification and Alert Types
186: export interface Notification extends BaseEntity {
187:   userId: string
188:   title: string
189:   message: string
190:   type: NotificationType
191:   isRead: boolean
192:   actionUrl?: string
193:   metadata?: Record<string, any>
194: }
195: 
196: export type NotificationType = 
197:   | 'rating_received'
198:   | 'schedule_change'
199:   | 'performance_alert'
200:   | 'system_update'
201:   | 'reminder'
202: 
203: // Dashboard and Analytics Types
204: export interface DashboardMetrics {
205:   totalEmployees: number
206:   activeEmployees: number
207:   averageRating: number
208:   ratingsTrendData: TrendDataPoint[]
209:   topPerformers: Employee[]
210:   improvementNeeded: Employee[]
211:   recentRatings: EmployeeRating[]
212: }
213: 
214: export interface TrendDataPoint {
215:   date: string
216:   value: number
217:   label?: string
218: }
219: 
220: // Export utility type for Payload CMS collections
221: export type PayloadCollection<T> = T & {
222:   id: string
223:   createdAt: string
224:   updatedAt: string
225: }
</file>

<file path="payload-backend/src/utils/index.ts">
  1: /**
  2:  * Restaurant Management System - Utility Functions
  3:  * Common utilities for data formatting, validation, and calculations
  4:  */
  5: 
  6: import { type ClassValue, clsx } from 'clsx'
  7: import { twMerge } from 'tailwind-merge'
  8: import { EmployeeRating, RatingCategory, User, UserRole } from '@/types/restaurant'
  9: 
 10: // Tailwind CSS class merging utility
 11: export function cn(...inputs: ClassValue[]) {
 12:   return twMerge(clsx(inputs))
 13: }
 14: 
 15: // Date and Time Utilities
 16: export const dateUtils = {
 17:   /**
 18:    * Format date to readable string
 19:    */
 20:   formatDate: (date: string | Date, options?: Intl.DateTimeFormatOptions): string => {
 21:     const dateObj = typeof date === 'string' ? new Date(date) : date
 22:     return dateObj.toLocaleDateString('en-US', {
 23:       year: 'numeric',
 24:       month: 'short',
 25:       day: 'numeric',
 26:       ...options
 27:     })
 28:   },
 29: 
 30:   /**
 31:    * Format time to readable string
 32:    */
 33:   formatTime: (time: string): string => {
 34:     const [hours, minutes] = time.split(':')
 35:     const hour = parseInt(hours)
 36:     const ampm = hour >= 12 ? 'PM' : 'AM'
 37:     const displayHour = hour % 12 || 12
 38:     return `${displayHour}:${minutes} ${ampm}`
 39:   },
 40: 
 41:   /**
 42:    * Get relative time (e.g., "2 hours ago")
 43:    */
 44:   getRelativeTime: (date: string | Date): string => {
 45:     const now = new Date()
 46:     const dateObj = typeof date === 'string' ? new Date(date) : date
 47:     const diffMs = now.getTime() - dateObj.getTime()
 48:     const diffMins = Math.floor(diffMs / (1000 * 60))
 49:     const diffHours = Math.floor(diffMins / 60)
 50:     const diffDays = Math.floor(diffHours / 24)
 51: 
 52:     if (diffMins < 1) return 'Just now'
 53:     if (diffMins < 60) return `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`
 54:     if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`
 55:     if (diffDays < 7) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`
 56:     
 57:     return dateUtils.formatDate(dateObj)
 58:   },
 59: 
 60:   /**
 61:    * Check if date is within the last N days
 62:    */
 63:   isWithinDays: (date: string | Date, days: number): boolean => {
 64:     const dateObj = typeof date === 'string' ? new Date(date) : date
 65:     const now = new Date()
 66:     const diffMs = now.getTime() - dateObj.getTime()
 67:     const diffDays = diffMs / (1000 * 60 * 60 * 24)
 68:     return diffDays <= days
 69:   }
 70: }
 71: 
 72: // Rating and Performance Utilities
 73: export const ratingUtils = {
 74:   /**
 75:    * Calculate weighted overall score from rating categories
 76:    */
 77:   calculateOverallScore: (categories: RatingCategory[]): number => {
 78:     if (!categories.length) return 0
 79:     
 80:     const totalWeight = categories.reduce((sum, cat) => sum + cat.weight, 0)
 81:     if (totalWeight === 0) return 0
 82:     
 83:     const weightedSum = categories.reduce((sum, cat) => {
 84:       return sum + (cat.score * cat.weight)
 85:     }, 0)
 86:     
 87:     return Math.round((weightedSum / totalWeight) * 100) / 100
 88:   },
 89: 
 90:   /**
 91:    * Get rating level description
 92:    */
 93:   getRatingLevel: (score: number): { level: string; color: string; description: string } => {
 94:     if (score >= 9) return { 
 95:       level: 'Exceptional', 
 96:       color: 'green', 
 97:       description: 'Outstanding performance' 
 98:     }
 99:     if (score >= 8) return { 
100:       level: 'Excellent', 
101:       color: 'blue', 
102:       description: 'Exceeds expectations' 
103:     }
104:     if (score >= 7) return { 
105:       level: 'Good', 
106:       color: 'teal', 
107:       description: 'Meets expectations' 
108:     }
109:     if (score >= 6) return { 
110:       level: 'Satisfactory', 
111:       color: 'yellow', 
112:       description: 'Acceptable performance' 
113:     }
114:     if (score >= 4) return { 
115:       level: 'Needs Improvement', 
116:       color: 'orange', 
117:       description: 'Below expectations' 
118:     }
119:     return { 
120:       level: 'Unsatisfactory', 
121:       color: 'red', 
122:       description: 'Significant improvement needed' 
123:     }
124:   },
125: 
126:   /**
127:    * Calculate average rating for an employee
128:    */
129:   calculateAverageRating: (ratings: EmployeeRating[]): number => {
130:     if (!ratings.length) return 0
131:     const sum = ratings.reduce((total, rating) => total + rating.overallScore, 0)
132:     return Math.round((sum / ratings.length) * 100) / 100
133:   },
134: 
135:   /**
136:    * Get rating trend (improving, declining, stable)
137:    */
138:   getRatingTrend: (ratings: EmployeeRating[]): 'improving' | 'declining' | 'stable' => {
139:     if (ratings.length < 2) return 'stable'
140:     
141:     const sortedRatings = [...ratings].sort((a, b) => 
142:       new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
143:     )
144:     
145:     const recent = sortedRatings.slice(-3)
146:     const older = sortedRatings.slice(-6, -3)
147:     
148:     if (recent.length < 2) return 'stable'
149:     
150:     const recentAvg = recent.reduce((sum, r) => sum + r.overallScore, 0) / recent.length
151:     const olderAvg = older.length > 0 
152:       ? older.reduce((sum, r) => sum + r.overallScore, 0) / older.length 
153:       : recentAvg
154:     
155:     const difference = recentAvg - olderAvg
156:     
157:     if (difference > 0.5) return 'improving'
158:     if (difference < -0.5) return 'declining'
159:     return 'stable'
160:   }
161: }
162: 
163: // User and Permission Utilities
164: export const userUtils = {
165:   /**
166:    * Get user's full name
167:    */
168:   getFullName: (user: User): string => {
169:     return `${user.firstName} ${user.lastName}`.trim()
170:   },
171: 
172:   /**
173:    * Get user's initials
174:    */
175:   getInitials: (user: User): string => {
176:     const first = user.firstName?.charAt(0) || ''
177:     const last = user.lastName?.charAt(0) || ''
178:     return (first + last).toUpperCase()
179:   },
180: 
181:   /**
182:    * Check if user has permission for action
183:    */
184:   hasPermission: (userRole: UserRole, requiredRole: UserRole): boolean => {
185:     const roleHierarchy: Record<UserRole, number> = {
186:       employee: 1,
187:       manager: 2,
188:       admin: 3
189:     }
190:     
191:     return roleHierarchy[userRole] >= roleHierarchy[requiredRole]
192:   },
193: 
194:   /**
195:    * Check if user can rate another user
196:    */
197:   canRateEmployee: (raterRole: UserRole, targetRole: UserRole): boolean => {
198:     // Admins can rate anyone, managers can rate employees, employees cannot rate
199:     if (raterRole === 'admin') return true
200:     if (raterRole === 'manager' && targetRole === 'employee') return true
201:     return false
202:   }
203: }
204: 
205: // Data Formatting Utilities
206: export const formatUtils = {
207:   /**
208:    * Format currency
209:    */
210:   currency: (amount: number): string => {
211:     return new Intl.NumberFormat('en-US', {
212:       style: 'currency',
213:       currency: 'USD'
214:     }).format(amount)
215:   },
216: 
217:   /**
218:    * Format percentage
219:    */
220:   percentage: (value: number, decimals: number = 1): string => {
221:     return `${value.toFixed(decimals)}%`
222:   },
223: 
224:   /**
225:    * Format phone number
226:    */
227:   phone: (phone: string): string => {
228:     const cleaned = phone.replace(/\D/g, '')
229:     if (cleaned.length === 10) {
230:       return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`
231:     }
232:     return phone
233:   },
234: 
235:   /**
236:    * Truncate text with ellipsis
237:    */
238:   truncate: (text: string, maxLength: number): string => {
239:     if (text.length <= maxLength) return text
240:     return text.slice(0, maxLength - 3) + '...'
241:   },
242: 
243:   /**
244:    * Capitalize first letter of each word
245:    */
246:   titleCase: (text: string): string => {
247:     return text.replace(/\w\S*/g, (txt) => 
248:       txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
249:     )
250:   }
251: }
252: 
253: // Validation Utilities
254: export const validationUtils = {
255:   /**
256:    * Validate email format
257:    */
258:   isValidEmail: (email: string): boolean => {
259:     const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
260:     return emailRegex.test(email)
261:   },
262: 
263:   /**
264:    * Validate phone number
265:    */
266:   isValidPhone: (phone: string): boolean => {
267:     const phoneRegex = /^\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$/
268:     return phoneRegex.test(phone)
269:   },
270: 
271:   /**
272:    * Validate rating score (1-10)
273:    */
274:   isValidRating: (score: number): boolean => {
275:     return score >= 1 && score <= 10 && Number.isInteger(score * 10)
276:   },
277: 
278:   /**
279:    * Check if string is not empty
280:    */
281:   isNotEmpty: (value: string): boolean => {
282:     return value.trim().length > 0
283:   }
284: }
285: 
286: // Array and Object Utilities
287: export const arrayUtils = {
288:   /**
289:    * Group array by key
290:    */
291:   groupBy: <T>(array: T[], key: keyof T): Record<string, T[]> => {
292:     return array.reduce((groups, item) => {
293:       const groupKey = String(item[key])
294:       if (!groups[groupKey]) {
295:         groups[groupKey] = []
296:       }
297:       groups[groupKey].push(item)
298:       return groups
299:     }, {} as Record<string, T[]>)
300:   },
301: 
302:   /**
303:    * Sort array by multiple criteria
304:    */
305:   sortBy: <T>(array: T[], ...criteria: Array<keyof T | ((item: T) => any)>): T[] => {
306:     return [...array].sort((a, b) => {
307:       for (const criterion of criteria) {
308:         let aVal, bVal
309:         
310:         if (typeof criterion === 'function') {
311:           aVal = criterion(a)
312:           bVal = criterion(b)
313:         } else {
314:           aVal = a[criterion]
315:           bVal = b[criterion]
316:         }
317:         
318:         if (aVal < bVal) return -1
319:         if (aVal > bVal) return 1
320:       }
321:       return 0
322:     })
323:   },
324: 
325:   /**
326:    * Remove duplicates from array
327:    */
328:   unique: <T>(array: T[], key?: keyof T): T[] => {
329:     if (!key) {
330:       return [...new Set(array)]
331:     }
332:     
333:     const seen = new Set()
334:     return array.filter(item => {
335:       const value = item[key]
336:       if (seen.has(value)) {
337:         return false
338:       }
339:       seen.add(value)
340:       return true
341:     })
342:   }
343: }
344: 
345: // Error Handling Utilities
346: export const errorUtils = {
347:   /**
348:    * Extract error message from various error types
349:    */
350:   getErrorMessage: (error: unknown): string => {
351:     if (error instanceof Error) {
352:       return error.message
353:     }
354:     if (typeof error === 'string') {
355:       return error
356:     }
357:     if (error && typeof error === 'object' && 'message' in error) {
358:       return String(error.message)
359:     }
360:     return 'An unexpected error occurred'
361:   },
362: 
363:   /**
364:    * Check if error is a network error
365:    */
366:   isNetworkError: (error: unknown): boolean => {
367:     const message = errorUtils.getErrorMessage(error).toLowerCase()
368:     return message.includes('network') || 
369:            message.includes('fetch') || 
370:            message.includes('connection')
371:   }
372: }
373: 
374: // All utilities are already exported above
</file>

<file path="payload-backend/src/middleware.ts">
 1: import { NextRequest, NextResponse } from 'next/server'
 2: 
 3: // Restaurant management system middleware
 4: export function middleware(request: NextRequest) {
 5:   const { pathname } = request.nextUrl
 6: 
 7:   // Security headers for all routes
 8:   const response = NextResponse.next()
 9:   
10:   // Add security headers
11:   response.headers.set('X-Frame-Options', 'DENY')
12:   response.headers.set('X-Content-Type-Options', 'nosniff')
13:   response.headers.set('Referrer-Policy', 'origin-when-cross-origin')
14:   response.headers.set('X-XSS-Protection', '1; mode=block')
15: 
16:   // CORS headers for API routes
17:   if (pathname.startsWith('/api/')) {
18:     response.headers.set('Access-Control-Allow-Origin', process.env.PAYLOAD_PUBLIC_SERVER_URL || '*')
19:     response.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS')
20:     response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization')
21:     response.headers.set('Access-Control-Allow-Credentials', 'true')
22:   }
23: 
24:   // Handle preflight requests
25:   if (request.method === 'OPTIONS') {
26:     return new Response(null, { status: 200, headers: response.headers })
27:   }
28: 
29:   // Restaurant-specific route protection
30:   if (pathname.startsWith('/admin') || pathname.startsWith('/dashboard')) {
31:     // Check for authentication token
32:     const token = request.cookies.get('payload-token')?.value
33:     
34:     if (!token && !pathname.startsWith('/admin/login')) {
35:       return NextResponse.redirect(new URL('/admin/login', request.url))
36:     }
37:   }
38: 
39:   // Rate limiting for API routes (basic implementation)
40:   if (pathname.startsWith('/api/')) {
41:     const ip = request.headers.get('x-forwarded-for') || 
42:               request.headers.get('x-real-ip') || 
43:               'unknown'
44:     // In production, implement proper rate limiting with Redis or similar
45:     console.log(`API request from ${ip} to ${pathname}`)
46:   }
47: 
48:   return response
49: }
50: 
51: export const config = {
52:   matcher: [
53:     /*
54:      * Match all request paths except for the ones starting with:
55:      * - _next/static (static files)
56:      * - _next/image (image optimization files)
57:      * - favicon.ico (favicon file)
58:      * - public folder
59:      */
60:     '/((?!_next/static|_next/image|favicon.ico|public/).*)',
61:   ],
62: }
</file>

<file path="payload-backend/src/payload.config.ts">
 1: // storage-adapter-import-placeholder
 2: import { vercelPostgresAdapter } from '@payloadcms/db-vercel-postgres'
 3: import { payloadCloudPlugin } from '@payloadcms/payload-cloud'
 4: import { lexicalEditor } from '@payloadcms/richtext-lexical'
 5: import path from 'path'
 6: import { buildConfig } from 'payload'
 7: import { fileURLToPath } from 'url'
 8: import sharp from 'sharp'
 9: 
10: import Users from './collections/Users'
11: import { Media } from './collections/Media'
12: import { Contacts } from './collections/Contacts'
13: import { DietaryRestrictions } from './collections/DietaryRestrictions'
14: import { DrinkMenuItems } from './collections/DrinkMenuItems'
15: import { DrinkSubcategories } from './collections/DrinkSubcategories'
16: import { EmployeeRatings } from './collections/EmployeeRatings'
17: import { Features } from './collections/Features'
18: import { HotspotLogins } from './collections/HotspotLogins'
19: import { Incidents } from './collections/Incidents'
20: import { Jobs } from './collections/Jobs'
21: import { Locations } from './collections/Locations'
22: import { ManagerReports } from './collections/ManagerReports'
23: import { Messages } from './collections/Messages'
24: import { MessageTypes } from './collections/MessageTypes'
25: import { QrFeedback } from './collections/QrFeedback'
26: import { Questions } from './collections/Questions'
27: import { ReviewKeywords } from './collections/ReviewKeywords'
28: import { Reviews } from './collections/Reviews'
29: import { ServerReports } from './collections/ServerReports'
30: import { ShiftTypes } from './collections/ShiftTypes'
31: import { Upgrades } from './collections/Upgrades'
32: import { UpgradeTypes } from './collections/UpgradeTypes'
33: 
34: const filename = fileURLToPath(import.meta.url)
35: const dirname = path.dirname(filename)
36: 
37: export default buildConfig({
38:   admin: {
39:     user: Users.slug,
40:     importMap: {
41:       baseDir: path.resolve(dirname),
42:     },
43:   },
44:   collections: [
45:     Users,
46:     Media,
47:     Contacts,
48:     DietaryRestrictions,
49:     DrinkMenuItems,
50:     DrinkSubcategories,
51:     EmployeeRatings,
52:     Features,
53:     HotspotLogins,
54:     Incidents,
55:     Jobs,
56:     Locations,
57:     ManagerReports,
58:     Messages,
59:     MessageTypes,
60:     QrFeedback,
61:     Questions,
62:     ReviewKeywords,
63:     Reviews,
64:     ServerReports,
65:     ShiftTypes,
66:     Upgrades,
67:     UpgradeTypes,
68:   ],
69:   editor: lexicalEditor(),
70:   secret: process.env.PAYLOAD_SECRET || '',
71:   typescript: {
72:     outputFile: path.resolve(dirname, 'payload-types.ts'),
73:   },
74:   db: vercelPostgresAdapter({
75:     pool: {
76:       connectionString: process.env.POSTGRES_URL || '',
77:     },
78:   }),
79:   sharp,
80:   plugins: [
81:     payloadCloudPlugin(),
82:     // storage-adapter-placeholder
83:   ],
84: })
</file>

<file path="payload-backend/tests/e2e/frontend.e2e.spec.ts">
 1: import { test, expect, Page } from '@playwright/test'
 2: 
 3: test.describe('Frontend', () => {
 4:   let page: Page
 5: 
 6:   test.beforeAll(async ({ browser }, testInfo) => {
 7:     const context = await browser.newContext()
 8:     page = await context.newPage()
 9:   })
10: 
11:   test('can go on homepage', async ({ page }) => {
12:     await page.goto('http://localhost:3000')
13: 
14:     await expect(page).toHaveTitle(/Payload Blank Template/)
15: 
16:     const headging = page.locator('h1').first()
17: 
18:     await expect(headging).toHaveText('Welcome to your new project.')
19:   })
20: })
</file>

<file path="payload-backend/tests/int/api.int.spec.ts">
 1: import { getPayload, Payload } from 'payload'
 2: import config from '@/payload.config'
 3: 
 4: import { describe, it, beforeAll, expect } from 'vitest'
 5: 
 6: let payload: Payload
 7: 
 8: describe('API', () => {
 9:   beforeAll(async () => {
10:     const payloadConfig = await config
11:     payload = await getPayload({ config: payloadConfig })
12:   })
13: 
14:   it('fetches users', async () => {
15:     const users = await payload.find({
16:       collection: 'users',
17:     })
18:     expect(users).toBeDefined()
19:   })
20: })
</file>

<file path="payload-backend/.env.example">
1: DATABASE_URI=postgresql://user:password@localhost:5432/your-database-name
2: PAYLOAD_SECRET=YOUR_SECRET_HERE
</file>

<file path="payload-backend/.prettierrc.json">
1: {
2:   "singleQuote": true,
3:   "trailingComma": "all",
4:   "printWidth": 100,
5:   "semi": false
6: }
</file>

<file path="payload-backend/docker-compose.yml">
 1: version: '3'
 2: 
 3: services:
 4:   payload:
 5:     image: node:18-alpine
 6:     ports:
 7:       - '4000:3000'
 8:     volumes:
 9:       - .:/home/node/app
10:       - node_modules:/home/node/app/node_modules
11:     working_dir: /home/node/app/
12:     command: sh -c "corepack enable && corepack prepare pnpm@latest --activate && pnpm install && pnpm dev"
13:     depends_on:
14:       - postgres
15:     env_file:
16:       - .env
17: 
18:   postgres:
19:     restart: always
20:     image: postgres:latest
21:     volumes:
22:       - pgdata:/var/lib/postgresql/data
23:     ports:
24:       - "5432:5432"
25: 
26: volumes:
27:   pgdata:
28:   node_modules:
</file>

<file path="payload-backend/eslint.config.mjs">
 1: import { dirname } from 'path'
 2: import { fileURLToPath } from 'url'
 3: import { FlatCompat } from '@eslint/eslintrc/dist/eslintrc.cjs'
 4: 
 5: const __filename = fileURLToPath(import.meta.url)
 6: const __dirname = dirname(__filename)
 7: 
 8: const compat = new FlatCompat({
 9:   baseDirectory: __dirname,
10: })
11: 
12: const eslintConfig = [
13:   ...compat.extends('next/core-web-vitals', 'next/typescript'),
14:   {
15:     rules: {
16:       '@typescript-eslint/ban-ts-comment': 'warn',
17:       '@typescript-eslint/no-empty-object-type': 'warn',
18:       '@typescript-eslint/no-explicit-any': 'warn',
19:       '@typescript-eslint/no-unused-vars': [
20:         'warn',
21:         {
22:           vars: 'all',
23:           args: 'after-used',
24:           ignoreRestSiblings: false,
25:           argsIgnorePattern: '^_',
26:           varsIgnorePattern: '^_',
27:           destructuredArrayIgnorePattern: '^_',
28:           caughtErrorsIgnorePattern: '^(_|ignore)',
29:         },
30:       ],
31:     },
32:   },
33:   {
34:     ignores: ['.next/'],
35:   },
36: ]
37: 
38: export default eslintConfig
</file>

<file path="payload-backend/next.config.mjs">
 1: import { withPayload } from '@payloadcms/next/withPayload'
 2: 
 3: /** @type {import('next').NextConfig} */
 4: const nextConfig = {
 5:   // Restaurant Management System Configuration
 6:   experimental: {
 7:     reactCompiler: false,
 8:     serverComponentsExternalPackages: ['sharp'],
 9:   },
10: 
11:   // Image optimization for restaurant photos and media
12:   images: {
13:     domains: ['localhost', 'your-domain.com'],
14:     formats: ['image/webp', 'image/avif'],
15:     deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
16:     imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
17:   },
18: 
19:   // Security headers for restaurant data protection
20:   async headers() {
21:     return [
22:       {
23:         source: '/(.*)',
24:         headers: [
25:           {
26:             key: 'X-Frame-Options',
27:             value: 'DENY',
28:           },
29:           {
30:             key: 'X-Content-Type-Options',
31:             value: 'nosniff',
32:           },
33:           {
34:             key: 'Referrer-Policy',
35:             value: 'origin-when-cross-origin',
36:           },
37:         ],
38:       },
39:     ]
40:   },
41: 
42:   // Webpack configuration for restaurant management modules
43:   webpack: (webpackConfig) => {
44:     webpackConfig.resolve.extensionAlias = {
45:       '.cjs': ['.cts', '.cjs'],
46:       '.js': ['.ts', '.tsx', '.js', '.jsx'],
47:       '.mjs': ['.mts', '.mjs'],
48:     }
49: 
50:     return webpackConfig
51:   },
52: 
53:   // Environment variables for restaurant configuration
54:   env: {
55:     RESTAURANT_NAME: process.env.RESTAURANT_NAME,
56:     RESTAURANT_TIMEZONE: process.env.RESTAURANT_TIMEZONE,
57:     RATING_SCALE_MAX: process.env.RATING_SCALE_MAX,
58:   },
59: }
60: 
61: export default withPayload(nextConfig, { devBundleServerPackages: false })
</file>

<file path="payload-backend/package.json">
 1: {
 2:   "name": "payload-backend",
 3:   "version": "1.0.0",
 4:   "description": "A blank template to get started with Payload 3.0",
 5:   "license": "MIT",
 6:   "type": "module",
 7:   "scripts": {
 8:     "build": "cross-env NODE_OPTIONS=\"--no-deprecation --max-old-space-size=8000\" next build",
 9:     "dev": "cross-env NODE_OPTIONS=--no-deprecation next dev -p 4000",
10:     "devsafe": "rm -rf .next && cross-env NODE_OPTIONS=--no-deprecation next dev",
11:     "generate:importmap": "cross-env NODE_OPTIONS=--no-deprecation payload generate:importmap",
12:     "generate:types": "cross-env NODE_OPTIONS=--no-deprecation payload generate:types",
13:     "lint": "cross-env NODE_OPTIONS=--no-deprecation next lint",
14:     "payload": "cross-env NODE_OPTIONS=--no-deprecation payload",
15:     "start": "cross-env NODE_OPTIONS=--no-deprecation next start",
16:     "test": "pnpm run test:int && pnpm run test:e2e",
17:     "test:e2e": "cross-env NODE_OPTIONS=\"--no-deprecation --no-experimental-strip-types\" pnpm exec playwright test",
18:     "test:int": "cross-env NODE_OPTIONS=--no-deprecation vitest run --config ./vitest.config.mts"
19:   },
20:   "dependencies": {
21:     "@hookform/resolvers": "^5.1.1",
22:     "@payloadcms/db-vercel-postgres": "3.44.0",
23:     "@payloadcms/next": "3.44.0",
24:     "@payloadcms/payload-cloud": "3.44.0",
25:     "@payloadcms/richtext-lexical": "3.44.0",
26:     "@payloadcms/ui": "3.44.0",
27:     "@radix-ui/react-slot": "^1.2.3",
28:     "@tanstack/react-query": "^5.81.5",
29:     "@tanstack/react-query-devtools": "^5.81.5",
30:     "class-variance-authority": "^0.7.1",
31:     "clsx": "^2.1.1",
32:     "cross-env": "^7.0.3",
33:     "dotenv": "16.4.7",
34:     "graphql": "^16.8.1",
35:     "lucide-react": "^0.525.0",
36:     "next": "15.3.2",
37:     "payload": "3.44.0",
38:     "react": "19.1.0",
39:     "react-hook-form": "^7.59.0",
40:     "sharp": "0.32.6",
41:     "tailwind-merge": "^3.3.1",
42:     "zod": "^3.25.67",
43:     "zustand": "^5.0.6"
44:   },
45:   "devDependencies": {
46:     "@playwright/test": "1.50.0",
47:     "@testing-library/react": "16.3.0",
48:     "@types/node": "^22.5.4",
49:     "@types/react": "19.1.0",
50:     "@types/react-dom": "19.1.2",
51:     "@vitejs/plugin-react": "4.5.2",
52:     "autoprefixer": "^10.4.21",
53:     "eslint": "^9.16.0",
54:     "eslint-config-next": "15.3.0",
55:     "jsdom": "26.1.0",
56:     "playwright": "1.50.0",
57:     "playwright-core": "1.50.0",
58:     "postcss": "^8.5.6",
59:     "prettier": "^3.4.2",
60:     "tailwindcss": "^4.1.11",
61:     "typescript": "5.7.3",
62:     "vite-tsconfig-paths": "5.1.4",
63:     "vitest": "3.2.3"
64:   },
65:   "engines": {
66:     "node": "^18.20.2 || >=20.9.0",
67:     "pnpm": "^9 || ^10"
68:   },
69:   "pnpm": {
70:     "onlyBuiltDependencies": [
71:       "sharp",
72:       "esbuild",
73:       "unrs-resolver"
74:     ]
75:   }
76: }
</file>

<file path="payload-backend/playwright.config.ts">
 1: import { defineConfig, devices } from '@playwright/test'
 2: 
 3: /**
 4:  * Read environment variables from file.
 5:  * https://github.com/motdotla/dotenv
 6:  */
 7: import 'dotenv/config'
 8: 
 9: /**
10:  * See https://playwright.dev/docs/test-configuration.
11:  */
12: export default defineConfig({
13:   testDir: './tests/e2e',
14:   /* Fail the build on CI if you accidentally left test.only in the source code. */
15:   forbidOnly: !!process.env.CI,
16:   /* Retry on CI only */
17:   retries: process.env.CI ? 2 : 0,
18:   /* Opt out of parallel tests on CI. */
19:   workers: process.env.CI ? 1 : undefined,
20:   /* Reporter to use. See https://playwright.dev/docs/test-reporters */
21:   reporter: 'html',
22:   /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
23:   use: {
24:     /* Base URL to use in actions like `await page.goto('/')`. */
25:     // baseURL: 'http://localhost:3000',
26: 
27:     /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
28:     trace: 'on-first-retry',
29:   },
30:   projects: [
31:     {
32:       name: 'chromium',
33:       use: { ...devices['Desktop Chrome'] },
34:     },
35:   ],
36:   webServer: {
37:     command: 'pnpm dev',
38:     reuseExistingServer: true,
39:     url: 'http://localhost:3000',
40:   },
41: })
</file>

<file path="payload-backend/README.md">
 1: # Payload Blank Template
 2: 
 3: This template comes configured with the bare minimum to get started on anything you need.
 4: 
 5: ## Quick start
 6: 
 7: This template can be deployed directly from our Cloud hosting and it will setup MongoDB and cloud S3 object storage for media.
 8: 
 9: ## Quick Start - local setup
10: 
11: To spin up this template locally, follow these steps:
12: 
13: ### Clone
14: 
15: After you click the `Deploy` button above, you'll want to have standalone copy of this repo on your machine. If you've already cloned this repo, skip to [Development](#development).
16: 
17: ### Development
18: 
19: 1. First [clone the repo](#clone) if you have not done so already
20: 2. `cd my-project && cp .env.example .env` to copy the example environment variables. You'll need to add the `MONGODB_URI` from your Cloud project to your `.env` if you want to use S3 storage and the MongoDB database that was created for you.
21: 
22: 3. `pnpm install && pnpm dev` to install dependencies and start the dev server
23: 4. open `http://localhost:3000` to open the app in your browser
24: 
25: That's it! Changes made in `./src` will be reflected in your app. Follow the on-screen instructions to login and create your first admin user. Then check out [Production](#production) once you're ready to build and serve your app, and [Deployment](#deployment) when you're ready to go live.
26: 
27: #### Docker (Optional)
28: 
29: If you prefer to use Docker for local development, the provided docker-compose.yml file can be used with PostgreSQL.
30: 
31: To do so, follow these steps:
32: 
33: - Ensure your `.env` file's `DATABASE_URI` is configured for PostgreSQL (e.g., `postgresql://user:password@localhost:5432/your-database-name`).
34: - Run `docker-compose up` to start the database, optionally pass `-d` to run in the background.
35: 
36: ## How it works
37: 
38: The Payload config is tailored specifically to the needs of most websites. It is pre-configured in the following ways:
39: 
40: ### Collections
41: 
42: See the [Collections](https://payloadcms.com/docs/configuration/collections) docs for details on how to extend this functionality.
43: 
44: - #### Users (Authentication)
45: 
46:   Users are auth-enabled collections that have access to the admin panel.
47: 
48:   For additional help, see the official [Auth Example](https://github.com/payloadcms/payload/tree/main/examples/auth) or the [Authentication](https://payloadcms.com/docs/authentication/overview#authentication-overview) docs.
49: 
50: - #### Media
51: 
52:   This is the uploads enabled collection. It features pre-configured sizes, focal point and manual resizing to help you manage your pictures.
53: 
54: ### Docker
55: 
56: Alternatively, you can use [Docker](https://www.docker.com) to spin up this template locally. To do so, follow these steps:
57: 
58: 1. Follow [steps 1 and 2 from above](#development), the docker-compose file will automatically use the `.env` file in your project root
59: 1. Next run `docker-compose up`
60: 1. Follow [steps 4 and 5 from above](#development) to login and create your first admin user
61: 
62: That's it! The Docker instance will help you get up and running quickly while also standardizing the development environment across your teams.
63: 
64: ## Questions
65: 
66: If you have any issues or questions, reach out to us on [Discord](https://discord.com/invite/payload) or start a [GitHub discussion](https://github.com/payloadcms/payload/discussions).
</file>

<file path="payload-backend/tsconfig.json">
 1: {
 2:   "compilerOptions": {
 3:     "baseUrl": ".",
 4:     "lib": ["DOM", "DOM.Iterable", "ES2022"],
 5:     "allowJs": true,
 6:     "skipLibCheck": true,
 7:     "strict": true,
 8:     "noEmit": true,
 9:     "esModuleInterop": true,
10:     "module": "esnext",
11:     "moduleResolution": "bundler",
12:     "resolveJsonModule": true,
13:     "isolatedModules": true,
14:     "jsx": "preserve",
15:     "incremental": true,
16:     "plugins": [
17:       {
18:         "name": "next"
19:       }
20:     ],
21:     "paths": {
22:       "@/*": ["./src/*"],
23:       "@payload-config": ["./src/payload.config.ts"],
24:       "@/collections/*": ["./src/collections/*"],
25:       "@/components/*": ["./src/components/*"],
26:       "@/lib/*": ["./src/lib/*"],
27:       "@/types/*": ["./src/types/*"],
28:       "@/hooks/*": ["./src/hooks/*"],
29:       "@/utils/*": ["./src/utils/*"]
30:     },
31:     "target": "ES2022"
32:   },
33:   "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
34:   "exclude": ["node_modules"]
35: }
</file>

<file path="payload-backend/vitest.config.mts">
 1: import { defineConfig } from 'vitest/config'
 2: import react from '@vitejs/plugin-react'
 3: import tsconfigPaths from 'vite-tsconfig-paths'
 4: 
 5: export default defineConfig({
 6:   plugins: [tsconfigPaths(), react()],
 7:   test: {
 8:     environment: 'jsdom',
 9:     setupFiles: ['./vitest.setup.ts'],
10:     include: ['tests/int/**/*.int.spec.ts'],
11:   },
12: })
</file>

<file path="payload-backend/vitest.setup.ts">
1: // Any setup scripts you might need go here
2: 
3: // Load .env files
4: import 'dotenv/config'
</file>

<file path="repomix.config.json">
 1: {
 2:   "include": [
 3:     "**/*.ts",
 4:     "**/*.tsx",
 5:     "**/*.js",
 6:     "**/*.jsx",
 7:     "**/*.json",
 8:     "**/*.md",
 9:     "**/*.yml",
10:     "**/*.yaml",
11:     "**/*.env.example",
12:     "**/*.config.*",
13:     "**/*.mjs",
14:     "**/*.mts"
15:   ],
16:   "ignore": {
17:     "useGitignore": true,
18:     "useDefaultPatterns": true,
19:     "customPatterns": [
20:       "node_modules/**",
21:       ".git/**",
22:       "dist/**",
23:       "build/**",
24:       ".next/**",
25:       "coverage/**",
26:       "*.log",
27:       "*.lock",
28:       "pnpm-lock.yaml",
29:       "yarn.lock",
30:       "package-lock.json",
31:       ".env",
32:       ".env.local",
33:       ".env.production",
34:       "**/.DS_Store",
35:       "**/Thumbs.db",
36:       "**/*.min.js",
37:       "**/*.min.css",
38:       "**/payload-types.ts",
39:       "**/*.d.ts",
40:       "repomix-output.*"
41:     ]
42:   },
43:   "output": {
44:     "filePath": "repomix-output.xml",
45:     "style": "xml",
46:     "headerText": "Canvas Payload v3 Restaurant Management System - Complete Codebase",
47:     "removeComments": false,
48:     "removeEmptyLines": false,
49:     "topFilesLength": 12,
50:     "showLineNumbers": true
51:   },
52:   "security": {
53:     "enableSecurityCheck": true
54:   }
55: }
</file>

<file path=".clinerules/cline_rules.md">
 1: ---
 2: description: Guidelines for creating and maintaining Cline rules to ensure consistency and effectiveness.
 3: globs: .cline/rules/*.md
 4: alwaysApply: true
 5: ---
 6: 
 7: - **Required Rule Structure:**
 8:   ```markdown
 9:   ---
10:   description: Clear, one-line description of what the rule enforces
11:   globs: path/to/files/*.ext, other/path/**/*
12:   alwaysApply: boolean
13:   ---
14: 
15:   - **Main Points in Bold**
16:     - Sub-points with details
17:     - Examples and explanations
18:   ```
19: 
20: - **File References:**
21:   - Use `[filename](mdc:path/to/file)` ([filename](mdc:filename)) to reference files
22:   - Example: [prisma.md](.clinerules/prisma.md) for rule references
23:   - Example: [schema.prisma](mdc:prisma/schema.prisma) for code references
24: 
25: - **Code Examples:**
26:   - Use language-specific code blocks
27:   ```typescript
28:   //  DO: Show good examples
29:   const goodExample = true;
30:   
31:   //  DON'T: Show anti-patterns
32:   const badExample = false;
33:   ```
34: 
35: - **Rule Content Guidelines:**
36:   - Start with high-level overview
37:   - Include specific, actionable requirements
38:   - Show examples of correct implementation
39:   - Reference existing code when possible
40:   - Keep rules DRY by referencing other rules
41: 
42: - **Rule Maintenance:**
43:   - Update rules when new patterns emerge
44:   - Add examples from actual codebase
45:   - Remove outdated patterns
46:   - Cross-reference related rules
47: 
48: - **Best Practices:**
49:   - Use bullet points for clarity
50:   - Keep descriptions concise
51:   - Include both DO and DON'T examples
52:   - Reference actual code over theoretical examples
53:   - Use consistent formatting across rules
</file>

<file path=".clinerules/dev_workflow.md">
  1: ---
  2: description: Guide for using Taskmaster to manage task-driven development workflows
  3: globs: **/*
  4: alwaysApply: true
  5: ---
  6: 
  7: # Taskmaster Development Workflow
  8: 
  9: This guide outlines the standard process for using Taskmaster to manage software development projects. It is written as a set of instructions for you, the AI agent.
 10: 
 11: - **Your Default Stance**: For most projects, the user can work directly within the `master` task context. Your initial actions should operate on this default context unless a clear pattern for multi-context work emerges.
 12: - **Your Goal**: Your role is to elevate the user's workflow by intelligently introducing advanced features like **Tagged Task Lists** when you detect the appropriate context. Do not force tags on the user; suggest them as a helpful solution to a specific need.
 13: 
 14: ## The Basic Loop
 15: The fundamental development cycle you will facilitate is:
 16: 1.  **`list`**: Show the user what needs to be done.
 17: 2.  **`next`**: Help the user decide what to work on.
 18: 3.  **`show <id>`**: Provide details for a specific task.
 19: 4.  **`expand <id>`**: Break down a complex task into smaller, manageable subtasks.
 20: 5.  **Implement**: The user writes the code and tests.
 21: 6.  **`update-subtask`**: Log progress and findings on behalf of the user.
 22: 7.  **`set-status`**: Mark tasks and subtasks as `done` as work is completed.
 23: 8.  **Repeat**.
 24: 
 25: All your standard command executions should operate on the user's current task context, which defaults to `master`.
 26: 
 27: ---
 28: 
 29: ## Standard Development Workflow Process
 30: 
 31: ### Simple Workflow (Default Starting Point)
 32: 
 33: For new projects or when users are getting started, operate within the `master` tag context:
 34: 
 35: -   Start new projects by running `initialize_project` tool / `task-master init` or `parse_prd` / `task-master parse-prd --input='<prd-file.txt>'` (see @`taskmaster.md`) to generate initial tasks.json with tagged structure
 36: -   Configure rule sets during initialization with `--rules` flag (e.g., `task-master init --rules cline,windsurf`) or manage them later with `task-master rules add/remove` commands  
 37: -   Begin coding sessions with `get_tasks` / `task-master list` (see @`taskmaster.md`) to see current tasks, status, and IDs
 38: -   Determine the next task to work on using `next_task` / `task-master next` (see @`taskmaster.md`)
 39: -   Analyze task complexity with `analyze_project_complexity` / `task-master analyze-complexity --research` (see @`taskmaster.md`) before breaking down tasks
 40: -   Review complexity report using `complexity_report` / `task-master complexity-report` (see @`taskmaster.md`)
 41: -   Select tasks based on dependencies (all marked 'done'), priority level, and ID order
 42: -   View specific task details using `get_task` / `task-master show <id>` (see @`taskmaster.md`) to understand implementation requirements
 43: -   Break down complex tasks using `expand_task` / `task-master expand --id=<id> --force --research` (see @`taskmaster.md`) with appropriate flags like `--force` (to replace existing subtasks) and `--research`
 44: -   Implement code following task details, dependencies, and project standards
 45: -   Mark completed tasks with `set_task_status` / `task-master set-status --id=<id> --status=done` (see @`taskmaster.md`)
 46: -   Update dependent tasks when implementation differs from original plan using `update` / `task-master update --from=<id> --prompt="..."` or `update_task` / `task-master update-task --id=<id> --prompt="..."` (see @`taskmaster.md`)
 47: 
 48: ---
 49: 
 50: ## Leveling Up: Agent-Led Multi-Context Workflows
 51: 
 52: While the basic workflow is powerful, your primary opportunity to add value is by identifying when to introduce **Tagged Task Lists**. These patterns are your tools for creating a more organized and efficient development environment for the user, especially if you detect agentic or parallel development happening across the same session.
 53: 
 54: **Critical Principle**: Most users should never see a difference in their experience. Only introduce advanced workflows when you detect clear indicators that the project has evolved beyond simple task management.
 55: 
 56: ### When to Introduce Tags: Your Decision Patterns
 57: 
 58: Here are the patterns to look for. When you detect one, you should propose the corresponding workflow to the user.
 59: 
 60: #### Pattern 1: Simple Git Feature Branching
 61: This is the most common and direct use case for tags.
 62: 
 63: - **Trigger**: The user creates a new git branch (e.g., `git checkout -b feature/user-auth`).
 64: - **Your Action**: Propose creating a new tag that mirrors the branch name to isolate the feature's tasks from `master`.
 65: - **Your Suggested Prompt**: *"I see you've created a new branch named 'feature/user-auth'. To keep all related tasks neatly organized and separate from your main list, I can create a corresponding task tag for you. This helps prevent merge conflicts in your `tasks.json` file later. Shall I create the 'feature-user-auth' tag?"*
 66: - **Tool to Use**: `task-master add-tag --from-branch`
 67: 
 68: #### Pattern 2: Team Collaboration
 69: - **Trigger**: The user mentions working with teammates (e.g., "My teammate Alice is handling the database schema," or "I need to review Bob's work on the API.").
 70: - **Your Action**: Suggest creating a separate tag for the user's work to prevent conflicts with shared master context.
 71: - **Your Suggested Prompt**: *"Since you're working with Alice, I can create a separate task context for your work to avoid conflicts. This way, Alice can continue working with the master list while you have your own isolated context. When you're ready to merge your work, we can coordinate the tasks back to master. Shall I create a tag for your current work?"*
 72: - **Tool to Use**: `task-master add-tag my-work --copy-from-current --description="My tasks while collaborating with Alice"`
 73: 
 74: #### Pattern 3: Experiments or Risky Refactors
 75: - **Trigger**: The user wants to try something that might not be kept (e.g., "I want to experiment with switching our state management library," or "Let's refactor the old API module, but I want to keep the current tasks as a reference.").
 76: - **Your Action**: Propose creating a sandboxed tag for the experimental work.
 77: - **Your Suggested Prompt**: *"This sounds like a great experiment. To keep these new tasks separate from our main plan, I can create a temporary 'experiment-zustand' tag for this work. If we decide not to proceed, we can simply delete the tag without affecting the main task list. Sound good?"*
 78: - **Tool to Use**: `task-master add-tag experiment-zustand --description="Exploring Zustand migration"`
 79: 
 80: #### Pattern 4: Large Feature Initiatives (PRD-Driven)
 81: This is a more structured approach for significant new features or epics.
 82: 
 83: - **Trigger**: The user describes a large, multi-step feature that would benefit from a formal plan.
 84: - **Your Action**: Propose a comprehensive, PRD-driven workflow.
 85: - **Your Suggested Prompt**: *"This sounds like a significant new feature. To manage this effectively, I suggest we create a dedicated task context for it. Here's the plan: I'll create a new tag called 'feature-xyz', then we can draft a Product Requirements Document (PRD) together to scope the work. Once the PRD is ready, I'll automatically generate all the necessary tasks within that new tag. How does that sound?"*
 86: - **Your Implementation Flow**:
 87:     1.  **Create an empty tag**: `task-master add-tag feature-xyz --description "Tasks for the new XYZ feature"`. You can also start by creating a git branch if applicable, and then create the tag from that branch.
 88:     2.  **Collaborate & Create PRD**: Work with the user to create a detailed PRD file (e.g., `.taskmaster/docs/feature-xyz-prd.txt`).
 89:     3.  **Parse PRD into the new tag**: `task-master parse-prd .taskmaster/docs/feature-xyz-prd.txt --tag feature-xyz`
 90:     4.  **Prepare the new task list**: Follow up by suggesting `analyze-complexity` and `expand-all` for the newly created tasks within the `feature-xyz` tag.
 91: 
 92: #### Pattern 5: Version-Based Development
 93: Tailor your approach based on the project maturity indicated by tag names.
 94: 
 95: - **Prototype/MVP Tags** (`prototype`, `mvp`, `poc`, `v0.x`):
 96:   - **Your Approach**: Focus on speed and functionality over perfection
 97:   - **Task Generation**: Create tasks that emphasize "get it working" over "get it perfect"
 98:   - **Complexity Level**: Lower complexity, fewer subtasks, more direct implementation paths
 99:   - **Research Prompts**: Include context like "This is a prototype - prioritize speed and basic functionality over optimization"
100:   - **Example Prompt Addition**: *"Since this is for the MVP, I'll focus on tasks that get core functionality working quickly rather than over-engineering."*
101: 
102: - **Production/Mature Tags** (`v1.0+`, `production`, `stable`):
103:   - **Your Approach**: Emphasize robustness, testing, and maintainability
104:   - **Task Generation**: Include comprehensive error handling, testing, documentation, and optimization
105:   - **Complexity Level**: Higher complexity, more detailed subtasks, thorough implementation paths
106:   - **Research Prompts**: Include context like "This is for production - prioritize reliability, performance, and maintainability"
107:   - **Example Prompt Addition**: *"Since this is for production, I'll ensure tasks include proper error handling, testing, and documentation."*
108: 
109: ### Advanced Workflow (Tag-Based & PRD-Driven)
110: 
111: **When to Transition**: Recognize when the project has evolved (or has initiated a project which existing code) beyond simple task management. Look for these indicators:
112: - User mentions teammates or collaboration needs
113: - Project has grown to 15+ tasks with mixed priorities
114: - User creates feature branches or mentions major initiatives
115: - User initializes Taskmaster on an existing, complex codebase
116: - User describes large features that would benefit from dedicated planning
117: 
118: **Your Role in Transition**: Guide the user to a more sophisticated workflow that leverages tags for organization and PRDs for comprehensive planning.
119: 
120: #### Master List Strategy (High-Value Focus)
121: Once you transition to tag-based workflows, the `master` tag should ideally contain only:
122: - **High-level deliverables** that provide significant business value
123: - **Major milestones** and epic-level features
124: - **Critical infrastructure** work that affects the entire project
125: - **Release-blocking** items
126: 
127: **What NOT to put in master**:
128: - Detailed implementation subtasks (these go in feature-specific tags' parent tasks)
129: - Refactoring work (create dedicated tags like `refactor-auth`)
130: - Experimental features (use `experiment-*` tags)
131: - Team member-specific tasks (use person-specific tags)
132: 
133: #### PRD-Driven Feature Development
134: 
135: **For New Major Features**:
136: 1. **Identify the Initiative**: When user describes a significant feature
137: 2. **Create Dedicated Tag**: `add_tag feature-[name] --description="[Feature description]"`
138: 3. **Collaborative PRD Creation**: Work with user to create comprehensive PRD in `.taskmaster/docs/feature-[name]-prd.txt`
139: 4. **Parse & Prepare**: 
140:    - `parse_prd .taskmaster/docs/feature-[name]-prd.txt --tag=feature-[name]`
141:    - `analyze_project_complexity --tag=feature-[name] --research`
142:    - `expand_all --tag=feature-[name] --research`
143: 5. **Add Master Reference**: Create a high-level task in `master` that references the feature tag
144: 
145: **For Existing Codebase Analysis**:
146: When users initialize Taskmaster on existing projects:
147: 1. **Codebase Discovery**: Use your native tools for producing deep context about the code base. You may use `research` tool with `--tree` and `--files` to collect up to date information using the existing architecture as context.
148: 2. **Collaborative Assessment**: Work with user to identify improvement areas, technical debt, or new features
149: 3. **Strategic PRD Creation**: Co-author PRDs that include:
150:    - Current state analysis (based on your codebase research)
151:    - Proposed improvements or new features
152:    - Implementation strategy considering existing code
153: 4. **Tag-Based Organization**: Parse PRDs into appropriate tags (`refactor-api`, `feature-dashboard`, `tech-debt`, etc.)
154: 5. **Master List Curation**: Keep only the most valuable initiatives in master
155: 
156: The parse-prd's `--append` flag enables the user to parse multple PRDs within tags or across tags. PRDs should be focused and the number of tasks they are parsed into should be strategically chosen relative to the PRD's complexity and level of detail.
157: 
158: ### Workflow Transition Examples
159: 
160: **Example 1: Simple  Team-Based**
161: ```
162: User: "Alice is going to help with the API work"
163: Your Response: "Great! To avoid conflicts, I'll create a separate task context for your work. Alice can continue with the master list while you work in your own context. When you're ready to merge, we can coordinate the tasks back together."
164: Action: add_tag my-api-work --copy-from-current --description="My API tasks while collaborating with Alice"
165: ```
166: 
167: **Example 2: Simple  PRD-Driven**
168: ```
169: User: "I want to add a complete user dashboard with analytics, user management, and reporting"
170: Your Response: "This sounds like a major feature that would benefit from detailed planning. Let me create a dedicated context for this work and we can draft a PRD together to ensure we capture all requirements."
171: Actions: 
172: 1. add_tag feature-dashboard --description="User dashboard with analytics and management"
173: 2. Collaborate on PRD creation
174: 3. parse_prd dashboard-prd.txt --tag=feature-dashboard
175: 4. Add high-level "User Dashboard" task to master
176: ```
177: 
178: **Example 3: Existing Project  Strategic Planning**
179: ```
180: User: "I just initialized Taskmaster on my existing React app. It's getting messy and I want to improve it."
181: Your Response: "Let me research your codebase to understand the current architecture, then we can create a strategic plan for improvements."
182: Actions:
183: 1. research "Current React app architecture and improvement opportunities" --tree --files=src/
184: 2. Collaborate on improvement PRD based on findings
185: 3. Create tags for different improvement areas (refactor-components, improve-state-management, etc.)
186: 4. Keep only major improvement initiatives in master
187: ```
188: 
189: ---
190: 
191: ## Primary Interaction: MCP Server vs. CLI
192: 
193: Taskmaster offers two primary ways to interact:
194: 
195: 1.  **MCP Server (Recommended for Integrated Tools)**:
196:     - For AI agents and integrated development environments (like Cline), interacting via the **MCP server is the preferred method**.
197:     - The MCP server exposes Taskmaster functionality through a set of tools (e.g., `get_tasks`, `add_subtask`).
198:     - This method offers better performance, structured data exchange, and richer error handling compared to CLI parsing.
199:     - Refer to @`mcp.md` for details on the MCP architecture and available tools.
200:     - A comprehensive list and description of MCP tools and their corresponding CLI commands can be found in @`taskmaster.md`.
201:     - **Restart the MCP server** if core logic in `scripts/modules` or MCP tool/direct function definitions change.
202:     - **Note**: MCP tools fully support tagged task lists with complete tag management capabilities.
203: 
204: 2.  **`task-master` CLI (For Users & Fallback)**:
205:     - The global `task-master` command provides a user-friendly interface for direct terminal interaction.
206:     - It can also serve as a fallback if the MCP server is inaccessible or a specific function isn't exposed via MCP.
207:     - Install globally with `npm install -g task-master-ai` or use locally via `npx task-master-ai ...`.
208:     - The CLI commands often mirror the MCP tools (e.g., `task-master list` corresponds to `get_tasks`).
209:     - Refer to @`taskmaster.md` for a detailed command reference.
210:     - **Tagged Task Lists**: CLI fully supports the new tagged system with seamless migration.
211: 
212: ## How the Tag System Works (For Your Reference)
213: 
214: - **Data Structure**: Tasks are organized into separate contexts (tags) like "master", "feature-branch", or "v2.0".
215: - **Silent Migration**: Existing projects automatically migrate to use a "master" tag with zero disruption.
216: - **Context Isolation**: Tasks in different tags are completely separate. Changes in one tag do not affect any other tag.
217: - **Manual Control**: The user is always in control. There is no automatic switching. You facilitate switching by using `use-tag <name>`.
218: - **Full CLI & MCP Support**: All tag management commands are available through both the CLI and MCP tools for you to use. Refer to @`taskmaster.md` for a full command list.
219: 
220: ---
221: 
222: ## Task Complexity Analysis
223: 
224: -   Run `analyze_project_complexity` / `task-master analyze-complexity --research` (see @`taskmaster.md`) for comprehensive analysis
225: -   Review complexity report via `complexity_report` / `task-master complexity-report` (see @`taskmaster.md`) for a formatted, readable version.
226: -   Focus on tasks with highest complexity scores (8-10) for detailed breakdown
227: -   Use analysis results to determine appropriate subtask allocation
228: -   Note that reports are automatically used by the `expand_task` tool/command
229: 
230: ## Task Breakdown Process
231: 
232: -   Use `expand_task` / `task-master expand --id=<id>`. It automatically uses the complexity report if found, otherwise generates default number of subtasks.
233: -   Use `--num=<number>` to specify an explicit number of subtasks, overriding defaults or complexity report recommendations.
234: -   Add `--research` flag to leverage Perplexity AI for research-backed expansion.
235: -   Add `--force` flag to clear existing subtasks before generating new ones (default is to append).
236: -   Use `--prompt="<context>"` to provide additional context when needed.
237: -   Review and adjust generated subtasks as necessary.
238: -   Use `expand_all` tool or `task-master expand --all` to expand multiple pending tasks at once, respecting flags like `--force` and `--research`.
239: -   If subtasks need complete replacement (regardless of the `--force` flag on `expand`), clear them first with `clear_subtasks` / `task-master clear-subtasks --id=<id>`.
240: 
241: ## Implementation Drift Handling
242: 
243: -   When implementation differs significantly from planned approach
244: -   When future tasks need modification due to current implementation choices
245: -   When new dependencies or requirements emerge
246: -   Use `update` / `task-master update --from=<futureTaskId> --prompt='<explanation>\nUpdate context...' --research` to update multiple future tasks.
247: -   Use `update_task` / `task-master update-task --id=<taskId> --prompt='<explanation>\nUpdate context...' --research` to update a single specific task.
248: 
249: ## Task Status Management
250: 
251: -   Use 'pending' for tasks ready to be worked on
252: -   Use 'done' for completed and verified tasks
253: -   Use 'deferred' for postponed tasks
254: -   Add custom status values as needed for project-specific workflows
255: 
256: ## Task Structure Fields
257: 
258: - **id**: Unique identifier for the task (Example: `1`, `1.1`)
259: - **title**: Brief, descriptive title (Example: `"Initialize Repo"`)
260: - **description**: Concise summary of what the task involves (Example: `"Create a new repository, set up initial structure."`)
261: - **status**: Current state of the task (Example: `"pending"`, `"done"`, `"deferred"`)
262: - **dependencies**: IDs of prerequisite tasks (Example: `[1, 2.1]`)
263:     - Dependencies are displayed with status indicators ( for completed,  for pending)
264:     - This helps quickly identify which prerequisite tasks are blocking work
265: - **priority**: Importance level (Example: `"high"`, `"medium"`, `"low"`)
266: - **details**: In-depth implementation instructions (Example: `"Use GitHub client ID/secret, handle callback, set session token."`) 
267: - **testStrategy**: Verification approach (Example: `"Deploy and call endpoint to confirm 'Hello World' response."`) 
268: - **subtasks**: List of smaller, more specific tasks (Example: `[{"id": 1, "title": "Configure OAuth", ...}]`) 
269: - Refer to task structure details (previously linked to `tasks.md`).
270: 
271: ## Configuration Management (Updated)
272: 
273: Taskmaster configuration is managed through two main mechanisms:
274: 
275: 1.  **`.taskmaster/config.json` File (Primary):**
276:     *   Located in the project root directory.
277:     *   Stores most configuration settings: AI model selections (main, research, fallback), parameters (max tokens, temperature), logging level, default subtasks/priority, project name, etc.
278:     *   **Tagged System Settings**: Includes `global.defaultTag` (defaults to "master") and `tags` section for tag management configuration.
279:     *   **Managed via `task-master models --setup` command.** Do not edit manually unless you know what you are doing.
280:     *   **View/Set specific models via `task-master models` command or `models` MCP tool.**
281:     *   Created automatically when you run `task-master models --setup` for the first time or during tagged system migration.
282: 
283: 2.  **Environment Variables (`.env` / `mcp.json`):**
284:     *   Used **only** for sensitive API keys and specific endpoint URLs.
285:     *   Place API keys (one per provider) in a `.env` file in the project root for CLI usage.
286:     *   For MCP/Cline integration, configure these keys in the `env` section of `.cline/mcp.json`.
287:     *   Available keys/variables: See `assets/env.example` or the Configuration section in the command reference (previously linked to `taskmaster.md`).
288: 
289: 3.  **`.taskmaster/state.json` File (Tagged System State):**
290:     *   Tracks current tag context and migration status.
291:     *   Automatically created during tagged system migration.
292:     *   Contains: `currentTag`, `lastSwitched`, `migrationNoticeShown`.
293: 
294: **Important:** Non-API key settings (like model selections, `MAX_TOKENS`, `TASKMASTER_LOG_LEVEL`) are **no longer configured via environment variables**. Use the `task-master models` command (or `--setup` for interactive configuration) or the `models` MCP tool.
295: **If AI commands FAIL in MCP** verify that the API key for the selected provider is present in the `env` section of `.cline/mcp.json`.
296: **If AI commands FAIL in CLI** verify that the API key for the selected provider is present in the `.env` file in the root of the project.
297: 
298: ## Rules Management
299: 
300: Taskmaster supports multiple AI coding assistant rule sets that can be configured during project initialization or managed afterward:
301: 
302: - **Available Profiles**: Claude Code, Cline, Codex, Cline, Roo Code, Trae, Windsurf (claude, cline, codex, cline, roo, trae, windsurf)
303: - **During Initialization**: Use `task-master init --rules cline,windsurf` to specify which rule sets to include
304: - **After Initialization**: Use `task-master rules add <profiles>` or `task-master rules remove <profiles>` to manage rule sets
305: - **Interactive Setup**: Use `task-master rules setup` to launch an interactive prompt for selecting rule profiles
306: - **Default Behavior**: If no `--rules` flag is specified during initialization, all available rule profiles are included
307: - **Rule Structure**: Each profile creates its own directory (e.g., `.cline/rules`, `.roo/rules`) with appropriate configuration files
308: 
309: ## Determining the Next Task
310: 
311: - Run `next_task` / `task-master next` to show the next task to work on.
312: - The command identifies tasks with all dependencies satisfied
313: - Tasks are prioritized by priority level, dependency count, and ID
314: - The command shows comprehensive task information including:
315:     - Basic task details and description
316:     - Implementation details
317:     - Subtasks (if they exist)
318:     - Contextual suggested actions
319: - Recommended before starting any new development work
320: - Respects your project's dependency structure
321: - Ensures tasks are completed in the appropriate sequence
322: - Provides ready-to-use commands for common task actions
323: 
324: ## Viewing Specific Task Details
325: 
326: - Run `get_task` / `task-master show <id>` to view a specific task.
327: - Use dot notation for subtasks: `task-master show 1.2` (shows subtask 2 of task 1)
328: - Displays comprehensive information similar to the next command, but for a specific task
329: - For parent tasks, shows all subtasks and their current status
330: - For subtasks, shows parent task information and relationship
331: - Provides contextual suggested actions appropriate for the specific task
332: - Useful for examining task details before implementation or checking status
333: 
334: ## Managing Task Dependencies
335: 
336: - Use `add_dependency` / `task-master add-dependency --id=<id> --depends-on=<id>` to add a dependency.
337: - Use `remove_dependency` / `task-master remove-dependency --id=<id> --depends-on=<id>` to remove a dependency.
338: - The system prevents circular dependencies and duplicate dependency entries
339: - Dependencies are checked for existence before being added or removed
340: - Task files are automatically regenerated after dependency changes
341: - Dependencies are visualized with status indicators in task listings and files
342: 
343: ## Task Reorganization
344: 
345: - Use `move_task` / `task-master move --from=<id> --to=<id>` to move tasks or subtasks within the hierarchy
346: - This command supports several use cases:
347:   - Moving a standalone task to become a subtask (e.g., `--from=5 --to=7`)
348:   - Moving a subtask to become a standalone task (e.g., `--from=5.2 --to=7`) 
349:   - Moving a subtask to a different parent (e.g., `--from=5.2 --to=7.3`)
350:   - Reordering subtasks within the same parent (e.g., `--from=5.2 --to=5.4`)
351:   - Moving a task to a new, non-existent ID position (e.g., `--from=5 --to=25`)
352:   - Moving multiple tasks at once using comma-separated IDs (e.g., `--from=10,11,12 --to=16,17,18`)
353: - The system includes validation to prevent data loss:
354:   - Allows moving to non-existent IDs by creating placeholder tasks
355:   - Prevents moving to existing task IDs that have content (to avoid overwriting)
356:   - Validates source tasks exist before attempting to move them
357: - The system maintains proper parent-child relationships and dependency integrity
358: - Task files are automatically regenerated after the move operation
359: - This provides greater flexibility in organizing and refining your task structure as project understanding evolves
360: - This is especially useful when dealing with potential merge conflicts arising from teams creating tasks on separate branches. Solve these conflicts very easily by moving your tasks and keeping theirs.
361: 
362: ## Iterative Subtask Implementation
363: 
364: Once a task has been broken down into subtasks using `expand_task` or similar methods, follow this iterative process for implementation:
365: 
366: 1.  **Understand the Goal (Preparation):**
367:     *   Use `get_task` / `task-master show <subtaskId>` (see @`taskmaster.md`) to thoroughly understand the specific goals and requirements of the subtask.
368: 
369: 2.  **Initial Exploration & Planning (Iteration 1):**
370:     *   This is the first attempt at creating a concrete implementation plan.
371:     *   Explore the codebase to identify the precise files, functions, and even specific lines of code that will need modification.
372:     *   Determine the intended code changes (diffs) and their locations.
373:     *   Gather *all* relevant details from this exploration phase.
374: 
375: 3.  **Log the Plan:**
376:     *   Run `update_subtask` / `task-master update-subtask --id=<subtaskId> --prompt='<detailed plan>'`.
377:     *   Provide the *complete and detailed* findings from the exploration phase in the prompt. Include file paths, line numbers, proposed diffs, reasoning, and any potential challenges identified. Do not omit details. The goal is to create a rich, timestamped log within the subtask's `details`.
378: 
379: 4.  **Verify the Plan:**
380:     *   Run `get_task` / `task-master show <subtaskId>` again to confirm that the detailed implementation plan has been successfully appended to the subtask's details.
381: 
382: 5.  **Begin Implementation:**
383:     *   Set the subtask status using `set_task_status` / `task-master set-status --id=<subtaskId> --status=in-progress`.
384:     *   Start coding based on the logged plan.
385: 
386: 6.  **Refine and Log Progress (Iteration 2+):**
387:     *   As implementation progresses, you will encounter challenges, discover nuances, or confirm successful approaches.
388:     *   **Before appending new information**: Briefly review the *existing* details logged in the subtask (using `get_task` or recalling from context) to ensure the update adds fresh insights and avoids redundancy.
389:     *   **Regularly** use `update_subtask` / `task-master update-subtask --id=<subtaskId> --prompt='<update details>\n- What worked...\n- What didn't work...'` to append new findings.
390:     *   **Crucially, log:**
391:         *   What worked ("fundamental truths" discovered).
392:         *   What didn't work and why (to avoid repeating mistakes).
393:         *   Specific code snippets or configurations that were successful.
394:         *   Decisions made, especially if confirmed with user input.
395:         *   Any deviations from the initial plan and the reasoning.
396:     *   The objective is to continuously enrich the subtask's details, creating a log of the implementation journey that helps the AI (and human developers) learn, adapt, and avoid repeating errors.
397: 
398: 7.  **Review & Update Rules (Post-Implementation):**
399:     *   Once the implementation for the subtask is functionally complete, review all code changes and the relevant chat history.
400:     *   Identify any new or modified code patterns, conventions, or best practices established during the implementation.
401:     *   Create new or update existing rules following internal guidelines (previously linked to `cursor_rules.md` and `self_improve.md`).
402: 
403: 8.  **Mark Task Complete:**
404:     *   After verifying the implementation and updating any necessary rules, mark the subtask as completed: `set_task_status` / `task-master set-status --id=<subtaskId> --status=done`.
405: 
406: 9.  **Commit Changes (If using Git):**
407:     *   Stage the relevant code changes and any updated/new rule files (`git add .`).
408:     *   Craft a comprehensive Git commit message summarizing the work done for the subtask, including both code implementation and any rule adjustments.
409:     *   Execute the commit command directly in the terminal (e.g., `git commit -m 'feat(module): Implement feature X for subtask <subtaskId>\n\n- Details about changes...\n- Updated rule Y for pattern Z'`).
410:     *   Consider if a Changeset is needed according to internal versioning guidelines (previously linked to `changeset.md`). If so, run `npm run changeset`, stage the generated file, and amend the commit or create a new one.
411: 
412: 10. **Proceed to Next Subtask:**
413:     *   Identify the next subtask (e.g., using `next_task` / `task-master next`).
414: 
415: ## Code Analysis & Refactoring Techniques
416: 
417: - **Top-Level Function Search**:
418:     - Useful for understanding module structure or planning refactors.
419:     - Use grep/ripgrep to find exported functions/constants:
420:       `rg "export (async function|function|const) \w+"` or similar patterns.
421:     - Can help compare functions between files during migrations or identify potential naming conflicts.
422: 
423: ---
424: *This workflow provides a general guideline. Adapt it based on your specific project needs and team practices.*
</file>

<file path=".clinerules/self_improve.md">
 1: ---
 2: description: Guidelines for continuously improving Cline rules based on emerging code patterns and best practices.
 3: globs: **/*
 4: alwaysApply: true
 5: ---
 6: 
 7: - **Rule Improvement Triggers:**
 8:   - New code patterns not covered by existing rules
 9:   - Repeated similar implementations across files
10:   - Common error patterns that could be prevented
11:   - New libraries or tools being used consistently
12:   - Emerging best practices in the codebase
13: 
14: - **Analysis Process:**
15:   - Compare new code with existing rules
16:   - Identify patterns that should be standardized
17:   - Look for references to external documentation
18:   - Check for consistent error handling patterns
19:   - Monitor test patterns and coverage
20: 
21: - **Rule Updates:**
22:   - **Add New Rules When:**
23:     - A new technology/pattern is used in 3+ files
24:     - Common bugs could be prevented by a rule
25:     - Code reviews repeatedly mention the same feedback
26:     - New security or performance patterns emerge
27: 
28:   - **Modify Existing Rules When:**
29:     - Better examples exist in the codebase
30:     - Additional edge cases are discovered
31:     - Related rules have been updated
32:     - Implementation details have changed
33: 
34: - **Example Pattern Recognition:**
35:   ```typescript
36:   // If you see repeated patterns like:
37:   const data = await prisma.user.findMany({
38:     select: { id: true, email: true },
39:     where: { status: 'ACTIVE' }
40:   });
41:   
42:   // Consider adding to [prisma.md](.clinerules/prisma.md):
43:   // - Standard select fields
44:   // - Common where conditions
45:   // - Performance optimization patterns
46:   ```
47: 
48: - **Rule Quality Checks:**
49:   - Rules should be actionable and specific
50:   - Examples should come from actual code
51:   - References should be up to date
52:   - Patterns should be consistently enforced
53: 
54: - **Continuous Improvement:**
55:   - Monitor code review comments
56:   - Track common development questions
57:   - Update rules after major refactors
58:   - Add links to relevant documentation
59:   - Cross-reference related rules
60: 
61: - **Rule Deprecation:**
62:   - Mark outdated patterns as deprecated
63:   - Remove rules that no longer apply
64:   - Update references to deprecated rules
65:   - Document migration paths for old patterns
66: 
67: - **Documentation Updates:**
68:   - Keep examples synchronized with code
69:   - Update references to external docs
70:   - Maintain links between related rules
71:   - Document breaking changes
72: Follow [cline_rules.md](.clinerules/cline_rules.md) for proper rule formatting and structure.
</file>

<file path=".clinerules/taskmaster.md">
  1: ---
  2: description: Comprehensive reference for Taskmaster MCP tools and CLI commands.
  3: globs: **/*
  4: alwaysApply: true
  5: ---
  6: 
  7: # Taskmaster Tool & Command Reference
  8: 
  9: This document provides a detailed reference for interacting with Taskmaster, covering both the recommended MCP tools, suitable for integrations like Cline, and the corresponding `task-master` CLI commands, designed for direct user interaction or fallback.
 10: 
 11: **Note:** For interacting with Taskmaster programmatically or via integrated tools, using the **MCP tools is strongly recommended** due to better performance, structured data, and error handling. The CLI commands serve as a user-friendly alternative and fallback. 
 12: 
 13: **Important:** Several MCP tools involve AI processing... The AI-powered tools include `parse_prd`, `analyze_project_complexity`, `update_subtask`, `update_task`, `update`, `expand_all`, `expand_task`, and `add_task`.
 14: 
 15: ** Tagged Task Lists System:** Task Master now supports **tagged task lists** for multi-context task management. This allows you to maintain separate, isolated lists of tasks for different features, branches, or experiments. Existing projects are seamlessly migrated to use a default "master" tag. Most commands now support a `--tag <name>` flag to specify which context to operate on. If omitted, commands use the currently active tag.
 16: 
 17: ---
 18: 
 19: ## Initialization & Setup
 20: 
 21: ### 1. Initialize Project (`init`)
 22: 
 23: *   **MCP Tool:** `initialize_project`
 24: *   **CLI Command:** `task-master init [options]`
 25: *   **Description:** `Set up the basic Taskmaster file structure and configuration in the current directory for a new project.`
 26: *   **Key CLI Options:**
 27:     *   `--name <name>`: `Set the name for your project in Taskmaster's configuration.`
 28:     *   `--description <text>`: `Provide a brief description for your project.`
 29:     *   `--version <version>`: `Set the initial version for your project, e.g., '0.1.0'.`
 30:     *   `-y, --yes`: `Initialize Taskmaster quickly using default settings without interactive prompts.`
 31: *   **Usage:** Run this once at the beginning of a new project.
 32: *   **MCP Variant Description:** `Set up the basic Taskmaster file structure and configuration in the current directory for a new project by running the 'task-master init' command.`
 33: *   **Key MCP Parameters/Options:**
 34:     *   `projectName`: `Set the name for your project.` (CLI: `--name <name>`)
 35:     *   `projectDescription`: `Provide a brief description for your project.` (CLI: `--description <text>`)
 36:     *   `projectVersion`: `Set the initial version for your project, e.g., '0.1.0'.` (CLI: `--version <version>`)
 37:     *   `authorName`: `Author name.` (CLI: `--author <author>`)
 38:     *   `skipInstall`: `Skip installing dependencies. Default is false.` (CLI: `--skip-install`)
 39:     *   `addAliases`: `Add shell aliases tm and taskmaster. Default is false.` (CLI: `--aliases`)
 40:     *   `yes`: `Skip prompts and use defaults/provided arguments. Default is false.` (CLI: `-y, --yes`)
 41: *   **Usage:** Run this once at the beginning of a new project, typically via an integrated tool like Cline. Operates on the current working directory of the MCP server. 
 42: *   **Important:** Once complete, you *MUST* parse a prd in order to generate tasks. There will be no tasks files until then. The next step after initializing should be to create a PRD using the example PRD in .taskmaster/templates/example_prd.txt. 
 43: *   **Tagging:** Use the `--tag` option to parse the PRD into a specific, non-default tag context. If the tag doesn't exist, it will be created automatically. Example: `task-master parse-prd spec.txt --tag=new-feature`.
 44: 
 45: ### 2. Parse PRD (`parse_prd`)
 46: 
 47: *   **MCP Tool:** `parse_prd`
 48: *   **CLI Command:** `task-master parse-prd [file] [options]`
 49: *   **Description:** `Parse a Product Requirements Document, PRD, or text file with Taskmaster to automatically generate an initial set of tasks in tasks.json.`
 50: *   **Key Parameters/Options:**
 51:     *   `input`: `Path to your PRD or requirements text file that Taskmaster should parse for tasks.` (CLI: `[file]` positional or `-i, --input <file>`)
 52:     *   `output`: `Specify where Taskmaster should save the generated 'tasks.json' file. Defaults to '.taskmaster/tasks/tasks.json'.` (CLI: `-o, --output <file>`)
 53:     *   `numTasks`: `Approximate number of top-level tasks Taskmaster should aim to generate from the document.` (CLI: `-n, --num-tasks <number>`)
 54:     *   `force`: `Use this to allow Taskmaster to overwrite an existing 'tasks.json' without asking for confirmation.` (CLI: `-f, --force`)
 55: *   **Usage:** Useful for bootstrapping a project from an existing requirements document.
 56: *   **Notes:** Task Master will strictly adhere to any specific requirements mentioned in the PRD, such as libraries, database schemas, frameworks, tech stacks, etc., while filling in any gaps where the PRD isn't fully specified. Tasks are designed to provide the most direct implementation path while avoiding over-engineering.
 57: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress. If the user does not have a PRD, suggest discussing their idea and then use the example PRD in `.taskmaster/templates/example_prd.txt` as a template for creating the PRD based on their idea, for use with `parse-prd`.
 58: 
 59: ---
 60: 
 61: ## AI Model Configuration
 62: 
 63: ### 2. Manage Models (`models`)
 64: *   **MCP Tool:** `models`
 65: *   **CLI Command:** `task-master models [options]`
 66: *   **Description:** `View the current AI model configuration or set specific models for different roles (main, research, fallback). Allows setting custom model IDs for Ollama and OpenRouter.`
 67: *   **Key MCP Parameters/Options:**
 68:     *   `setMain <model_id>`: `Set the primary model ID for task generation/updates.` (CLI: `--set-main <model_id>`)
 69:     *   `setResearch <model_id>`: `Set the model ID for research-backed operations.` (CLI: `--set-research <model_id>`)
 70:     *   `setFallback <model_id>`: `Set the model ID to use if the primary fails.` (CLI: `--set-fallback <model_id>`)
 71:     *   `ollama <boolean>`: `Indicates the set model ID is a custom Ollama model.` (CLI: `--ollama`)
 72:     *   `openrouter <boolean>`: `Indicates the set model ID is a custom OpenRouter model.` (CLI: `--openrouter`)
 73:     *   `listAvailableModels <boolean>`: `If true, lists available models not currently assigned to a role.` (CLI: No direct equivalent; CLI lists available automatically)
 74:     *   `projectRoot <string>`: `Optional. Absolute path to the project root directory.` (CLI: Determined automatically)
 75: *   **Key CLI Options:**
 76:     *   `--set-main <model_id>`: `Set the primary model.`
 77:     *   `--set-research <model_id>`: `Set the research model.`
 78:     *   `--set-fallback <model_id>`: `Set the fallback model.`
 79:     *   `--ollama`: `Specify that the provided model ID is for Ollama (use with --set-*).`
 80:     *   `--openrouter`: `Specify that the provided model ID is for OpenRouter (use with --set-*). Validates against OpenRouter API.`
 81:     *   `--bedrock`: `Specify that the provided model ID is for AWS Bedrock (use with --set-*).`
 82:     *   `--setup`: `Run interactive setup to configure models, including custom Ollama/OpenRouter IDs.`
 83: *   **Usage (MCP):** Call without set flags to get current config. Use `setMain`, `setResearch`, or `setFallback` with a valid model ID to update the configuration. Use `listAvailableModels: true` to get a list of unassigned models. To set a custom model, provide the model ID and set `ollama: true` or `openrouter: true`.
 84: *   **Usage (CLI):** Run without flags to view current configuration and available models. Use set flags to update specific roles. Use `--setup` for guided configuration, including custom models. To set a custom model via flags, use `--set-<role>=<model_id>` along with either `--ollama` or `--openrouter`.
 85: *   **Notes:** Configuration is stored in `.taskmaster/config.json` in the project root. This command/tool modifies that file. Use `listAvailableModels` or `task-master models` to see internally supported models. OpenRouter custom models are validated against their live API. Ollama custom models are not validated live.
 86: *   **API note:** API keys for selected AI providers (based on their model) need to exist in the mcp.json file to be accessible in MCP context. The API keys must be present in the local .env file for the CLI to be able to read them.
 87: *   **Model costs:** The costs in supported models are expressed in dollars. An input/output value of 3 is $3.00. A value of 0.8 is $0.80. 
 88: *   **Warning:** DO NOT MANUALLY EDIT THE .taskmaster/config.json FILE. Use the included commands either in the MCP or CLI format as needed. Always prioritize MCP tools when available and use the CLI as a fallback.
 89: 
 90: ---
 91: 
 92: ## Task Listing & Viewing
 93: 
 94: ### 3. Get Tasks (`get_tasks`)
 95: 
 96: *   **MCP Tool:** `get_tasks`
 97: *   **CLI Command:** `task-master list [options]`
 98: *   **Description:** `List your Taskmaster tasks, optionally filtering by status and showing subtasks.`
 99: *   **Key Parameters/Options:**
100:     *   `status`: `Show only Taskmaster tasks matching this status (or multiple statuses, comma-separated), e.g., 'pending' or 'done,in-progress'.` (CLI: `-s, --status <status>`)
101:     *   `withSubtasks`: `Include subtasks indented under their parent tasks in the list.` (CLI: `--with-subtasks`)
102:     *   `tag`: `Specify which tag context to list tasks from. Defaults to the current active tag.` (CLI: `--tag <name>`)
103:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
104: *   **Usage:** Get an overview of the project status, often used at the start of a work session.
105: 
106: ### 4. Get Next Task (`next_task`)
107: 
108: *   **MCP Tool:** `next_task`
109: *   **CLI Command:** `task-master next [options]`
110: *   **Description:** `Ask Taskmaster to show the next available task you can work on, based on status and completed dependencies.`
111: *   **Key Parameters/Options:**
112:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
113:     *   `tag`: `Specify which tag context to use. Defaults to the current active tag.` (CLI: `--tag <name>`)
114: *   **Usage:** Identify what to work on next according to the plan.
115: 
116: ### 5. Get Task Details (`get_task`)
117: 
118: *   **MCP Tool:** `get_task`
119: *   **CLI Command:** `task-master show [id] [options]`
120: *   **Description:** `Display detailed information for one or more specific Taskmaster tasks or subtasks by ID.`
121: *   **Key Parameters/Options:**
122:     *   `id`: `Required. The ID of the Taskmaster task (e.g., '15'), subtask (e.g., '15.2'), or a comma-separated list of IDs ('1,5,10.2') you want to view.` (CLI: `[id]` positional or `-i, --id <id>`)
123:     *   `tag`: `Specify which tag context to get the task(s) from. Defaults to the current active tag.` (CLI: `--tag <name>`)
124:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
125: *   **Usage:** Understand the full details for a specific task. When multiple IDs are provided, a summary table is shown.
126: *   **CRITICAL INFORMATION** If you need to collect information from multiple tasks, use comma-separated IDs (i.e. 1,2,3) to receive an array of tasks. Do not needlessly get tasks one at a time if you need to get many as that is wasteful.
127: 
128: ---
129: 
130: ## Task Creation & Modification
131: 
132: ### 6. Add Task (`add_task`)
133: 
134: *   **MCP Tool:** `add_task`
135: *   **CLI Command:** `task-master add-task [options]`
136: *   **Description:** `Add a new task to Taskmaster by describing it; AI will structure it.`
137: *   **Key Parameters/Options:**
138:     *   `prompt`: `Required. Describe the new task you want Taskmaster to create, e.g., "Implement user authentication using JWT".` (CLI: `-p, --prompt <text>`)
139:     *   `dependencies`: `Specify the IDs of any Taskmaster tasks that must be completed before this new one can start, e.g., '12,14'.` (CLI: `-d, --dependencies <ids>`)
140:     *   `priority`: `Set the priority for the new task: 'high', 'medium', or 'low'. Default is 'medium'.` (CLI: `--priority <priority>`)
141:     *   `research`: `Enable Taskmaster to use the research role for potentially more informed task creation.` (CLI: `-r, --research`)
142:     *   `tag`: `Specify which tag context to add the task to. Defaults to the current active tag.` (CLI: `--tag <name>`)
143:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
144: *   **Usage:** Quickly add newly identified tasks during development.
145: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
146: 
147: ### 7. Add Subtask (`add_subtask`)
148: 
149: *   **MCP Tool:** `add_subtask`
150: *   **CLI Command:** `task-master add-subtask [options]`
151: *   **Description:** `Add a new subtask to a Taskmaster parent task, or convert an existing task into a subtask.`
152: *   **Key Parameters/Options:**
153:     *   `id` / `parent`: `Required. The ID of the Taskmaster task that will be the parent.` (MCP: `id`, CLI: `-p, --parent <id>`)
154:     *   `taskId`: `Use this if you want to convert an existing top-level Taskmaster task into a subtask of the specified parent.` (CLI: `-i, --task-id <id>`)
155:     *   `title`: `Required if not using taskId. The title for the new subtask Taskmaster should create.` (CLI: `-t, --title <title>`)
156:     *   `description`: `A brief description for the new subtask.` (CLI: `-d, --description <text>`)
157:     *   `details`: `Provide implementation notes or details for the new subtask.` (CLI: `--details <text>`)
158:     *   `dependencies`: `Specify IDs of other tasks or subtasks, e.g., '15' or '16.1', that must be done before this new subtask.` (CLI: `--dependencies <ids>`)
159:     *   `status`: `Set the initial status for the new subtask. Default is 'pending'.` (CLI: `-s, --status <status>`)
160:     *   `skipGenerate`: `Prevent Taskmaster from automatically regenerating markdown task files after adding the subtask.` (CLI: `--skip-generate`)
161:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
162:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
163: *   **Usage:** Break down tasks manually or reorganize existing tasks.
164: 
165: ### 8. Update Tasks (`update`)
166: 
167: *   **MCP Tool:** `update`
168: *   **CLI Command:** `task-master update [options]`
169: *   **Description:** `Update multiple upcoming tasks in Taskmaster based on new context or changes, starting from a specific task ID.`
170: *   **Key Parameters/Options:**
171:     *   `from`: `Required. The ID of the first task Taskmaster should update. All tasks with this ID or higher that are not 'done' will be considered.` (CLI: `--from <id>`)
172:     *   `prompt`: `Required. Explain the change or new context for Taskmaster to apply to the tasks, e.g., "We are now using React Query instead of Redux Toolkit for data fetching".` (CLI: `-p, --prompt <text>`)
173:     *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
174:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
175:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
176: *   **Usage:** Handle significant implementation changes or pivots that affect multiple future tasks. Example CLI: `task-master update --from='18' --prompt='Switching to React Query.\nNeed to refactor data fetching...'`
177: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
178: 
179: ### 9. Update Task (`update_task`)
180: 
181: *   **MCP Tool:** `update_task`
182: *   **CLI Command:** `task-master update-task [options]`
183: *   **Description:** `Modify a specific Taskmaster task by ID, incorporating new information or changes. By default, this replaces the existing task details.`
184: *   **Key Parameters/Options:**
185:     *   `id`: `Required. The specific ID of the Taskmaster task, e.g., '15', you want to update.` (CLI: `-i, --id <id>`)
186:     *   `prompt`: `Required. Explain the specific changes or provide the new information Taskmaster should incorporate into this task.` (CLI: `-p, --prompt <text>`)
187:     *   `append`: `If true, appends the prompt content to the task's details with a timestamp, rather than replacing them. Behaves like update-subtask.` (CLI: `--append`)
188:     *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
189:     *   `tag`: `Specify which tag context the task belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
190:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
191: *   **Usage:** Refine a specific task based on new understanding. Use `--append` to log progress without creating subtasks.
192: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
193: 
194: ### 10. Update Subtask (`update_subtask`)
195: 
196: *   **MCP Tool:** `update_subtask`
197: *   **CLI Command:** `task-master update-subtask [options]`
198: *   **Description:** `Append timestamped notes or details to a specific Taskmaster subtask without overwriting existing content. Intended for iterative implementation logging.`
199: *   **Key Parameters/Options:**
200:     *   `id`: `Required. The ID of the Taskmaster subtask, e.g., '5.2', to update with new information.` (CLI: `-i, --id <id>`)
201:     *   `prompt`: `Required. The information, findings, or progress notes to append to the subtask's details with a timestamp.` (CLI: `-p, --prompt <text>`)
202:     *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
203:     *   `tag`: `Specify which tag context the subtask belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
204:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
205: *   **Usage:** Log implementation progress, findings, and discoveries during subtask development. Each update is timestamped and appended to preserve the implementation journey.
206: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
207: 
208: ### 11. Set Task Status (`set_task_status`)
209: 
210: *   **MCP Tool:** `set_task_status`
211: *   **CLI Command:** `task-master set-status [options]`
212: *   **Description:** `Update the status of one or more Taskmaster tasks or subtasks, e.g., 'pending', 'in-progress', 'done'.`
213: *   **Key Parameters/Options:**
214:     *   `id`: `Required. The ID(s) of the Taskmaster task(s) or subtask(s), e.g., '15', '15.2', or '16,17.1', to update.` (CLI: `-i, --id <id>`)
215:     *   `status`: `Required. The new status to set, e.g., 'done', 'pending', 'in-progress', 'review', 'cancelled'.` (CLI: `-s, --status <status>`)
216:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
217:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
218: *   **Usage:** Mark progress as tasks move through the development cycle.
219: 
220: ### 12. Remove Task (`remove_task`)
221: 
222: *   **MCP Tool:** `remove_task`
223: *   **CLI Command:** `task-master remove-task [options]`
224: *   **Description:** `Permanently remove a task or subtask from the Taskmaster tasks list.`
225: *   **Key Parameters/Options:**
226:     *   `id`: `Required. The ID of the Taskmaster task, e.g., '5', or subtask, e.g., '5.2', to permanently remove.` (CLI: `-i, --id <id>`)
227:     *   `yes`: `Skip the confirmation prompt and immediately delete the task.` (CLI: `-y, --yes`)
228:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
229:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
230: *   **Usage:** Permanently delete tasks or subtasks that are no longer needed in the project.
231: *   **Notes:** Use with caution as this operation cannot be undone. Consider using 'blocked', 'cancelled', or 'deferred' status instead if you just want to exclude a task from active planning but keep it for reference. The command automatically cleans up dependency references in other tasks.
232: 
233: ---
234: 
235: ## Task Structure & Breakdown
236: 
237: ### 13. Expand Task (`expand_task`)
238: 
239: *   **MCP Tool:** `expand_task`
240: *   **CLI Command:** `task-master expand [options]`
241: *   **Description:** `Use Taskmaster's AI to break down a complex task into smaller, manageable subtasks. Appends subtasks by default.`
242: *   **Key Parameters/Options:**
243:     *   `id`: `The ID of the specific Taskmaster task you want to break down into subtasks.` (CLI: `-i, --id <id>`)
244:     *   `num`: `Optional: Suggests how many subtasks Taskmaster should aim to create. Uses complexity analysis/defaults otherwise.` (CLI: `-n, --num <number>`)
245:     *   `research`: `Enable Taskmaster to use the research role for more informed subtask generation. Requires appropriate API key.` (CLI: `-r, --research`)
246:     *   `prompt`: `Optional: Provide extra context or specific instructions to Taskmaster for generating the subtasks.` (CLI: `-p, --prompt <text>`)
247:     *   `force`: `Optional: If true, clear existing subtasks before generating new ones. Default is false (append).` (CLI: `--force`)
248:     *   `tag`: `Specify which tag context the task belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
249:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
250: *   **Usage:** Generate a detailed implementation plan for a complex task before starting coding. Automatically uses complexity report recommendations if available and `num` is not specified.
251: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
252: 
253: ### 14. Expand All Tasks (`expand_all`)
254: 
255: *   **MCP Tool:** `expand_all`
256: *   **CLI Command:** `task-master expand --all [options]` (Note: CLI uses the `expand` command with the `--all` flag)
257: *   **Description:** `Tell Taskmaster to automatically expand all eligible pending/in-progress tasks based on complexity analysis or defaults. Appends subtasks by default.`
258: *   **Key Parameters/Options:**
259:     *   `num`: `Optional: Suggests how many subtasks Taskmaster should aim to create per task.` (CLI: `-n, --num <number>`)
260:     *   `research`: `Enable research role for more informed subtask generation. Requires appropriate API key.` (CLI: `-r, --research`)
261:     *   `prompt`: `Optional: Provide extra context for Taskmaster to apply generally during expansion.` (CLI: `-p, --prompt <text>`)
262:     *   `force`: `Optional: If true, clear existing subtasks before generating new ones for each eligible task. Default is false (append).` (CLI: `--force`)
263:     *   `tag`: `Specify which tag context to expand. Defaults to the current active tag.` (CLI: `--tag <name>`)
264:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
265: *   **Usage:** Useful after initial task generation or complexity analysis to break down multiple tasks at once.
266: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
267: 
268: ### 15. Clear Subtasks (`clear_subtasks`)
269: 
270: *   **MCP Tool:** `clear_subtasks`
271: *   **CLI Command:** `task-master clear-subtasks [options]`
272: *   **Description:** `Remove all subtasks from one or more specified Taskmaster parent tasks.`
273: *   **Key Parameters/Options:**
274:     *   `id`: `The ID(s) of the Taskmaster parent task(s) whose subtasks you want to remove, e.g., '15' or '16,18'. Required unless using `all`.) (CLI: `-i, --id <ids>`)
275:     *   `all`: `Tell Taskmaster to remove subtasks from all parent tasks.` (CLI: `--all`)
276:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
277:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
278: *   **Usage:** Used before regenerating subtasks with `expand_task` if the previous breakdown needs replacement.
279: 
280: ### 16. Remove Subtask (`remove_subtask`)
281: 
282: *   **MCP Tool:** `remove_subtask`
283: *   **CLI Command:** `task-master remove-subtask [options]`
284: *   **Description:** `Remove a subtask from its Taskmaster parent, optionally converting it into a standalone task.`
285: *   **Key Parameters/Options:**
286:     *   `id`: `Required. The ID(s) of the Taskmaster subtask(s) to remove, e.g., '15.2' or '16.1,16.3'.` (CLI: `-i, --id <id>`)
287:     *   `convert`: `If used, Taskmaster will turn the subtask into a regular top-level task instead of deleting it.` (CLI: `-c, --convert`)
288:     *   `skipGenerate`: `Prevent Taskmaster from automatically regenerating markdown task files after removing the subtask.` (CLI: `--skip-generate`)
289:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
290:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
291: *   **Usage:** Delete unnecessary subtasks or promote a subtask to a top-level task.
292: 
293: ### 17. Move Task (`move_task`)
294: 
295: *   **MCP Tool:** `move_task`
296: *   **CLI Command:** `task-master move [options]`
297: *   **Description:** `Move a task or subtask to a new position within the task hierarchy.`
298: *   **Key Parameters/Options:**
299:     *   `from`: `Required. ID of the task/subtask to move (e.g., "5" or "5.2"). Can be comma-separated for multiple tasks.` (CLI: `--from <id>`)
300:     *   `to`: `Required. ID of the destination (e.g., "7" or "7.3"). Must match the number of source IDs if comma-separated.` (CLI: `--to <id>`)
301:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
302:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
303: *   **Usage:** Reorganize tasks by moving them within the hierarchy. Supports various scenarios like:
304:     *   Moving a task to become a subtask
305:     *   Moving a subtask to become a standalone task
306:     *   Moving a subtask to a different parent
307:     *   Reordering subtasks within the same parent
308:     *   Moving a task to a new, non-existent ID (automatically creates placeholders)
309:     *   Moving multiple tasks at once with comma-separated IDs
310: *   **Validation Features:**
311:     *   Allows moving tasks to non-existent destination IDs (creates placeholder tasks)
312:     *   Prevents moving to existing task IDs that already have content (to avoid overwriting)
313:     *   Validates that source tasks exist before attempting to move them
314:     *   Maintains proper parent-child relationships
315: *   **Example CLI:** `task-master move --from=5.2 --to=7.3` to move subtask 5.2 to become subtask 7.3.
316: *   **Example Multi-Move:** `task-master move --from=10,11,12 --to=16,17,18` to move multiple tasks to new positions.
317: *   **Common Use:** Resolving merge conflicts in tasks.json when multiple team members create tasks on different branches.
318: 
319: ---
320: 
321: ## Dependency Management
322: 
323: ### 18. Add Dependency (`add_dependency`)
324: 
325: *   **MCP Tool:** `add_dependency`
326: *   **CLI Command:** `task-master add-dependency [options]`
327: *   **Description:** `Define a dependency in Taskmaster, making one task a prerequisite for another.`
328: *   **Key Parameters/Options:**
329:     *   `id`: `Required. The ID of the Taskmaster task that will depend on another.` (CLI: `-i, --id <id>`)
330:     *   `dependsOn`: `Required. The ID of the Taskmaster task that must be completed first, the prerequisite.` (CLI: `-d, --depends-on <id>`)
331:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
332:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <path>`)
333: *   **Usage:** Establish the correct order of execution between tasks.
334: 
335: ### 19. Remove Dependency (`remove_dependency`)
336: 
337: *   **MCP Tool:** `remove_dependency`
338: *   **CLI Command:** `task-master remove-dependency [options]`
339: *   **Description:** `Remove a dependency relationship between two Taskmaster tasks.`
340: *   **Key Parameters/Options:**
341:     *   `id`: `Required. The ID of the Taskmaster task you want to remove a prerequisite from.` (CLI: `-i, --id <id>`)
342:     *   `dependsOn`: `Required. The ID of the Taskmaster task that should no longer be a prerequisite.` (CLI: `-d, --depends-on <id>`)
343:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
344:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
345: *   **Usage:** Update task relationships when the order of execution changes.
346: 
347: ### 20. Validate Dependencies (`validate_dependencies`)
348: 
349: *   **MCP Tool:** `validate_dependencies`
350: *   **CLI Command:** `task-master validate-dependencies [options]`
351: *   **Description:** `Check your Taskmaster tasks for dependency issues (like circular references or links to non-existent tasks) without making changes.`
352: *   **Key Parameters/Options:**
353:     *   `tag`: `Specify which tag context to validate. Defaults to the current active tag.` (CLI: `--tag <name>`)
354:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
355: *   **Usage:** Audit the integrity of your task dependencies.
356: 
357: ### 21. Fix Dependencies (`fix_dependencies`)
358: 
359: *   **MCP Tool:** `fix_dependencies`
360: *   **CLI Command:** `task-master fix-dependencies [options]`
361: *   **Description:** `Automatically fix dependency issues (like circular references or links to non-existent tasks) in your Taskmaster tasks.`
362: *   **Key Parameters/Options:**
363:     *   `tag`: `Specify which tag context to fix dependencies in. Defaults to the current active tag.` (CLI: `--tag <name>`)
364:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
365: *   **Usage:** Clean up dependency errors automatically.
366: 
367: ---
368: 
369: ## Analysis & Reporting
370: 
371: ### 22. Analyze Project Complexity (`analyze_project_complexity`)
372: 
373: *   **MCP Tool:** `analyze_project_complexity`
374: *   **CLI Command:** `task-master analyze-complexity [options]`
375: *   **Description:** `Have Taskmaster analyze your tasks to determine their complexity and suggest which ones need to be broken down further.`
376: *   **Key Parameters/Options:**
377:     *   `output`: `Where to save the complexity analysis report. Default is '.taskmaster/reports/task-complexity-report.json' (or '..._tagname.json' if a tag is used).` (CLI: `-o, --output <file>`)
378:     *   `threshold`: `The minimum complexity score (1-10) that should trigger a recommendation to expand a task.` (CLI: `-t, --threshold <number>`)
379:     *   `research`: `Enable research role for more accurate complexity analysis. Requires appropriate API key.` (CLI: `-r, --research`)
380:     *   `tag`: `Specify which tag context to analyze. Defaults to the current active tag.` (CLI: `--tag <name>`)
381:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
382: *   **Usage:** Used before breaking down tasks to identify which ones need the most attention.
383: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
384: 
385: ### 23. View Complexity Report (`complexity_report`)
386: 
387: *   **MCP Tool:** `complexity_report`
388: *   **CLI Command:** `task-master complexity-report [options]`
389: *   **Description:** `Display the task complexity analysis report in a readable format.`
390: *   **Key Parameters/Options:**
391:     *   `tag`: `Specify which tag context to show the report for. Defaults to the current active tag.` (CLI: `--tag <name>`)
392:     *   `file`: `Path to the complexity report (default: '.taskmaster/reports/task-complexity-report.json').` (CLI: `-f, --file <file>`)
393: *   **Usage:** Review and understand the complexity analysis results after running analyze-complexity.
394: 
395: ---
396: 
397: ## File Management
398: 
399: ### 24. Generate Task Files (`generate`)
400: 
401: *   **MCP Tool:** `generate`
402: *   **CLI Command:** `task-master generate [options]`
403: *   **Description:** `Create or update individual Markdown files for each task based on your tasks.json.`
404: *   **Key Parameters/Options:**
405:     *   `output`: `The directory where Taskmaster should save the task files (default: in a 'tasks' directory).` (CLI: `-o, --output <directory>`)
406:     *   `tag`: `Specify which tag context to generate files for. Defaults to the current active tag.` (CLI: `--tag <name>`)
407:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
408: *   **Usage:** Run this after making changes to tasks.json to keep individual task files up to date. This command is now manual and no longer runs automatically.
409: 
410: ---
411: 
412: ## AI-Powered Research
413: 
414: ### 25. Research (`research`)
415: 
416: *   **MCP Tool:** `research`
417: *   **CLI Command:** `task-master research [options]`
418: *   **Description:** `Perform AI-powered research queries with project context to get fresh, up-to-date information beyond the AI's knowledge cutoff.`
419: *   **Key Parameters/Options:**
420:     *   `query`: `Required. Research query/prompt (e.g., "What are the latest best practices for React Query v5?").` (CLI: `[query]` positional or `-q, --query <text>`)
421:     *   `taskIds`: `Comma-separated list of task/subtask IDs from the current tag context (e.g., "15,16.2,17").` (CLI: `-i, --id <ids>`)
422:     *   `filePaths`: `Comma-separated list of file paths for context (e.g., "src/api.js,docs/readme.md").` (CLI: `-f, --files <paths>`)
423:     *   `customContext`: `Additional custom context text to include in the research.` (CLI: `-c, --context <text>`)
424:     *   `includeProjectTree`: `Include project file tree structure in context (default: false).` (CLI: `--tree`)
425:     *   `detailLevel`: `Detail level for the research response: 'low', 'medium', 'high' (default: medium).` (CLI: `--detail <level>`)
426:     *   `saveTo`: `Task or subtask ID (e.g., "15", "15.2") to automatically save the research conversation to.` (CLI: `--save-to <id>`)
427:     *   `saveFile`: `If true, saves the research conversation to a markdown file in '.taskmaster/docs/research/'.` (CLI: `--save-file`)
428:     *   `noFollowup`: `Disables the interactive follow-up question menu in the CLI.` (CLI: `--no-followup`)
429:     *   `tag`: `Specify which tag context to use for task-based context gathering. Defaults to the current active tag.` (CLI: `--tag <name>`)
430:     *   `projectRoot`: `The directory of the project. Must be an absolute path.` (CLI: Determined automatically)
431: *   **Usage:** **This is a POWERFUL tool that agents should use FREQUENTLY** to:
432:     *   Get fresh information beyond knowledge cutoff dates
433:     *   Research latest best practices, library updates, security patches
434:     *   Find implementation examples for specific technologies
435:     *   Validate approaches against current industry standards
436:     *   Get contextual advice based on project files and tasks
437: *   **When to Consider Using Research:**
438:     *   **Before implementing any task** - Research current best practices
439:     *   **When encountering new technologies** - Get up-to-date implementation guidance (libraries, apis, etc)
440:     *   **For security-related tasks** - Find latest security recommendations
441:     *   **When updating dependencies** - Research breaking changes and migration guides
442:     *   **For performance optimization** - Get current performance best practices
443:     *   **When debugging complex issues** - Research known solutions and workarounds
444: *   **Research + Action Pattern:**
445:     *   Use `research` to gather fresh information
446:     *   Use `update_subtask` to commit findings with timestamps
447:     *   Use `update_task` to incorporate research into task details
448:     *   Use `add_task` with research flag for informed task creation
449: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. The research provides FRESH data beyond the AI's training cutoff, making it invaluable for current best practices and recent developments.
450: 
451: ---
452: 
453: ## Tag Management
454: 
455: This new suite of commands allows you to manage different task contexts (tags).
456: 
457: ### 26. List Tags (`tags`)
458: 
459: *   **MCP Tool:** `list_tags`
460: *   **CLI Command:** `task-master tags [options]`
461: *   **Description:** `List all available tags with task counts, completion status, and other metadata.`
462: *   **Key Parameters/Options:**
463:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
464:     *   `--show-metadata`: `Include detailed metadata in the output (e.g., creation date, description).` (CLI: `--show-metadata`)
465: 
466: ### 27. Add Tag (`add_tag`)
467: 
468: *   **MCP Tool:** `add_tag`
469: *   **CLI Command:** `task-master add-tag <tagName> [options]`
470: *   **Description:** `Create a new, empty tag context, or copy tasks from another tag.`
471: *   **Key Parameters/Options:**
472:     *   `tagName`: `Name of the new tag to create (alphanumeric, hyphens, underscores).` (CLI: `<tagName>` positional)
473:     *   `--from-branch`: `Creates a tag with a name derived from the current git branch, ignoring the <tagName> argument.` (CLI: `--from-branch`)
474:     *   `--copy-from-current`: `Copy tasks from the currently active tag to the new tag.` (CLI: `--copy-from-current`)
475:     *   `--copy-from <tag>`: `Copy tasks from a specific source tag to the new tag.` (CLI: `--copy-from <tag>`)
476:     *   `--description <text>`: `Provide an optional description for the new tag.` (CLI: `-d, --description <text>`)
477:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
478: 
479: ### 28. Delete Tag (`delete_tag`)
480: 
481: *   **MCP Tool:** `delete_tag`
482: *   **CLI Command:** `task-master delete-tag <tagName> [options]`
483: *   **Description:** `Permanently delete a tag and all of its associated tasks.`
484: *   **Key Parameters/Options:**
485:     *   `tagName`: `Name of the tag to delete.` (CLI: `<tagName>` positional)
486:     *   `--yes`: `Skip the confirmation prompt.` (CLI: `-y, --yes`)
487:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
488: 
489: ### 29. Use Tag (`use_tag`)
490: 
491: *   **MCP Tool:** `use_tag`
492: *   **CLI Command:** `task-master use-tag <tagName>`
493: *   **Description:** `Switch your active task context to a different tag.`
494: *   **Key Parameters/Options:**
495:     *   `tagName`: `Name of the tag to switch to.` (CLI: `<tagName>` positional)
496:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
497: 
498: ### 30. Rename Tag (`rename_tag`)
499: 
500: *   **MCP Tool:** `rename_tag`
501: *   **CLI Command:** `task-master rename-tag <oldName> <newName>`
502: *   **Description:** `Rename an existing tag.`
503: *   **Key Parameters/Options:**
504:     *   `oldName`: `The current name of the tag.` (CLI: `<oldName>` positional)
505:     *   `newName`: `The new name for the tag.` (CLI: `<newName>` positional)
506:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
507: 
508: ### 31. Copy Tag (`copy_tag`)
509: 
510: *   **MCP Tool:** `copy_tag`
511: *   **CLI Command:** `task-master copy-tag <sourceName> <targetName> [options]`
512: *   **Description:** `Copy an entire tag context, including all its tasks and metadata, to a new tag.`
513: *   **Key Parameters/Options:**
514:     *   `sourceName`: `Name of the tag to copy from.` (CLI: `<sourceName>` positional)
515:     *   `targetName`: `Name of the new tag to create.` (CLI: `<targetName>` positional)
516:     *   `--description <text>`: `Optional description for the new tag.` (CLI: `-d, --description <text>`)
517: 
518: ---
519: 
520: ## Miscellaneous
521: 
522: ### 32. Sync Readme (`sync-readme`) -- experimental
523: 
524: *   **MCP Tool:** N/A
525: *   **CLI Command:** `task-master sync-readme [options]`
526: *   **Description:** `Exports your task list to your project's README.md file, useful for showcasing progress.`
527: *   **Key Parameters/Options:**
528:     *   `status`: `Filter tasks by status (e.g., 'pending', 'done').` (CLI: `-s, --status <status>`)
529:     *   `withSubtasks`: `Include subtasks in the export.` (CLI: `--with-subtasks`)
530:     *   `tag`: `Specify which tag context to export from. Defaults to the current active tag.` (CLI: `--tag <name>`)
531: 
532: ---
533: 
534: ## Environment Variables Configuration (Updated)
535: 
536: Taskmaster primarily uses the **`.taskmaster/config.json`** file (in project root) for configuration (models, parameters, logging level, etc.), managed via `task-master models --setup`.
537: 
538: Environment variables are used **only** for sensitive API keys related to AI providers and specific overrides like the Ollama base URL:
539: 
540: *   **API Keys (Required for corresponding provider):**
541:     *   `ANTHROPIC_API_KEY`
542:     *   `PERPLEXITY_API_KEY`
543:     *   `OPENAI_API_KEY`
544:     *   `GOOGLE_API_KEY`
545:     *   `MISTRAL_API_KEY`
546:     *   `AZURE_OPENAI_API_KEY` (Requires `AZURE_OPENAI_ENDPOINT` too)
547:     *   `OPENROUTER_API_KEY`
548:     *   `XAI_API_KEY`
549:     *   `OLLAMA_API_KEY` (Requires `OLLAMA_BASE_URL` too)
550: *   **Endpoints (Optional/Provider Specific inside .taskmaster/config.json):**
551:     *   `AZURE_OPENAI_ENDPOINT`
552:     *   `OLLAMA_BASE_URL` (Default: `http://localhost:11434/api`)
553: 
554: **Set API keys** in your **`.env`** file in the project root (for CLI use) or within the `env` section of your **`.cline/mcp.json`** file (for MCP/Cline integration). All other settings (model choice, max tokens, temperature, log level, custom endpoints) are managed in `.taskmaster/config.json` via `task-master models` command or `models` MCP tool.
555: 
556: ---
557: 
558: For details on how these commands fit into the development process, see the [dev_workflow.md](.clinerules/dev_workflow.md).
</file>

<file path=".cursor/mcp.json">
 1: {
 2: 	"mcpServers": {
 3: 		"task-master-ai": {
 4: 			"command": "npx",
 5: 			"args": ["-y", "--package=task-master-ai", "task-master-ai"],
 6: 			"env": {
 7: 				"ANTHROPIC_API_KEY": "ANTHROPIC_API_KEY_HERE",
 8: 				"PERPLEXITY_API_KEY": "PERPLEXITY_API_KEY_HERE",
 9: 				"OPENAI_API_KEY": "OPENAI_API_KEY_HERE",
10: 				"GOOGLE_API_KEY": "GOOGLE_API_KEY_HERE",
11: 				"XAI_API_KEY": "XAI_API_KEY_HERE",
12: 				"OPENROUTER_API_KEY": "OPENROUTER_API_KEY_HERE",
13: 				"MISTRAL_API_KEY": "MISTRAL_API_KEY_HERE",
14: 				"AZURE_OPENAI_API_KEY": "AZURE_OPENAI_API_KEY_HERE",
15: 				"OLLAMA_API_KEY": "OLLAMA_API_KEY_HERE"
16: 			}
17: 		}
18: 	}
19: }
</file>

<file path=".github/instructions/dev_workflow.md">
  1: ---
  2: description: Guide for using Taskmaster to manage task-driven development workflows
  3: applyTo: "**/*"
  4: alwaysApply: true
  5: ---
  6: 
  7: # Taskmaster Development Workflow
  8: 
  9: This guide outlines the standard process for using Taskmaster to manage software development projects. It is written as a set of instructions for you, the AI agent.
 10: 
 11: - **Your Default Stance**: For most projects, the user can work directly within the `master` task context. Your initial actions should operate on this default context unless a clear pattern for multi-context work emerges.
 12: - **Your Goal**: Your role is to elevate the user's workflow by intelligently introducing advanced features like **Tagged Task Lists** when you detect the appropriate context. Do not force tags on the user; suggest them as a helpful solution to a specific need.
 13: 
 14: ## The Basic Loop
 15: The fundamental development cycle you will facilitate is:
 16: 1.  **`list`**: Show the user what needs to be done.
 17: 2.  **`next`**: Help the user decide what to work on.
 18: 3.  **`show <id>`**: Provide details for a specific task.
 19: 4.  **`expand <id>`**: Break down a complex task into smaller, manageable subtasks.
 20: 5.  **Implement**: The user writes the code and tests.
 21: 6.  **`update-subtask`**: Log progress and findings on behalf of the user.
 22: 7.  **`set-status`**: Mark tasks and subtasks as `done` as work is completed.
 23: 8.  **Repeat**.
 24: 
 25: All your standard command executions should operate on the user's current task context, which defaults to `master`.
 26: 
 27: ---
 28: 
 29: ## Standard Development Workflow Process
 30: 
 31: ### Simple Workflow (Default Starting Point)
 32: 
 33: For new projects or when users are getting started, operate within the `master` tag context:
 34: 
 35: -   Start new projects by running `initialize_project` tool / `task-master init` or `parse_prd` / `task-master parse-prd --input='<prd-file.txt>'` (see @`taskmaster.md`) to generate initial tasks.json with tagged structure
 36: -   Configure rule sets during initialization with `--rules` flag (e.g., `task-master init --rules vscode,windsurf`) or manage them later with `task-master rules add/remove` commands  
 37: -   Begin coding sessions with `get_tasks` / `task-master list` (see @`taskmaster.md`) to see current tasks, status, and IDs
 38: -   Determine the next task to work on using `next_task` / `task-master next` (see @`taskmaster.md`)
 39: -   Analyze task complexity with `analyze_project_complexity` / `task-master analyze-complexity --research` (see @`taskmaster.md`) before breaking down tasks
 40: -   Review complexity report using `complexity_report` / `task-master complexity-report` (see @`taskmaster.md`)
 41: -   Select tasks based on dependencies (all marked 'done'), priority level, and ID order
 42: -   View specific task details using `get_task` / `task-master show <id>` (see @`taskmaster.md`) to understand implementation requirements
 43: -   Break down complex tasks using `expand_task` / `task-master expand --id=<id> --force --research` (see @`taskmaster.md`) with appropriate flags like `--force` (to replace existing subtasks) and `--research`
 44: -   Implement code following task details, dependencies, and project standards
 45: -   Mark completed tasks with `set_task_status` / `task-master set-status --id=<id> --status=done` (see @`taskmaster.md`)
 46: -   Update dependent tasks when implementation differs from original plan using `update` / `task-master update --from=<id> --prompt="..."` or `update_task` / `task-master update-task --id=<id> --prompt="..."` (see @`taskmaster.md`)
 47: 
 48: ---
 49: 
 50: ## Leveling Up: Agent-Led Multi-Context Workflows
 51: 
 52: While the basic workflow is powerful, your primary opportunity to add value is by identifying when to introduce **Tagged Task Lists**. These patterns are your tools for creating a more organized and efficient development environment for the user, especially if you detect agentic or parallel development happening across the same session.
 53: 
 54: **Critical Principle**: Most users should never see a difference in their experience. Only introduce advanced workflows when you detect clear indicators that the project has evolved beyond simple task management.
 55: 
 56: ### When to Introduce Tags: Your Decision Patterns
 57: 
 58: Here are the patterns to look for. When you detect one, you should propose the corresponding workflow to the user.
 59: 
 60: #### Pattern 1: Simple Git Feature Branching
 61: This is the most common and direct use case for tags.
 62: 
 63: - **Trigger**: The user creates a new git branch (e.g., `git checkout -b feature/user-auth`).
 64: - **Your Action**: Propose creating a new tag that mirrors the branch name to isolate the feature's tasks from `master`.
 65: - **Your Suggested Prompt**: *"I see you've created a new branch named 'feature/user-auth'. To keep all related tasks neatly organized and separate from your main list, I can create a corresponding task tag for you. This helps prevent merge conflicts in your `tasks.json` file later. Shall I create the 'feature-user-auth' tag?"*
 66: - **Tool to Use**: `task-master add-tag --from-branch`
 67: 
 68: #### Pattern 2: Team Collaboration
 69: - **Trigger**: The user mentions working with teammates (e.g., "My teammate Alice is handling the database schema," or "I need to review Bob's work on the API.").
 70: - **Your Action**: Suggest creating a separate tag for the user's work to prevent conflicts with shared master context.
 71: - **Your Suggested Prompt**: *"Since you're working with Alice, I can create a separate task context for your work to avoid conflicts. This way, Alice can continue working with the master list while you have your own isolated context. When you're ready to merge your work, we can coordinate the tasks back to master. Shall I create a tag for your current work?"*
 72: - **Tool to Use**: `task-master add-tag my-work --copy-from-current --description="My tasks while collaborating with Alice"`
 73: 
 74: #### Pattern 3: Experiments or Risky Refactors
 75: - **Trigger**: The user wants to try something that might not be kept (e.g., "I want to experiment with switching our state management library," or "Let's refactor the old API module, but I want to keep the current tasks as a reference.").
 76: - **Your Action**: Propose creating a sandboxed tag for the experimental work.
 77: - **Your Suggested Prompt**: *"This sounds like a great experiment. To keep these new tasks separate from our main plan, I can create a temporary 'experiment-zustand' tag for this work. If we decide not to proceed, we can simply delete the tag without affecting the main task list. Sound good?"*
 78: - **Tool to Use**: `task-master add-tag experiment-zustand --description="Exploring Zustand migration"`
 79: 
 80: #### Pattern 4: Large Feature Initiatives (PRD-Driven)
 81: This is a more structured approach for significant new features or epics.
 82: 
 83: - **Trigger**: The user describes a large, multi-step feature that would benefit from a formal plan.
 84: - **Your Action**: Propose a comprehensive, PRD-driven workflow.
 85: - **Your Suggested Prompt**: *"This sounds like a significant new feature. To manage this effectively, I suggest we create a dedicated task context for it. Here's the plan: I'll create a new tag called 'feature-xyz', then we can draft a Product Requirements Document (PRD) together to scope the work. Once the PRD is ready, I'll automatically generate all the necessary tasks within that new tag. How does that sound?"*
 86: - **Your Implementation Flow**:
 87:     1.  **Create an empty tag**: `task-master add-tag feature-xyz --description "Tasks for the new XYZ feature"`. You can also start by creating a git branch if applicable, and then create the tag from that branch.
 88:     2.  **Collaborate & Create PRD**: Work with the user to create a detailed PRD file (e.g., `.taskmaster/docs/feature-xyz-prd.txt`).
 89:     3.  **Parse PRD into the new tag**: `task-master parse-prd .taskmaster/docs/feature-xyz-prd.txt --tag feature-xyz`
 90:     4.  **Prepare the new task list**: Follow up by suggesting `analyze-complexity` and `expand-all` for the newly created tasks within the `feature-xyz` tag.
 91: 
 92: #### Pattern 5: Version-Based Development
 93: Tailor your approach based on the project maturity indicated by tag names.
 94: 
 95: - **Prototype/MVP Tags** (`prototype`, `mvp`, `poc`, `v0.x`):
 96:   - **Your Approach**: Focus on speed and functionality over perfection
 97:   - **Task Generation**: Create tasks that emphasize "get it working" over "get it perfect"
 98:   - **Complexity Level**: Lower complexity, fewer subtasks, more direct implementation paths
 99:   - **Research Prompts**: Include context like "This is a prototype - prioritize speed and basic functionality over optimization"
100:   - **Example Prompt Addition**: *"Since this is for the MVP, I'll focus on tasks that get core functionality working quickly rather than over-engineering."*
101: 
102: - **Production/Mature Tags** (`v1.0+`, `production`, `stable`):
103:   - **Your Approach**: Emphasize robustness, testing, and maintainability
104:   - **Task Generation**: Include comprehensive error handling, testing, documentation, and optimization
105:   - **Complexity Level**: Higher complexity, more detailed subtasks, thorough implementation paths
106:   - **Research Prompts**: Include context like "This is for production - prioritize reliability, performance, and maintainability"
107:   - **Example Prompt Addition**: *"Since this is for production, I'll ensure tasks include proper error handling, testing, and documentation."*
108: 
109: ### Advanced Workflow (Tag-Based & PRD-Driven)
110: 
111: **When to Transition**: Recognize when the project has evolved (or has initiated a project which existing code) beyond simple task management. Look for these indicators:
112: - User mentions teammates or collaboration needs
113: - Project has grown to 15+ tasks with mixed priorities
114: - User creates feature branches or mentions major initiatives
115: - User initializes Taskmaster on an existing, complex codebase
116: - User describes large features that would benefit from dedicated planning
117: 
118: **Your Role in Transition**: Guide the user to a more sophisticated workflow that leverages tags for organization and PRDs for comprehensive planning.
119: 
120: #### Master List Strategy (High-Value Focus)
121: Once you transition to tag-based workflows, the `master` tag should ideally contain only:
122: - **High-level deliverables** that provide significant business value
123: - **Major milestones** and epic-level features
124: - **Critical infrastructure** work that affects the entire project
125: - **Release-blocking** items
126: 
127: **What NOT to put in master**:
128: - Detailed implementation subtasks (these go in feature-specific tags' parent tasks)
129: - Refactoring work (create dedicated tags like `refactor-auth`)
130: - Experimental features (use `experiment-*` tags)
131: - Team member-specific tasks (use person-specific tags)
132: 
133: #### PRD-Driven Feature Development
134: 
135: **For New Major Features**:
136: 1. **Identify the Initiative**: When user describes a significant feature
137: 2. **Create Dedicated Tag**: `add_tag feature-[name] --description="[Feature description]"`
138: 3. **Collaborative PRD Creation**: Work with user to create comprehensive PRD in `.taskmaster/docs/feature-[name]-prd.txt`
139: 4. **Parse & Prepare**: 
140:    - `parse_prd .taskmaster/docs/feature-[name]-prd.txt --tag=feature-[name]`
141:    - `analyze_project_complexity --tag=feature-[name] --research`
142:    - `expand_all --tag=feature-[name] --research`
143: 5. **Add Master Reference**: Create a high-level task in `master` that references the feature tag
144: 
145: **For Existing Codebase Analysis**:
146: When users initialize Taskmaster on existing projects:
147: 1. **Codebase Discovery**: Use your native tools for producing deep context about the code base. You may use `research` tool with `--tree` and `--files` to collect up to date information using the existing architecture as context.
148: 2. **Collaborative Assessment**: Work with user to identify improvement areas, technical debt, or new features
149: 3. **Strategic PRD Creation**: Co-author PRDs that include:
150:    - Current state analysis (based on your codebase research)
151:    - Proposed improvements or new features
152:    - Implementation strategy considering existing code
153: 4. **Tag-Based Organization**: Parse PRDs into appropriate tags (`refactor-api`, `feature-dashboard`, `tech-debt`, etc.)
154: 5. **Master List Curation**: Keep only the most valuable initiatives in master
155: 
156: The parse-prd's `--append` flag enables the user to parse multple PRDs within tags or across tags. PRDs should be focused and the number of tasks they are parsed into should be strategically chosen relative to the PRD's complexity and level of detail.
157: 
158: ### Workflow Transition Examples
159: 
160: **Example 1: Simple  Team-Based**
161: ```
162: User: "Alice is going to help with the API work"
163: Your Response: "Great! To avoid conflicts, I'll create a separate task context for your work. Alice can continue with the master list while you work in your own context. When you're ready to merge, we can coordinate the tasks back together."
164: Action: add_tag my-api-work --copy-from-current --description="My API tasks while collaborating with Alice"
165: ```
166: 
167: **Example 2: Simple  PRD-Driven**
168: ```
169: User: "I want to add a complete user dashboard with analytics, user management, and reporting"
170: Your Response: "This sounds like a major feature that would benefit from detailed planning. Let me create a dedicated context for this work and we can draft a PRD together to ensure we capture all requirements."
171: Actions: 
172: 1. add_tag feature-dashboard --description="User dashboard with analytics and management"
173: 2. Collaborate on PRD creation
174: 3. parse_prd dashboard-prd.txt --tag=feature-dashboard
175: 4. Add high-level "User Dashboard" task to master
176: ```
177: 
178: **Example 3: Existing Project  Strategic Planning**
179: ```
180: User: "I just initialized Taskmaster on my existing React app. It's getting messy and I want to improve it."
181: Your Response: "Let me research your codebase to understand the current architecture, then we can create a strategic plan for improvements."
182: Actions:
183: 1. research "Current React app architecture and improvement opportunities" --tree --files=src/
184: 2. Collaborate on improvement PRD based on findings
185: 3. Create tags for different improvement areas (refactor-components, improve-state-management, etc.)
186: 4. Keep only major improvement initiatives in master
187: ```
188: 
189: ---
190: 
191: ## Primary Interaction: MCP Server vs. CLI
192: 
193: Taskmaster offers two primary ways to interact:
194: 
195: 1.  **MCP Server (Recommended for Integrated Tools)**:
196:     - For AI agents and integrated development environments (like VS Code), interacting via the **MCP server is the preferred method**.
197:     - The MCP server exposes Taskmaster functionality through a set of tools (e.g., `get_tasks`, `add_subtask`).
198:     - This method offers better performance, structured data exchange, and richer error handling compared to CLI parsing.
199:     - Refer to @`mcp.md` for details on the MCP architecture and available tools.
200:     - A comprehensive list and description of MCP tools and their corresponding CLI commands can be found in @`taskmaster.md`.
201:     - **Restart the MCP server** if core logic in `scripts/modules` or MCP tool/direct function definitions change.
202:     - **Note**: MCP tools fully support tagged task lists with complete tag management capabilities.
203: 
204: 2.  **`task-master` CLI (For Users & Fallback)**:
205:     - The global `task-master` command provides a user-friendly interface for direct terminal interaction.
206:     - It can also serve as a fallback if the MCP server is inaccessible or a specific function isn't exposed via MCP.
207:     - Install globally with `npm install -g task-master-ai` or use locally via `npx task-master-ai ...`.
208:     - The CLI commands often mirror the MCP tools (e.g., `task-master list` corresponds to `get_tasks`).
209:     - Refer to @`taskmaster.md` for a detailed command reference.
210:     - **Tagged Task Lists**: CLI fully supports the new tagged system with seamless migration.
211: 
212: ## How the Tag System Works (For Your Reference)
213: 
214: - **Data Structure**: Tasks are organized into separate contexts (tags) like "master", "feature-branch", or "v2.0".
215: - **Silent Migration**: Existing projects automatically migrate to use a "master" tag with zero disruption.
216: - **Context Isolation**: Tasks in different tags are completely separate. Changes in one tag do not affect any other tag.
217: - **Manual Control**: The user is always in control. There is no automatic switching. You facilitate switching by using `use-tag <name>`.
218: - **Full CLI & MCP Support**: All tag management commands are available through both the CLI and MCP tools for you to use. Refer to @`taskmaster.md` for a full command list.
219: 
220: ---
221: 
222: ## Task Complexity Analysis
223: 
224: -   Run `analyze_project_complexity` / `task-master analyze-complexity --research` (see @`taskmaster.md`) for comprehensive analysis
225: -   Review complexity report via `complexity_report` / `task-master complexity-report` (see @`taskmaster.md`) for a formatted, readable version.
226: -   Focus on tasks with highest complexity scores (8-10) for detailed breakdown
227: -   Use analysis results to determine appropriate subtask allocation
228: -   Note that reports are automatically used by the `expand_task` tool/command
229: 
230: ## Task Breakdown Process
231: 
232: -   Use `expand_task` / `task-master expand --id=<id>`. It automatically uses the complexity report if found, otherwise generates default number of subtasks.
233: -   Use `--num=<number>` to specify an explicit number of subtasks, overriding defaults or complexity report recommendations.
234: -   Add `--research` flag to leverage Perplexity AI for research-backed expansion.
235: -   Add `--force` flag to clear existing subtasks before generating new ones (default is to append).
236: -   Use `--prompt="<context>"` to provide additional context when needed.
237: -   Review and adjust generated subtasks as necessary.
238: -   Use `expand_all` tool or `task-master expand --all` to expand multiple pending tasks at once, respecting flags like `--force` and `--research`.
239: -   If subtasks need complete replacement (regardless of the `--force` flag on `expand`), clear them first with `clear_subtasks` / `task-master clear-subtasks --id=<id>`.
240: 
241: ## Implementation Drift Handling
242: 
243: -   When implementation differs significantly from planned approach
244: -   When future tasks need modification due to current implementation choices
245: -   When new dependencies or requirements emerge
246: -   Use `update` / `task-master update --from=<futureTaskId> --prompt='<explanation>\nUpdate context...' --research` to update multiple future tasks.
247: -   Use `update_task` / `task-master update-task --id=<taskId> --prompt='<explanation>\nUpdate context...' --research` to update a single specific task.
248: 
249: ## Task Status Management
250: 
251: -   Use 'pending' for tasks ready to be worked on
252: -   Use 'done' for completed and verified tasks
253: -   Use 'deferred' for postponed tasks
254: -   Add custom status values as needed for project-specific workflows
255: 
256: ## Task Structure Fields
257: 
258: - **id**: Unique identifier for the task (Example: `1`, `1.1`)
259: - **title**: Brief, descriptive title (Example: `"Initialize Repo"`)
260: - **description**: Concise summary of what the task involves (Example: `"Create a new repository, set up initial structure."`)
261: - **status**: Current state of the task (Example: `"pending"`, `"done"`, `"deferred"`)
262: - **dependencies**: IDs of prerequisite tasks (Example: `[1, 2.1]`)
263:     - Dependencies are displayed with status indicators ( for completed,  for pending)
264:     - This helps quickly identify which prerequisite tasks are blocking work
265: - **priority**: Importance level (Example: `"high"`, `"medium"`, `"low"`)
266: - **details**: In-depth implementation instructions (Example: `"Use GitHub client ID/secret, handle callback, set session token."`) 
267: - **testStrategy**: Verification approach (Example: `"Deploy and call endpoint to confirm 'Hello World' response."`) 
268: - **subtasks**: List of smaller, more specific tasks (Example: `[{"id": 1, "title": "Configure OAuth", ...}]`) 
269: - Refer to task structure details (previously linked to `tasks.md`).
270: 
271: ## Configuration Management (Updated)
272: 
273: Taskmaster configuration is managed through two main mechanisms:
274: 
275: 1.  **`.taskmaster/config.json` File (Primary):**
276:     *   Located in the project root directory.
277:     *   Stores most configuration settings: AI model selections (main, research, fallback), parameters (max tokens, temperature), logging level, default subtasks/priority, project name, etc.
278:     *   **Tagged System Settings**: Includes `global.defaultTag` (defaults to "master") and `tags` section for tag management configuration.
279:     *   **Managed via `task-master models --setup` command.** Do not edit manually unless you know what you are doing.
280:     *   **View/Set specific models via `task-master models` command or `models` MCP tool.**
281:     *   Created automatically when you run `task-master models --setup` for the first time or during tagged system migration.
282: 
283: 2.  **Environment Variables (`.env` / `mcp.json`):**
284:     *   Used **only** for sensitive API keys and specific endpoint URLs.
285:     *   Place API keys (one per provider) in a `.env` file in the project root for CLI usage.
286:     *   For MCP/VS Code integration, configure these keys in the `env` section of `.vscode/mcp.json`.
287:     *   Available keys/variables: See `assets/env.example` or the Configuration section in the command reference (previously linked to `taskmaster.md`).
288: 
289: 3.  **`.taskmaster/state.json` File (Tagged System State):**
290:     *   Tracks current tag context and migration status.
291:     *   Automatically created during tagged system migration.
292:     *   Contains: `currentTag`, `lastSwitched`, `migrationNoticeShown`.
293: 
294: **Important:** Non-API key settings (like model selections, `MAX_TOKENS`, `TASKMASTER_LOG_LEVEL`) are **no longer configured via environment variables**. Use the `task-master models` command (or `--setup` for interactive configuration) or the `models` MCP tool.
295: **If AI commands FAIL in MCP** verify that the API key for the selected provider is present in the `env` section of `.vscode/mcp.json`.
296: **If AI commands FAIL in CLI** verify that the API key for the selected provider is present in the `.env` file in the root of the project.
297: 
298: ## Rules Management
299: 
300: Taskmaster supports multiple AI coding assistant rule sets that can be configured during project initialization or managed afterward:
301: 
302: - **Available Profiles**: Claude Code, Cline, Codex, VS Code, Roo Code, Trae, Windsurf (claude, cline, codex, vscode, roo, trae, windsurf)
303: - **During Initialization**: Use `task-master init --rules vscode,windsurf` to specify which rule sets to include
304: - **After Initialization**: Use `task-master rules add <profiles>` or `task-master rules remove <profiles>` to manage rule sets
305: - **Interactive Setup**: Use `task-master rules setup` to launch an interactive prompt for selecting rule profiles
306: - **Default Behavior**: If no `--rules` flag is specified during initialization, all available rule profiles are included
307: - **Rule Structure**: Each profile creates its own directory (e.g., `.github/instructions`, `.roo/rules`) with appropriate configuration files
308: 
309: ## Determining the Next Task
310: 
311: - Run `next_task` / `task-master next` to show the next task to work on.
312: - The command identifies tasks with all dependencies satisfied
313: - Tasks are prioritized by priority level, dependency count, and ID
314: - The command shows comprehensive task information including:
315:     - Basic task details and description
316:     - Implementation details
317:     - Subtasks (if they exist)
318:     - Contextual suggested actions
319: - Recommended before starting any new development work
320: - Respects your project's dependency structure
321: - Ensures tasks are completed in the appropriate sequence
322: - Provides ready-to-use commands for common task actions
323: 
324: ## Viewing Specific Task Details
325: 
326: - Run `get_task` / `task-master show <id>` to view a specific task.
327: - Use dot notation for subtasks: `task-master show 1.2` (shows subtask 2 of task 1)
328: - Displays comprehensive information similar to the next command, but for a specific task
329: - For parent tasks, shows all subtasks and their current status
330: - For subtasks, shows parent task information and relationship
331: - Provides contextual suggested actions appropriate for the specific task
332: - Useful for examining task details before implementation or checking status
333: 
334: ## Managing Task Dependencies
335: 
336: - Use `add_dependency` / `task-master add-dependency --id=<id> --depends-on=<id>` to add a dependency.
337: - Use `remove_dependency` / `task-master remove-dependency --id=<id> --depends-on=<id>` to remove a dependency.
338: - The system prevents circular dependencies and duplicate dependency entries
339: - Dependencies are checked for existence before being added or removed
340: - Task files are automatically regenerated after dependency changes
341: - Dependencies are visualized with status indicators in task listings and files
342: 
343: ## Task Reorganization
344: 
345: - Use `move_task` / `task-master move --from=<id> --to=<id>` to move tasks or subtasks within the hierarchy
346: - This command supports several use cases:
347:   - Moving a standalone task to become a subtask (e.g., `--from=5 --to=7`)
348:   - Moving a subtask to become a standalone task (e.g., `--from=5.2 --to=7`) 
349:   - Moving a subtask to a different parent (e.g., `--from=5.2 --to=7.3`)
350:   - Reordering subtasks within the same parent (e.g., `--from=5.2 --to=5.4`)
351:   - Moving a task to a new, non-existent ID position (e.g., `--from=5 --to=25`)
352:   - Moving multiple tasks at once using comma-separated IDs (e.g., `--from=10,11,12 --to=16,17,18`)
353: - The system includes validation to prevent data loss:
354:   - Allows moving to non-existent IDs by creating placeholder tasks
355:   - Prevents moving to existing task IDs that have content (to avoid overwriting)
356:   - Validates source tasks exist before attempting to move them
357: - The system maintains proper parent-child relationships and dependency integrity
358: - Task files are automatically regenerated after the move operation
359: - This provides greater flexibility in organizing and refining your task structure as project understanding evolves
360: - This is especially useful when dealing with potential merge conflicts arising from teams creating tasks on separate branches. Solve these conflicts very easily by moving your tasks and keeping theirs.
361: 
362: ## Iterative Subtask Implementation
363: 
364: Once a task has been broken down into subtasks using `expand_task` or similar methods, follow this iterative process for implementation:
365: 
366: 1.  **Understand the Goal (Preparation):**
367:     *   Use `get_task` / `task-master show <subtaskId>` (see @`taskmaster.md`) to thoroughly understand the specific goals and requirements of the subtask.
368: 
369: 2.  **Initial Exploration & Planning (Iteration 1):**
370:     *   This is the first attempt at creating a concrete implementation plan.
371:     *   Explore the codebase to identify the precise files, functions, and even specific lines of code that will need modification.
372:     *   Determine the intended code changes (diffs) and their locations.
373:     *   Gather *all* relevant details from this exploration phase.
374: 
375: 3.  **Log the Plan:**
376:     *   Run `update_subtask` / `task-master update-subtask --id=<subtaskId> --prompt='<detailed plan>'`.
377:     *   Provide the *complete and detailed* findings from the exploration phase in the prompt. Include file paths, line numbers, proposed diffs, reasoning, and any potential challenges identified. Do not omit details. The goal is to create a rich, timestamped log within the subtask's `details`.
378: 
379: 4.  **Verify the Plan:**
380:     *   Run `get_task` / `task-master show <subtaskId>` again to confirm that the detailed implementation plan has been successfully appended to the subtask's details.
381: 
382: 5.  **Begin Implementation:**
383:     *   Set the subtask status using `set_task_status` / `task-master set-status --id=<subtaskId> --status=in-progress`.
384:     *   Start coding based on the logged plan.
385: 
386: 6.  **Refine and Log Progress (Iteration 2+):**
387:     *   As implementation progresses, you will encounter challenges, discover nuances, or confirm successful approaches.
388:     *   **Before appending new information**: Briefly review the *existing* details logged in the subtask (using `get_task` or recalling from context) to ensure the update adds fresh insights and avoids redundancy.
389:     *   **Regularly** use `update_subtask` / `task-master update-subtask --id=<subtaskId> --prompt='<update details>\n- What worked...\n- What didn't work...'` to append new findings.
390:     *   **Crucially, log:**
391:         *   What worked ("fundamental truths" discovered).
392:         *   What didn't work and why (to avoid repeating mistakes).
393:         *   Specific code snippets or configurations that were successful.
394:         *   Decisions made, especially if confirmed with user input.
395:         *   Any deviations from the initial plan and the reasoning.
396:     *   The objective is to continuously enrich the subtask's details, creating a log of the implementation journey that helps the AI (and human developers) learn, adapt, and avoid repeating errors.
397: 
398: 7.  **Review & Update Rules (Post-Implementation):**
399:     *   Once the implementation for the subtask is functionally complete, review all code changes and the relevant chat history.
400:     *   Identify any new or modified code patterns, conventions, or best practices established during the implementation.
401:     *   Create new or update existing rules following internal guidelines (previously linked to `cursor_rules.md` and `self_improve.md`).
402: 
403: 8.  **Mark Task Complete:**
404:     *   After verifying the implementation and updating any necessary rules, mark the subtask as completed: `set_task_status` / `task-master set-status --id=<subtaskId> --status=done`.
405: 
406: 9.  **Commit Changes (If using Git):**
407:     *   Stage the relevant code changes and any updated/new rule files (`git add .`).
408:     *   Craft a comprehensive Git commit message summarizing the work done for the subtask, including both code implementation and any rule adjustments.
409:     *   Execute the commit command directly in the terminal (e.g., `git commit -m 'feat(module): Implement feature X for subtask <subtaskId>\n\n- Details about changes...\n- Updated rule Y for pattern Z'`).
410:     *   Consider if a Changeset is needed according to internal versioning guidelines (previously linked to `changeset.md`). If so, run `npm run changeset`, stage the generated file, and amend the commit or create a new one.
411: 
412: 10. **Proceed to Next Subtask:**
413:     *   Identify the next subtask (e.g., using `next_task` / `task-master next`).
414: 
415: ## Code Analysis & Refactoring Techniques
416: 
417: - **Top-Level Function Search**:
418:     - Useful for understanding module structure or planning refactors.
419:     - Use grep/ripgrep to find exported functions/constants:
420:       `rg "export (async function|function|const) \w+"` or similar patterns.
421:     - Can help compare functions between files during migrations or identify potential naming conflicts.
422: 
423: ---
424: *This workflow provides a general guideline. Adapt it based on your specific project needs and team practices.*
</file>

<file path=".github/instructions/self_improve.md">
 1: ---
 2: description: Guidelines for continuously improving VS Code rules based on emerging code patterns and best practices.
 3: applyTo: "**/*"
 4: alwaysApply: true
 5: ---
 6: 
 7: - **Rule Improvement Triggers:**
 8:   - New code patterns not covered by existing rules
 9:   - Repeated similar implementations across files
10:   - Common error patterns that could be prevented
11:   - New libraries or tools being used consistently
12:   - Emerging best practices in the codebase
13: 
14: - **Analysis Process:**
15:   - Compare new code with existing rules
16:   - Identify patterns that should be standardized
17:   - Look for references to external documentation
18:   - Check for consistent error handling patterns
19:   - Monitor test patterns and coverage
20: 
21: - **Rule Updates:**
22:   - **Add New Rules When:**
23:     - A new technology/pattern is used in 3+ files
24:     - Common bugs could be prevented by a rule
25:     - Code reviews repeatedly mention the same feedback
26:     - New security or performance patterns emerge
27: 
28:   - **Modify Existing Rules When:**
29:     - Better examples exist in the codebase
30:     - Additional edge cases are discovered
31:     - Related rules have been updated
32:     - Implementation details have changed
33: 
34: - **Example Pattern Recognition:**
35:   ```typescript
36:   // If you see repeated patterns like:
37:   const data = await prisma.user.findMany({
38:     select: { id: true, email: true },
39:     where: { status: 'ACTIVE' }
40:   });
41:   
42:   // Consider adding to [prisma.md](.github/instructions/prisma.md):
43:   // - Standard select fields
44:   // - Common where conditions
45:   // - Performance optimization patterns
46:   ```
47: 
48: - **Rule Quality Checks:**
49:   - Rules should be actionable and specific
50:   - Examples should come from actual code
51:   - References should be up to date
52:   - Patterns should be consistently enforced
53: 
54: - **Continuous Improvement:**
55:   - Monitor code review comments
56:   - Track common development questions
57:   - Update rules after major refactors
58:   - Add links to relevant documentation
59:   - Cross-reference related rules
60: 
61: - **Rule Deprecation:**
62:   - Mark outdated patterns as deprecated
63:   - Remove rules that no longer apply
64:   - Update references to deprecated rules
65:   - Document migration paths for old patterns
66: 
67: - **Documentation Updates:**
68:   - Keep examples synchronized with code
69:   - Update references to external docs
70:   - Maintain links between related rules
71:   - Document breaking changes
72: Follow [vscode_rules.md](.github/instructions/vscode_rules.md) for proper rule formatting and structure.
</file>

<file path=".github/instructions/taskmaster.md">
  1: ---
  2: description: Comprehensive reference for Taskmaster MCP tools and CLI commands.
  3: applyTo: "**/*"
  4: alwaysApply: true
  5: ---
  6: 
  7: # Taskmaster Tool & Command Reference
  8: 
  9: This document provides a detailed reference for interacting with Taskmaster, covering both the recommended MCP tools, suitable for integrations like VS Code, and the corresponding `task-master` CLI commands, designed for direct user interaction or fallback.
 10: 
 11: **Note:** For interacting with Taskmaster programmatically or via integrated tools, using the **MCP tools is strongly recommended** due to better performance, structured data, and error handling. The CLI commands serve as a user-friendly alternative and fallback. 
 12: 
 13: **Important:** Several MCP tools involve AI processing... The AI-powered tools include `parse_prd`, `analyze_project_complexity`, `update_subtask`, `update_task`, `update`, `expand_all`, `expand_task`, and `add_task`.
 14: 
 15: ** Tagged Task Lists System:** Task Master now supports **tagged task lists** for multi-context task management. This allows you to maintain separate, isolated lists of tasks for different features, branches, or experiments. Existing projects are seamlessly migrated to use a default "master" tag. Most commands now support a `--tag <name>` flag to specify which context to operate on. If omitted, commands use the currently active tag.
 16: 
 17: ---
 18: 
 19: ## Initialization & Setup
 20: 
 21: ### 1. Initialize Project (`init`)
 22: 
 23: *   **MCP Tool:** `initialize_project`
 24: *   **CLI Command:** `task-master init [options]`
 25: *   **Description:** `Set up the basic Taskmaster file structure and configuration in the current directory for a new project.`
 26: *   **Key CLI Options:**
 27:     *   `--name <name>`: `Set the name for your project in Taskmaster's configuration.`
 28:     *   `--description <text>`: `Provide a brief description for your project.`
 29:     *   `--version <version>`: `Set the initial version for your project, e.g., '0.1.0'.`
 30:     *   `-y, --yes`: `Initialize Taskmaster quickly using default settings without interactive prompts.`
 31: *   **Usage:** Run this once at the beginning of a new project.
 32: *   **MCP Variant Description:** `Set up the basic Taskmaster file structure and configuration in the current directory for a new project by running the 'task-master init' command.`
 33: *   **Key MCP Parameters/Options:**
 34:     *   `projectName`: `Set the name for your project.` (CLI: `--name <name>`)
 35:     *   `projectDescription`: `Provide a brief description for your project.` (CLI: `--description <text>`)
 36:     *   `projectVersion`: `Set the initial version for your project, e.g., '0.1.0'.` (CLI: `--version <version>`)
 37:     *   `authorName`: `Author name.` (CLI: `--author <author>`)
 38:     *   `skipInstall`: `Skip installing dependencies. Default is false.` (CLI: `--skip-install`)
 39:     *   `addAliases`: `Add shell aliases tm and taskmaster. Default is false.` (CLI: `--aliases`)
 40:     *   `yes`: `Skip prompts and use defaults/provided arguments. Default is false.` (CLI: `-y, --yes`)
 41: *   **Usage:** Run this once at the beginning of a new project, typically via an integrated tool like VS Code. Operates on the current working directory of the MCP server. 
 42: *   **Important:** Once complete, you *MUST* parse a prd in order to generate tasks. There will be no tasks files until then. The next step after initializing should be to create a PRD using the example PRD in .taskmaster/templates/example_prd.txt. 
 43: *   **Tagging:** Use the `--tag` option to parse the PRD into a specific, non-default tag context. If the tag doesn't exist, it will be created automatically. Example: `task-master parse-prd spec.txt --tag=new-feature`.
 44: 
 45: ### 2. Parse PRD (`parse_prd`)
 46: 
 47: *   **MCP Tool:** `parse_prd`
 48: *   **CLI Command:** `task-master parse-prd [file] [options]`
 49: *   **Description:** `Parse a Product Requirements Document, PRD, or text file with Taskmaster to automatically generate an initial set of tasks in tasks.json.`
 50: *   **Key Parameters/Options:**
 51:     *   `input`: `Path to your PRD or requirements text file that Taskmaster should parse for tasks.` (CLI: `[file]` positional or `-i, --input <file>`)
 52:     *   `output`: `Specify where Taskmaster should save the generated 'tasks.json' file. Defaults to '.taskmaster/tasks/tasks.json'.` (CLI: `-o, --output <file>`)
 53:     *   `numTasks`: `Approximate number of top-level tasks Taskmaster should aim to generate from the document.` (CLI: `-n, --num-tasks <number>`)
 54:     *   `force`: `Use this to allow Taskmaster to overwrite an existing 'tasks.json' without asking for confirmation.` (CLI: `-f, --force`)
 55: *   **Usage:** Useful for bootstrapping a project from an existing requirements document.
 56: *   **Notes:** Task Master will strictly adhere to any specific requirements mentioned in the PRD, such as libraries, database schemas, frameworks, tech stacks, etc., while filling in any gaps where the PRD isn't fully specified. Tasks are designed to provide the most direct implementation path while avoiding over-engineering.
 57: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress. If the user does not have a PRD, suggest discussing their idea and then use the example PRD in `.taskmaster/templates/example_prd.txt` as a template for creating the PRD based on their idea, for use with `parse-prd`.
 58: 
 59: ---
 60: 
 61: ## AI Model Configuration
 62: 
 63: ### 2. Manage Models (`models`)
 64: *   **MCP Tool:** `models`
 65: *   **CLI Command:** `task-master models [options]`
 66: *   **Description:** `View the current AI model configuration or set specific models for different roles (main, research, fallback). Allows setting custom model IDs for Ollama and OpenRouter.`
 67: *   **Key MCP Parameters/Options:**
 68:     *   `setMain <model_id>`: `Set the primary model ID for task generation/updates.` (CLI: `--set-main <model_id>`)
 69:     *   `setResearch <model_id>`: `Set the model ID for research-backed operations.` (CLI: `--set-research <model_id>`)
 70:     *   `setFallback <model_id>`: `Set the model ID to use if the primary fails.` (CLI: `--set-fallback <model_id>`)
 71:     *   `ollama <boolean>`: `Indicates the set model ID is a custom Ollama model.` (CLI: `--ollama`)
 72:     *   `openrouter <boolean>`: `Indicates the set model ID is a custom OpenRouter model.` (CLI: `--openrouter`)
 73:     *   `listAvailableModels <boolean>`: `If true, lists available models not currently assigned to a role.` (CLI: No direct equivalent; CLI lists available automatically)
 74:     *   `projectRoot <string>`: `Optional. Absolute path to the project root directory.` (CLI: Determined automatically)
 75: *   **Key CLI Options:**
 76:     *   `--set-main <model_id>`: `Set the primary model.`
 77:     *   `--set-research <model_id>`: `Set the research model.`
 78:     *   `--set-fallback <model_id>`: `Set the fallback model.`
 79:     *   `--ollama`: `Specify that the provided model ID is for Ollama (use with --set-*).`
 80:     *   `--openrouter`: `Specify that the provided model ID is for OpenRouter (use with --set-*). Validates against OpenRouter API.`
 81:     *   `--bedrock`: `Specify that the provided model ID is for AWS Bedrock (use with --set-*).`
 82:     *   `--setup`: `Run interactive setup to configure models, including custom Ollama/OpenRouter IDs.`
 83: *   **Usage (MCP):** Call without set flags to get current config. Use `setMain`, `setResearch`, or `setFallback` with a valid model ID to update the configuration. Use `listAvailableModels: true` to get a list of unassigned models. To set a custom model, provide the model ID and set `ollama: true` or `openrouter: true`.
 84: *   **Usage (CLI):** Run without flags to view current configuration and available models. Use set flags to update specific roles. Use `--setup` for guided configuration, including custom models. To set a custom model via flags, use `--set-<role>=<model_id>` along with either `--ollama` or `--openrouter`.
 85: *   **Notes:** Configuration is stored in `.taskmaster/config.json` in the project root. This command/tool modifies that file. Use `listAvailableModels` or `task-master models` to see internally supported models. OpenRouter custom models are validated against their live API. Ollama custom models are not validated live.
 86: *   **API note:** API keys for selected AI providers (based on their model) need to exist in the mcp.json file to be accessible in MCP context. The API keys must be present in the local .env file for the CLI to be able to read them.
 87: *   **Model costs:** The costs in supported models are expressed in dollars. An input/output value of 3 is $3.00. A value of 0.8 is $0.80. 
 88: *   **Warning:** DO NOT MANUALLY EDIT THE .taskmaster/config.json FILE. Use the included commands either in the MCP or CLI format as needed. Always prioritize MCP tools when available and use the CLI as a fallback.
 89: 
 90: ---
 91: 
 92: ## Task Listing & Viewing
 93: 
 94: ### 3. Get Tasks (`get_tasks`)
 95: 
 96: *   **MCP Tool:** `get_tasks`
 97: *   **CLI Command:** `task-master list [options]`
 98: *   **Description:** `List your Taskmaster tasks, optionally filtering by status and showing subtasks.`
 99: *   **Key Parameters/Options:**
100:     *   `status`: `Show only Taskmaster tasks matching this status (or multiple statuses, comma-separated), e.g., 'pending' or 'done,in-progress'.` (CLI: `-s, --status <status>`)
101:     *   `withSubtasks`: `Include subtasks indented under their parent tasks in the list.` (CLI: `--with-subtasks`)
102:     *   `tag`: `Specify which tag context to list tasks from. Defaults to the current active tag.` (CLI: `--tag <name>`)
103:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
104: *   **Usage:** Get an overview of the project status, often used at the start of a work session.
105: 
106: ### 4. Get Next Task (`next_task`)
107: 
108: *   **MCP Tool:** `next_task`
109: *   **CLI Command:** `task-master next [options]`
110: *   **Description:** `Ask Taskmaster to show the next available task you can work on, based on status and completed dependencies.`
111: *   **Key Parameters/Options:**
112:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
113:     *   `tag`: `Specify which tag context to use. Defaults to the current active tag.` (CLI: `--tag <name>`)
114: *   **Usage:** Identify what to work on next according to the plan.
115: 
116: ### 5. Get Task Details (`get_task`)
117: 
118: *   **MCP Tool:** `get_task`
119: *   **CLI Command:** `task-master show [id] [options]`
120: *   **Description:** `Display detailed information for one or more specific Taskmaster tasks or subtasks by ID.`
121: *   **Key Parameters/Options:**
122:     *   `id`: `Required. The ID of the Taskmaster task (e.g., '15'), subtask (e.g., '15.2'), or a comma-separated list of IDs ('1,5,10.2') you want to view.` (CLI: `[id]` positional or `-i, --id <id>`)
123:     *   `tag`: `Specify which tag context to get the task(s) from. Defaults to the current active tag.` (CLI: `--tag <name>`)
124:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
125: *   **Usage:** Understand the full details for a specific task. When multiple IDs are provided, a summary table is shown.
126: *   **CRITICAL INFORMATION** If you need to collect information from multiple tasks, use comma-separated IDs (i.e. 1,2,3) to receive an array of tasks. Do not needlessly get tasks one at a time if you need to get many as that is wasteful.
127: 
128: ---
129: 
130: ## Task Creation & Modification
131: 
132: ### 6. Add Task (`add_task`)
133: 
134: *   **MCP Tool:** `add_task`
135: *   **CLI Command:** `task-master add-task [options]`
136: *   **Description:** `Add a new task to Taskmaster by describing it; AI will structure it.`
137: *   **Key Parameters/Options:**
138:     *   `prompt`: `Required. Describe the new task you want Taskmaster to create, e.g., "Implement user authentication using JWT".` (CLI: `-p, --prompt <text>`)
139:     *   `dependencies`: `Specify the IDs of any Taskmaster tasks that must be completed before this new one can start, e.g., '12,14'.` (CLI: `-d, --dependencies <ids>`)
140:     *   `priority`: `Set the priority for the new task: 'high', 'medium', or 'low'. Default is 'medium'.` (CLI: `--priority <priority>`)
141:     *   `research`: `Enable Taskmaster to use the research role for potentially more informed task creation.` (CLI: `-r, --research`)
142:     *   `tag`: `Specify which tag context to add the task to. Defaults to the current active tag.` (CLI: `--tag <name>`)
143:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
144: *   **Usage:** Quickly add newly identified tasks during development.
145: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
146: 
147: ### 7. Add Subtask (`add_subtask`)
148: 
149: *   **MCP Tool:** `add_subtask`
150: *   **CLI Command:** `task-master add-subtask [options]`
151: *   **Description:** `Add a new subtask to a Taskmaster parent task, or convert an existing task into a subtask.`
152: *   **Key Parameters/Options:**
153:     *   `id` / `parent`: `Required. The ID of the Taskmaster task that will be the parent.` (MCP: `id`, CLI: `-p, --parent <id>`)
154:     *   `taskId`: `Use this if you want to convert an existing top-level Taskmaster task into a subtask of the specified parent.` (CLI: `-i, --task-id <id>`)
155:     *   `title`: `Required if not using taskId. The title for the new subtask Taskmaster should create.` (CLI: `-t, --title <title>`)
156:     *   `description`: `A brief description for the new subtask.` (CLI: `-d, --description <text>`)
157:     *   `details`: `Provide implementation notes or details for the new subtask.` (CLI: `--details <text>`)
158:     *   `dependencies`: `Specify IDs of other tasks or subtasks, e.g., '15' or '16.1', that must be done before this new subtask.` (CLI: `--dependencies <ids>`)
159:     *   `status`: `Set the initial status for the new subtask. Default is 'pending'.` (CLI: `-s, --status <status>`)
160:     *   `skipGenerate`: `Prevent Taskmaster from automatically regenerating markdown task files after adding the subtask.` (CLI: `--skip-generate`)
161:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
162:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
163: *   **Usage:** Break down tasks manually or reorganize existing tasks.
164: 
165: ### 8. Update Tasks (`update`)
166: 
167: *   **MCP Tool:** `update`
168: *   **CLI Command:** `task-master update [options]`
169: *   **Description:** `Update multiple upcoming tasks in Taskmaster based on new context or changes, starting from a specific task ID.`
170: *   **Key Parameters/Options:**
171:     *   `from`: `Required. The ID of the first task Taskmaster should update. All tasks with this ID or higher that are not 'done' will be considered.` (CLI: `--from <id>`)
172:     *   `prompt`: `Required. Explain the change or new context for Taskmaster to apply to the tasks, e.g., "We are now using React Query instead of Redux Toolkit for data fetching".` (CLI: `-p, --prompt <text>`)
173:     *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
174:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
175:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
176: *   **Usage:** Handle significant implementation changes or pivots that affect multiple future tasks. Example CLI: `task-master update --from='18' --prompt='Switching to React Query.\nNeed to refactor data fetching...'`
177: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
178: 
179: ### 9. Update Task (`update_task`)
180: 
181: *   **MCP Tool:** `update_task`
182: *   **CLI Command:** `task-master update-task [options]`
183: *   **Description:** `Modify a specific Taskmaster task by ID, incorporating new information or changes. By default, this replaces the existing task details.`
184: *   **Key Parameters/Options:**
185:     *   `id`: `Required. The specific ID of the Taskmaster task, e.g., '15', you want to update.` (CLI: `-i, --id <id>`)
186:     *   `prompt`: `Required. Explain the specific changes or provide the new information Taskmaster should incorporate into this task.` (CLI: `-p, --prompt <text>`)
187:     *   `append`: `If true, appends the prompt content to the task's details with a timestamp, rather than replacing them. Behaves like update-subtask.` (CLI: `--append`)
188:     *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
189:     *   `tag`: `Specify which tag context the task belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
190:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
191: *   **Usage:** Refine a specific task based on new understanding. Use `--append` to log progress without creating subtasks.
192: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
193: 
194: ### 10. Update Subtask (`update_subtask`)
195: 
196: *   **MCP Tool:** `update_subtask`
197: *   **CLI Command:** `task-master update-subtask [options]`
198: *   **Description:** `Append timestamped notes or details to a specific Taskmaster subtask without overwriting existing content. Intended for iterative implementation logging.`
199: *   **Key Parameters/Options:**
200:     *   `id`: `Required. The ID of the Taskmaster subtask, e.g., '5.2', to update with new information.` (CLI: `-i, --id <id>`)
201:     *   `prompt`: `Required. The information, findings, or progress notes to append to the subtask's details with a timestamp.` (CLI: `-p, --prompt <text>`)
202:     *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
203:     *   `tag`: `Specify which tag context the subtask belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
204:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
205: *   **Usage:** Log implementation progress, findings, and discoveries during subtask development. Each update is timestamped and appended to preserve the implementation journey.
206: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
207: 
208: ### 11. Set Task Status (`set_task_status`)
209: 
210: *   **MCP Tool:** `set_task_status`
211: *   **CLI Command:** `task-master set-status [options]`
212: *   **Description:** `Update the status of one or more Taskmaster tasks or subtasks, e.g., 'pending', 'in-progress', 'done'.`
213: *   **Key Parameters/Options:**
214:     *   `id`: `Required. The ID(s) of the Taskmaster task(s) or subtask(s), e.g., '15', '15.2', or '16,17.1', to update.` (CLI: `-i, --id <id>`)
215:     *   `status`: `Required. The new status to set, e.g., 'done', 'pending', 'in-progress', 'review', 'cancelled'.` (CLI: `-s, --status <status>`)
216:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
217:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
218: *   **Usage:** Mark progress as tasks move through the development cycle.
219: 
220: ### 12. Remove Task (`remove_task`)
221: 
222: *   **MCP Tool:** `remove_task`
223: *   **CLI Command:** `task-master remove-task [options]`
224: *   **Description:** `Permanently remove a task or subtask from the Taskmaster tasks list.`
225: *   **Key Parameters/Options:**
226:     *   `id`: `Required. The ID of the Taskmaster task, e.g., '5', or subtask, e.g., '5.2', to permanently remove.` (CLI: `-i, --id <id>`)
227:     *   `yes`: `Skip the confirmation prompt and immediately delete the task.` (CLI: `-y, --yes`)
228:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
229:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
230: *   **Usage:** Permanently delete tasks or subtasks that are no longer needed in the project.
231: *   **Notes:** Use with caution as this operation cannot be undone. Consider using 'blocked', 'cancelled', or 'deferred' status instead if you just want to exclude a task from active planning but keep it for reference. The command automatically cleans up dependency references in other tasks.
232: 
233: ---
234: 
235: ## Task Structure & Breakdown
236: 
237: ### 13. Expand Task (`expand_task`)
238: 
239: *   **MCP Tool:** `expand_task`
240: *   **CLI Command:** `task-master expand [options]`
241: *   **Description:** `Use Taskmaster's AI to break down a complex task into smaller, manageable subtasks. Appends subtasks by default.`
242: *   **Key Parameters/Options:**
243:     *   `id`: `The ID of the specific Taskmaster task you want to break down into subtasks.` (CLI: `-i, --id <id>`)
244:     *   `num`: `Optional: Suggests how many subtasks Taskmaster should aim to create. Uses complexity analysis/defaults otherwise.` (CLI: `-n, --num <number>`)
245:     *   `research`: `Enable Taskmaster to use the research role for more informed subtask generation. Requires appropriate API key.` (CLI: `-r, --research`)
246:     *   `prompt`: `Optional: Provide extra context or specific instructions to Taskmaster for generating the subtasks.` (CLI: `-p, --prompt <text>`)
247:     *   `force`: `Optional: If true, clear existing subtasks before generating new ones. Default is false (append).` (CLI: `--force`)
248:     *   `tag`: `Specify which tag context the task belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
249:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
250: *   **Usage:** Generate a detailed implementation plan for a complex task before starting coding. Automatically uses complexity report recommendations if available and `num` is not specified.
251: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
252: 
253: ### 14. Expand All Tasks (`expand_all`)
254: 
255: *   **MCP Tool:** `expand_all`
256: *   **CLI Command:** `task-master expand --all [options]` (Note: CLI uses the `expand` command with the `--all` flag)
257: *   **Description:** `Tell Taskmaster to automatically expand all eligible pending/in-progress tasks based on complexity analysis or defaults. Appends subtasks by default.`
258: *   **Key Parameters/Options:**
259:     *   `num`: `Optional: Suggests how many subtasks Taskmaster should aim to create per task.` (CLI: `-n, --num <number>`)
260:     *   `research`: `Enable research role for more informed subtask generation. Requires appropriate API key.` (CLI: `-r, --research`)
261:     *   `prompt`: `Optional: Provide extra context for Taskmaster to apply generally during expansion.` (CLI: `-p, --prompt <text>`)
262:     *   `force`: `Optional: If true, clear existing subtasks before generating new ones for each eligible task. Default is false (append).` (CLI: `--force`)
263:     *   `tag`: `Specify which tag context to expand. Defaults to the current active tag.` (CLI: `--tag <name>`)
264:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
265: *   **Usage:** Useful after initial task generation or complexity analysis to break down multiple tasks at once.
266: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
267: 
268: ### 15. Clear Subtasks (`clear_subtasks`)
269: 
270: *   **MCP Tool:** `clear_subtasks`
271: *   **CLI Command:** `task-master clear-subtasks [options]`
272: *   **Description:** `Remove all subtasks from one or more specified Taskmaster parent tasks.`
273: *   **Key Parameters/Options:**
274:     *   `id`: `The ID(s) of the Taskmaster parent task(s) whose subtasks you want to remove, e.g., '15' or '16,18'. Required unless using `all`.) (CLI: `-i, --id <ids>`)
275:     *   `all`: `Tell Taskmaster to remove subtasks from all parent tasks.` (CLI: `--all`)
276:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
277:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
278: *   **Usage:** Used before regenerating subtasks with `expand_task` if the previous breakdown needs replacement.
279: 
280: ### 16. Remove Subtask (`remove_subtask`)
281: 
282: *   **MCP Tool:** `remove_subtask`
283: *   **CLI Command:** `task-master remove-subtask [options]`
284: *   **Description:** `Remove a subtask from its Taskmaster parent, optionally converting it into a standalone task.`
285: *   **Key Parameters/Options:**
286:     *   `id`: `Required. The ID(s) of the Taskmaster subtask(s) to remove, e.g., '15.2' or '16.1,16.3'.` (CLI: `-i, --id <id>`)
287:     *   `convert`: `If used, Taskmaster will turn the subtask into a regular top-level task instead of deleting it.` (CLI: `-c, --convert`)
288:     *   `skipGenerate`: `Prevent Taskmaster from automatically regenerating markdown task files after removing the subtask.` (CLI: `--skip-generate`)
289:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
290:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
291: *   **Usage:** Delete unnecessary subtasks or promote a subtask to a top-level task.
292: 
293: ### 17. Move Task (`move_task`)
294: 
295: *   **MCP Tool:** `move_task`
296: *   **CLI Command:** `task-master move [options]`
297: *   **Description:** `Move a task or subtask to a new position within the task hierarchy.`
298: *   **Key Parameters/Options:**
299:     *   `from`: `Required. ID of the task/subtask to move (e.g., "5" or "5.2"). Can be comma-separated for multiple tasks.` (CLI: `--from <id>`)
300:     *   `to`: `Required. ID of the destination (e.g., "7" or "7.3"). Must match the number of source IDs if comma-separated.` (CLI: `--to <id>`)
301:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
302:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
303: *   **Usage:** Reorganize tasks by moving them within the hierarchy. Supports various scenarios like:
304:     *   Moving a task to become a subtask
305:     *   Moving a subtask to become a standalone task
306:     *   Moving a subtask to a different parent
307:     *   Reordering subtasks within the same parent
308:     *   Moving a task to a new, non-existent ID (automatically creates placeholders)
309:     *   Moving multiple tasks at once with comma-separated IDs
310: *   **Validation Features:**
311:     *   Allows moving tasks to non-existent destination IDs (creates placeholder tasks)
312:     *   Prevents moving to existing task IDs that already have content (to avoid overwriting)
313:     *   Validates that source tasks exist before attempting to move them
314:     *   Maintains proper parent-child relationships
315: *   **Example CLI:** `task-master move --from=5.2 --to=7.3` to move subtask 5.2 to become subtask 7.3.
316: *   **Example Multi-Move:** `task-master move --from=10,11,12 --to=16,17,18` to move multiple tasks to new positions.
317: *   **Common Use:** Resolving merge conflicts in tasks.json when multiple team members create tasks on different branches.
318: 
319: ---
320: 
321: ## Dependency Management
322: 
323: ### 18. Add Dependency (`add_dependency`)
324: 
325: *   **MCP Tool:** `add_dependency`
326: *   **CLI Command:** `task-master add-dependency [options]`
327: *   **Description:** `Define a dependency in Taskmaster, making one task a prerequisite for another.`
328: *   **Key Parameters/Options:**
329:     *   `id`: `Required. The ID of the Taskmaster task that will depend on another.` (CLI: `-i, --id <id>`)
330:     *   `dependsOn`: `Required. The ID of the Taskmaster task that must be completed first, the prerequisite.` (CLI: `-d, --depends-on <id>`)
331:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
332:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <path>`)
333: *   **Usage:** Establish the correct order of execution between tasks.
334: 
335: ### 19. Remove Dependency (`remove_dependency`)
336: 
337: *   **MCP Tool:** `remove_dependency`
338: *   **CLI Command:** `task-master remove-dependency [options]`
339: *   **Description:** `Remove a dependency relationship between two Taskmaster tasks.`
340: *   **Key Parameters/Options:**
341:     *   `id`: `Required. The ID of the Taskmaster task you want to remove a prerequisite from.` (CLI: `-i, --id <id>`)
342:     *   `dependsOn`: `Required. The ID of the Taskmaster task that should no longer be a prerequisite.` (CLI: `-d, --depends-on <id>`)
343:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
344:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
345: *   **Usage:** Update task relationships when the order of execution changes.
346: 
347: ### 20. Validate Dependencies (`validate_dependencies`)
348: 
349: *   **MCP Tool:** `validate_dependencies`
350: *   **CLI Command:** `task-master validate-dependencies [options]`
351: *   **Description:** `Check your Taskmaster tasks for dependency issues (like circular references or links to non-existent tasks) without making changes.`
352: *   **Key Parameters/Options:**
353:     *   `tag`: `Specify which tag context to validate. Defaults to the current active tag.` (CLI: `--tag <name>`)
354:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
355: *   **Usage:** Audit the integrity of your task dependencies.
356: 
357: ### 21. Fix Dependencies (`fix_dependencies`)
358: 
359: *   **MCP Tool:** `fix_dependencies`
360: *   **CLI Command:** `task-master fix-dependencies [options]`
361: *   **Description:** `Automatically fix dependency issues (like circular references or links to non-existent tasks) in your Taskmaster tasks.`
362: *   **Key Parameters/Options:**
363:     *   `tag`: `Specify which tag context to fix dependencies in. Defaults to the current active tag.` (CLI: `--tag <name>`)
364:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
365: *   **Usage:** Clean up dependency errors automatically.
366: 
367: ---
368: 
369: ## Analysis & Reporting
370: 
371: ### 22. Analyze Project Complexity (`analyze_project_complexity`)
372: 
373: *   **MCP Tool:** `analyze_project_complexity`
374: *   **CLI Command:** `task-master analyze-complexity [options]`
375: *   **Description:** `Have Taskmaster analyze your tasks to determine their complexity and suggest which ones need to be broken down further.`
376: *   **Key Parameters/Options:**
377:     *   `output`: `Where to save the complexity analysis report. Default is '.taskmaster/reports/task-complexity-report.json' (or '..._tagname.json' if a tag is used).` (CLI: `-o, --output <file>`)
378:     *   `threshold`: `The minimum complexity score (1-10) that should trigger a recommendation to expand a task.` (CLI: `-t, --threshold <number>`)
379:     *   `research`: `Enable research role for more accurate complexity analysis. Requires appropriate API key.` (CLI: `-r, --research`)
380:     *   `tag`: `Specify which tag context to analyze. Defaults to the current active tag.` (CLI: `--tag <name>`)
381:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
382: *   **Usage:** Used before breaking down tasks to identify which ones need the most attention.
383: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
384: 
385: ### 23. View Complexity Report (`complexity_report`)
386: 
387: *   **MCP Tool:** `complexity_report`
388: *   **CLI Command:** `task-master complexity-report [options]`
389: *   **Description:** `Display the task complexity analysis report in a readable format.`
390: *   **Key Parameters/Options:**
391:     *   `tag`: `Specify which tag context to show the report for. Defaults to the current active tag.` (CLI: `--tag <name>`)
392:     *   `file`: `Path to the complexity report (default: '.taskmaster/reports/task-complexity-report.json').` (CLI: `-f, --file <file>`)
393: *   **Usage:** Review and understand the complexity analysis results after running analyze-complexity.
394: 
395: ---
396: 
397: ## File Management
398: 
399: ### 24. Generate Task Files (`generate`)
400: 
401: *   **MCP Tool:** `generate`
402: *   **CLI Command:** `task-master generate [options]`
403: *   **Description:** `Create or update individual Markdown files for each task based on your tasks.json.`
404: *   **Key Parameters/Options:**
405:     *   `output`: `The directory where Taskmaster should save the task files (default: in a 'tasks' directory).` (CLI: `-o, --output <directory>`)
406:     *   `tag`: `Specify which tag context to generate files for. Defaults to the current active tag.` (CLI: `--tag <name>`)
407:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
408: *   **Usage:** Run this after making changes to tasks.json to keep individual task files up to date. This command is now manual and no longer runs automatically.
409: 
410: ---
411: 
412: ## AI-Powered Research
413: 
414: ### 25. Research (`research`)
415: 
416: *   **MCP Tool:** `research`
417: *   **CLI Command:** `task-master research [options]`
418: *   **Description:** `Perform AI-powered research queries with project context to get fresh, up-to-date information beyond the AI's knowledge cutoff.`
419: *   **Key Parameters/Options:**
420:     *   `query`: `Required. Research query/prompt (e.g., "What are the latest best practices for React Query v5?").` (CLI: `[query]` positional or `-q, --query <text>`)
421:     *   `taskIds`: `Comma-separated list of task/subtask IDs from the current tag context (e.g., "15,16.2,17").` (CLI: `-i, --id <ids>`)
422:     *   `filePaths`: `Comma-separated list of file paths for context (e.g., "src/api.js,docs/readme.md").` (CLI: `-f, --files <paths>`)
423:     *   `customContext`: `Additional custom context text to include in the research.` (CLI: `-c, --context <text>`)
424:     *   `includeProjectTree`: `Include project file tree structure in context (default: false).` (CLI: `--tree`)
425:     *   `detailLevel`: `Detail level for the research response: 'low', 'medium', 'high' (default: medium).` (CLI: `--detail <level>`)
426:     *   `saveTo`: `Task or subtask ID (e.g., "15", "15.2") to automatically save the research conversation to.` (CLI: `--save-to <id>`)
427:     *   `saveFile`: `If true, saves the research conversation to a markdown file in '.taskmaster/docs/research/'.` (CLI: `--save-file`)
428:     *   `noFollowup`: `Disables the interactive follow-up question menu in the CLI.` (CLI: `--no-followup`)
429:     *   `tag`: `Specify which tag context to use for task-based context gathering. Defaults to the current active tag.` (CLI: `--tag <name>`)
430:     *   `projectRoot`: `The directory of the project. Must be an absolute path.` (CLI: Determined automatically)
431: *   **Usage:** **This is a POWERFUL tool that agents should use FREQUENTLY** to:
432:     *   Get fresh information beyond knowledge cutoff dates
433:     *   Research latest best practices, library updates, security patches
434:     *   Find implementation examples for specific technologies
435:     *   Validate approaches against current industry standards
436:     *   Get contextual advice based on project files and tasks
437: *   **When to Consider Using Research:**
438:     *   **Before implementing any task** - Research current best practices
439:     *   **When encountering new technologies** - Get up-to-date implementation guidance (libraries, apis, etc)
440:     *   **For security-related tasks** - Find latest security recommendations
441:     *   **When updating dependencies** - Research breaking changes and migration guides
442:     *   **For performance optimization** - Get current performance best practices
443:     *   **When debugging complex issues** - Research known solutions and workarounds
444: *   **Research + Action Pattern:**
445:     *   Use `research` to gather fresh information
446:     *   Use `update_subtask` to commit findings with timestamps
447:     *   Use `update_task` to incorporate research into task details
448:     *   Use `add_task` with research flag for informed task creation
449: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. The research provides FRESH data beyond the AI's training cutoff, making it invaluable for current best practices and recent developments.
450: 
451: ---
452: 
453: ## Tag Management
454: 
455: This new suite of commands allows you to manage different task contexts (tags).
456: 
457: ### 26. List Tags (`tags`)
458: 
459: *   **MCP Tool:** `list_tags`
460: *   **CLI Command:** `task-master tags [options]`
461: *   **Description:** `List all available tags with task counts, completion status, and other metadata.`
462: *   **Key Parameters/Options:**
463:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
464:     *   `--show-metadata`: `Include detailed metadata in the output (e.g., creation date, description).` (CLI: `--show-metadata`)
465: 
466: ### 27. Add Tag (`add_tag`)
467: 
468: *   **MCP Tool:** `add_tag`
469: *   **CLI Command:** `task-master add-tag <tagName> [options]`
470: *   **Description:** `Create a new, empty tag context, or copy tasks from another tag.`
471: *   **Key Parameters/Options:**
472:     *   `tagName`: `Name of the new tag to create (alphanumeric, hyphens, underscores).` (CLI: `<tagName>` positional)
473:     *   `--from-branch`: `Creates a tag with a name derived from the current git branch, ignoring the <tagName> argument.` (CLI: `--from-branch`)
474:     *   `--copy-from-current`: `Copy tasks from the currently active tag to the new tag.` (CLI: `--copy-from-current`)
475:     *   `--copy-from <tag>`: `Copy tasks from a specific source tag to the new tag.` (CLI: `--copy-from <tag>`)
476:     *   `--description <text>`: `Provide an optional description for the new tag.` (CLI: `-d, --description <text>`)
477:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
478: 
479: ### 28. Delete Tag (`delete_tag`)
480: 
481: *   **MCP Tool:** `delete_tag`
482: *   **CLI Command:** `task-master delete-tag <tagName> [options]`
483: *   **Description:** `Permanently delete a tag and all of its associated tasks.`
484: *   **Key Parameters/Options:**
485:     *   `tagName`: `Name of the tag to delete.` (CLI: `<tagName>` positional)
486:     *   `--yes`: `Skip the confirmation prompt.` (CLI: `-y, --yes`)
487:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
488: 
489: ### 29. Use Tag (`use_tag`)
490: 
491: *   **MCP Tool:** `use_tag`
492: *   **CLI Command:** `task-master use-tag <tagName>`
493: *   **Description:** `Switch your active task context to a different tag.`
494: *   **Key Parameters/Options:**
495:     *   `tagName`: `Name of the tag to switch to.` (CLI: `<tagName>` positional)
496:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
497: 
498: ### 30. Rename Tag (`rename_tag`)
499: 
500: *   **MCP Tool:** `rename_tag`
501: *   **CLI Command:** `task-master rename-tag <oldName> <newName>`
502: *   **Description:** `Rename an existing tag.`
503: *   **Key Parameters/Options:**
504:     *   `oldName`: `The current name of the tag.` (CLI: `<oldName>` positional)
505:     *   `newName`: `The new name for the tag.` (CLI: `<newName>` positional)
506:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
507: 
508: ### 31. Copy Tag (`copy_tag`)
509: 
510: *   **MCP Tool:** `copy_tag`
511: *   **CLI Command:** `task-master copy-tag <sourceName> <targetName> [options]`
512: *   **Description:** `Copy an entire tag context, including all its tasks and metadata, to a new tag.`
513: *   **Key Parameters/Options:**
514:     *   `sourceName`: `Name of the tag to copy from.` (CLI: `<sourceName>` positional)
515:     *   `targetName`: `Name of the new tag to create.` (CLI: `<targetName>` positional)
516:     *   `--description <text>`: `Optional description for the new tag.` (CLI: `-d, --description <text>`)
517: 
518: ---
519: 
520: ## Miscellaneous
521: 
522: ### 32. Sync Readme (`sync-readme`) -- experimental
523: 
524: *   **MCP Tool:** N/A
525: *   **CLI Command:** `task-master sync-readme [options]`
526: *   **Description:** `Exports your task list to your project's README.md file, useful for showcasing progress.`
527: *   **Key Parameters/Options:**
528:     *   `status`: `Filter tasks by status (e.g., 'pending', 'done').` (CLI: `-s, --status <status>`)
529:     *   `withSubtasks`: `Include subtasks in the export.` (CLI: `--with-subtasks`)
530:     *   `tag`: `Specify which tag context to export from. Defaults to the current active tag.` (CLI: `--tag <name>`)
531: 
532: ---
533: 
534: ## Environment Variables Configuration (Updated)
535: 
536: Taskmaster primarily uses the **`.taskmaster/config.json`** file (in project root) for configuration (models, parameters, logging level, etc.), managed via `task-master models --setup`.
537: 
538: Environment variables are used **only** for sensitive API keys related to AI providers and specific overrides like the Ollama base URL:
539: 
540: *   **API Keys (Required for corresponding provider):**
541:     *   `ANTHROPIC_API_KEY`
542:     *   `PERPLEXITY_API_KEY`
543:     *   `OPENAI_API_KEY`
544:     *   `GOOGLE_API_KEY`
545:     *   `MISTRAL_API_KEY`
546:     *   `AZURE_OPENAI_API_KEY` (Requires `AZURE_OPENAI_ENDPOINT` too)
547:     *   `OPENROUTER_API_KEY`
548:     *   `XAI_API_KEY`
549:     *   `OLLAMA_API_KEY` (Requires `OLLAMA_BASE_URL` too)
550: *   **Endpoints (Optional/Provider Specific inside .taskmaster/config.json):**
551:     *   `AZURE_OPENAI_ENDPOINT`
552:     *   `OLLAMA_BASE_URL` (Default: `http://localhost:11434/api`)
553: 
554: **Set API keys** in your **`.env`** file in the project root (for CLI use) or within the `env` section of your **`.vscode/mcp.json`** file (for MCP/VS Code integration). All other settings (model choice, max tokens, temperature, log level, custom endpoints) are managed in `.taskmaster/config.json` via `task-master models` command or `models` MCP tool.
555: 
556: ---
557: 
558: For details on how these commands fit into the development process, see the [dev_workflow.md](.github/instructions/dev_workflow.md).
</file>

<file path=".github/instructions/vscode_rules.md">
 1: ---
 2: description: Guidelines for creating and maintaining VS Code rules to ensure consistency and effectiveness.
 3: applyTo: ".github/instructions/*.md"
 4: alwaysApply: true
 5: ---
 6: 
 7: - **Required Rule Structure:**
 8:   ```markdown
 9:   ---
10:   description: Clear, one-line description of what the rule enforces
11:   globs: path/to/files/*.ext, other/path/**/*
12:   alwaysApply: boolean
13:   ---
14: 
15:   - **Main Points in Bold**
16:     - Sub-points with details
17:     - Examples and explanations
18:   ```
19: 
20: - **File References:**
21:   - Use `[filename](mdc:path/to/file)` ([filename](mdc:filename)) to reference files
22:   - Example: [prisma.md](.github/instructions/prisma.md) for rule references
23:   - Example: [schema.prisma](mdc:prisma/schema.prisma) for code references
24: 
25: - **Code Examples:**
26:   - Use language-specific code blocks
27:   ```typescript
28:   //  DO: Show good examples
29:   const goodExample = true;
30:   
31:   //  DON'T: Show anti-patterns
32:   const badExample = false;
33:   ```
34: 
35: - **Rule Content Guidelines:**
36:   - Start with high-level overview
37:   - Include specific, actionable requirements
38:   - Show examples of correct implementation
39:   - Reference existing code when possible
40:   - Keep rules DRY by referencing other rules
41: 
42: - **Rule Maintenance:**
43:   - Update rules when new patterns emerge
44:   - Add examples from actual codebase
45:   - Remove outdated patterns
46:   - Cross-reference related rules
47: 
48: - **Best Practices:**
49:   - Use bullet points for clarity
50:   - Keep descriptions concise
51:   - Include both DO and DON'T examples
52:   - Reference actual code over theoretical examples
53:   - Use consistent formatting across rules
</file>

<file path=".roo/rules/dev_workflow.md">
  1: ---
  2: description: Guide for using Taskmaster to manage task-driven development workflows
  3: globs: **/*
  4: alwaysApply: true
  5: ---
  6: 
  7: # Taskmaster Development Workflow
  8: 
  9: This guide outlines the standard process for using Taskmaster to manage software development projects. It is written as a set of instructions for you, the AI agent.
 10: 
 11: - **Your Default Stance**: For most projects, the user can work directly within the `master` task context. Your initial actions should operate on this default context unless a clear pattern for multi-context work emerges.
 12: - **Your Goal**: Your role is to elevate the user's workflow by intelligently introducing advanced features like **Tagged Task Lists** when you detect the appropriate context. Do not force tags on the user; suggest them as a helpful solution to a specific need.
 13: 
 14: ## The Basic Loop
 15: The fundamental development cycle you will facilitate is:
 16: 1.  **`list`**: Show the user what needs to be done.
 17: 2.  **`next`**: Help the user decide what to work on.
 18: 3.  **`show <id>`**: Provide details for a specific task.
 19: 4.  **`expand <id>`**: Break down a complex task into smaller, manageable subtasks.
 20: 5.  **Implement**: The user writes the code and tests.
 21: 6.  **`update-subtask`**: Log progress and findings on behalf of the user.
 22: 7.  **`set-status`**: Mark tasks and subtasks as `done` as work is completed.
 23: 8.  **Repeat**.
 24: 
 25: All your standard command executions should operate on the user's current task context, which defaults to `master`.
 26: 
 27: ---
 28: 
 29: ## Standard Development Workflow Process
 30: 
 31: ### Simple Workflow (Default Starting Point)
 32: 
 33: For new projects or when users are getting started, operate within the `master` tag context:
 34: 
 35: -   Start new projects by running `initialize_project` tool / `task-master init` or `parse_prd` / `task-master parse-prd --input='<prd-file.txt>'` (see @`taskmaster.md`) to generate initial tasks.json with tagged structure
 36: -   Configure rule sets during initialization with `--rules` flag (e.g., `task-master init --rules roo,windsurf`) or manage them later with `task-master rules add/remove` commands  
 37: -   Begin coding sessions with `get_tasks` / `task-master list` (see @`taskmaster.md`) to see current tasks, status, and IDs
 38: -   Determine the next task to work on using `next_task` / `task-master next` (see @`taskmaster.md`)
 39: -   Analyze task complexity with `analyze_project_complexity` / `task-master analyze-complexity --research` (see @`taskmaster.md`) before breaking down tasks
 40: -   Review complexity report using `complexity_report` / `task-master complexity-report` (see @`taskmaster.md`)
 41: -   Select tasks based on dependencies (all marked 'done'), priority level, and ID order
 42: -   View specific task details using `get_task` / `task-master show <id>` (see @`taskmaster.md`) to understand implementation requirements
 43: -   Break down complex tasks using `expand_task` / `task-master expand --id=<id> --force --research` (see @`taskmaster.md`) with appropriate flags like `--force` (to replace existing subtasks) and `--research`
 44: -   Implement code following task details, dependencies, and project standards
 45: -   Mark completed tasks with `set_task_status` / `task-master set-status --id=<id> --status=done` (see @`taskmaster.md`)
 46: -   Update dependent tasks when implementation differs from original plan using `update` / `task-master update --from=<id> --prompt="..."` or `update_task` / `task-master update-task --id=<id> --prompt="..."` (see @`taskmaster.md`)
 47: 
 48: ---
 49: 
 50: ## Leveling Up: Agent-Led Multi-Context Workflows
 51: 
 52: While the basic workflow is powerful, your primary opportunity to add value is by identifying when to introduce **Tagged Task Lists**. These patterns are your tools for creating a more organized and efficient development environment for the user, especially if you detect agentic or parallel development happening across the same session.
 53: 
 54: **Critical Principle**: Most users should never see a difference in their experience. Only introduce advanced workflows when you detect clear indicators that the project has evolved beyond simple task management.
 55: 
 56: ### When to Introduce Tags: Your Decision Patterns
 57: 
 58: Here are the patterns to look for. When you detect one, you should propose the corresponding workflow to the user.
 59: 
 60: #### Pattern 1: Simple Git Feature Branching
 61: This is the most common and direct use case for tags.
 62: 
 63: - **Trigger**: The user creates a new git branch (e.g., `git checkout -b feature/user-auth`).
 64: - **Your Action**: Propose creating a new tag that mirrors the branch name to isolate the feature's tasks from `master`.
 65: - **Your Suggested Prompt**: *"I see you've created a new branch named 'feature/user-auth'. To keep all related tasks neatly organized and separate from your main list, I can create a corresponding task tag for you. This helps prevent merge conflicts in your `tasks.json` file later. Shall I create the 'feature-user-auth' tag?"*
 66: - **Tool to Use**: `task-master add-tag --from-branch`
 67: 
 68: #### Pattern 2: Team Collaboration
 69: - **Trigger**: The user mentions working with teammates (e.g., "My teammate Alice is handling the database schema," or "I need to review Bob's work on the API.").
 70: - **Your Action**: Suggest creating a separate tag for the user's work to prevent conflicts with shared master context.
 71: - **Your Suggested Prompt**: *"Since you're working with Alice, I can create a separate task context for your work to avoid conflicts. This way, Alice can continue working with the master list while you have your own isolated context. When you're ready to merge your work, we can coordinate the tasks back to master. Shall I create a tag for your current work?"*
 72: - **Tool to Use**: `task-master add-tag my-work --copy-from-current --description="My tasks while collaborating with Alice"`
 73: 
 74: #### Pattern 3: Experiments or Risky Refactors
 75: - **Trigger**: The user wants to try something that might not be kept (e.g., "I want to experiment with switching our state management library," or "Let's refactor the old API module, but I want to keep the current tasks as a reference.").
 76: - **Your Action**: Propose creating a sandboxed tag for the experimental work.
 77: - **Your Suggested Prompt**: *"This sounds like a great experiment. To keep these new tasks separate from our main plan, I can create a temporary 'experiment-zustand' tag for this work. If we decide not to proceed, we can simply delete the tag without affecting the main task list. Sound good?"*
 78: - **Tool to Use**: `task-master add-tag experiment-zustand --description="Exploring Zustand migration"`
 79: 
 80: #### Pattern 4: Large Feature Initiatives (PRD-Driven)
 81: This is a more structured approach for significant new features or epics.
 82: 
 83: - **Trigger**: The user describes a large, multi-step feature that would benefit from a formal plan.
 84: - **Your Action**: Propose a comprehensive, PRD-driven workflow.
 85: - **Your Suggested Prompt**: *"This sounds like a significant new feature. To manage this effectively, I suggest we create a dedicated task context for it. Here's the plan: I'll create a new tag called 'feature-xyz', then we can draft a Product Requirements Document (PRD) together to scope the work. Once the PRD is ready, I'll automatically generate all the necessary tasks within that new tag. How does that sound?"*
 86: - **Your Implementation Flow**:
 87:     1.  **Create an empty tag**: `task-master add-tag feature-xyz --description "Tasks for the new XYZ feature"`. You can also start by creating a git branch if applicable, and then create the tag from that branch.
 88:     2.  **Collaborate & Create PRD**: Work with the user to create a detailed PRD file (e.g., `.taskmaster/docs/feature-xyz-prd.txt`).
 89:     3.  **Parse PRD into the new tag**: `task-master parse-prd .taskmaster/docs/feature-xyz-prd.txt --tag feature-xyz`
 90:     4.  **Prepare the new task list**: Follow up by suggesting `analyze-complexity` and `expand-all` for the newly created tasks within the `feature-xyz` tag.
 91: 
 92: #### Pattern 5: Version-Based Development
 93: Tailor your approach based on the project maturity indicated by tag names.
 94: 
 95: - **Prototype/MVP Tags** (`prototype`, `mvp`, `poc`, `v0.x`):
 96:   - **Your Approach**: Focus on speed and functionality over perfection
 97:   - **Task Generation**: Create tasks that emphasize "get it working" over "get it perfect"
 98:   - **Complexity Level**: Lower complexity, fewer subtasks, more direct implementation paths
 99:   - **Research Prompts**: Include context like "This is a prototype - prioritize speed and basic functionality over optimization"
100:   - **Example Prompt Addition**: *"Since this is for the MVP, I'll focus on tasks that get core functionality working quickly rather than over-engineering."*
101: 
102: - **Production/Mature Tags** (`v1.0+`, `production`, `stable`):
103:   - **Your Approach**: Emphasize robustness, testing, and maintainability
104:   - **Task Generation**: Include comprehensive error handling, testing, documentation, and optimization
105:   - **Complexity Level**: Higher complexity, more detailed subtasks, thorough implementation paths
106:   - **Research Prompts**: Include context like "This is for production - prioritize reliability, performance, and maintainability"
107:   - **Example Prompt Addition**: *"Since this is for production, I'll ensure tasks include proper error handling, testing, and documentation."*
108: 
109: ### Advanced Workflow (Tag-Based & PRD-Driven)
110: 
111: **When to Transition**: Recognize when the project has evolved (or has initiated a project which existing code) beyond simple task management. Look for these indicators:
112: - User mentions teammates or collaboration needs
113: - Project has grown to 15+ tasks with mixed priorities
114: - User creates feature branches or mentions major initiatives
115: - User initializes Taskmaster on an existing, complex codebase
116: - User describes large features that would benefit from dedicated planning
117: 
118: **Your Role in Transition**: Guide the user to a more sophisticated workflow that leverages tags for organization and PRDs for comprehensive planning.
119: 
120: #### Master List Strategy (High-Value Focus)
121: Once you transition to tag-based workflows, the `master` tag should ideally contain only:
122: - **High-level deliverables** that provide significant business value
123: - **Major milestones** and epic-level features
124: - **Critical infrastructure** work that affects the entire project
125: - **Release-blocking** items
126: 
127: **What NOT to put in master**:
128: - Detailed implementation subtasks (these go in feature-specific tags' parent tasks)
129: - Refactoring work (create dedicated tags like `refactor-auth`)
130: - Experimental features (use `experiment-*` tags)
131: - Team member-specific tasks (use person-specific tags)
132: 
133: #### PRD-Driven Feature Development
134: 
135: **For New Major Features**:
136: 1. **Identify the Initiative**: When user describes a significant feature
137: 2. **Create Dedicated Tag**: `add_tag feature-[name] --description="[Feature description]"`
138: 3. **Collaborative PRD Creation**: Work with user to create comprehensive PRD in `.taskmaster/docs/feature-[name]-prd.txt`
139: 4. **Parse & Prepare**: 
140:    - `parse_prd .taskmaster/docs/feature-[name]-prd.txt --tag=feature-[name]`
141:    - `analyze_project_complexity --tag=feature-[name] --research`
142:    - `expand_all --tag=feature-[name] --research`
143: 5. **Add Master Reference**: Create a high-level task in `master` that references the feature tag
144: 
145: **For Existing Codebase Analysis**:
146: When users initialize Taskmaster on existing projects:
147: 1. **Codebase Discovery**: Use your native tools for producing deep context about the code base. You may use `research` tool with `--tree` and `--files` to collect up to date information using the existing architecture as context.
148: 2. **Collaborative Assessment**: Work with user to identify improvement areas, technical debt, or new features
149: 3. **Strategic PRD Creation**: Co-author PRDs that include:
150:    - Current state analysis (based on your codebase research)
151:    - Proposed improvements or new features
152:    - Implementation strategy considering existing code
153: 4. **Tag-Based Organization**: Parse PRDs into appropriate tags (`refactor-api`, `feature-dashboard`, `tech-debt`, etc.)
154: 5. **Master List Curation**: Keep only the most valuable initiatives in master
155: 
156: The parse-prd's `--append` flag enables the user to parse multple PRDs within tags or across tags. PRDs should be focused and the number of tasks they are parsed into should be strategically chosen relative to the PRD's complexity and level of detail.
157: 
158: ### Workflow Transition Examples
159: 
160: **Example 1: Simple  Team-Based**
161: ```
162: User: "Alice is going to help with the API work"
163: Your Response: "Great! To avoid conflicts, I'll create a separate task context for your work. Alice can continue with the master list while you work in your own context. When you're ready to merge, we can coordinate the tasks back together."
164: Action: add_tag my-api-work --copy-from-current --description="My API tasks while collaborating with Alice"
165: ```
166: 
167: **Example 2: Simple  PRD-Driven**
168: ```
169: User: "I want to add a complete user dashboard with analytics, user management, and reporting"
170: Your Response: "This sounds like a major feature that would benefit from detailed planning. Let me create a dedicated context for this work and we can draft a PRD together to ensure we capture all requirements."
171: Actions: 
172: 1. add_tag feature-dashboard --description="User dashboard with analytics and management"
173: 2. Collaborate on PRD creation
174: 3. parse_prd dashboard-prd.txt --tag=feature-dashboard
175: 4. Add high-level "User Dashboard" task to master
176: ```
177: 
178: **Example 3: Existing Project  Strategic Planning**
179: ```
180: User: "I just initialized Taskmaster on my existing React app. It's getting messy and I want to improve it."
181: Your Response: "Let me research your codebase to understand the current architecture, then we can create a strategic plan for improvements."
182: Actions:
183: 1. research "Current React app architecture and improvement opportunities" --tree --files=src/
184: 2. Collaborate on improvement PRD based on findings
185: 3. Create tags for different improvement areas (refactor-components, improve-state-management, etc.)
186: 4. Keep only major improvement initiatives in master
187: ```
188: 
189: ---
190: 
191: ## Primary Interaction: MCP Server vs. CLI
192: 
193: Taskmaster offers two primary ways to interact:
194: 
195: 1.  **MCP Server (Recommended for Integrated Tools)**:
196:     - For AI agents and integrated development environments (like Roo Code), interacting via the **MCP server is the preferred method**.
197:     - The MCP server exposes Taskmaster functionality through a set of tools (e.g., `get_tasks`, `add_subtask`).
198:     - This method offers better performance, structured data exchange, and richer error handling compared to CLI parsing.
199:     - Refer to @`mcp.md` for details on the MCP architecture and available tools.
200:     - A comprehensive list and description of MCP tools and their corresponding CLI commands can be found in @`taskmaster.md`.
201:     - **Restart the MCP server** if core logic in `scripts/modules` or MCP tool/direct function definitions change.
202:     - **Note**: MCP tools fully support tagged task lists with complete tag management capabilities.
203: 
204: 2.  **`task-master` CLI (For Users & Fallback)**:
205:     - The global `task-master` command provides a user-friendly interface for direct terminal interaction.
206:     - It can also serve as a fallback if the MCP server is inaccessible or a specific function isn't exposed via MCP.
207:     - Install globally with `npm install -g task-master-ai` or use locally via `npx task-master-ai ...`.
208:     - The CLI commands often mirror the MCP tools (e.g., `task-master list` corresponds to `get_tasks`).
209:     - Refer to @`taskmaster.md` for a detailed command reference.
210:     - **Tagged Task Lists**: CLI fully supports the new tagged system with seamless migration.
211: 
212: ## How the Tag System Works (For Your Reference)
213: 
214: - **Data Structure**: Tasks are organized into separate contexts (tags) like "master", "feature-branch", or "v2.0".
215: - **Silent Migration**: Existing projects automatically migrate to use a "master" tag with zero disruption.
216: - **Context Isolation**: Tasks in different tags are completely separate. Changes in one tag do not affect any other tag.
217: - **Manual Control**: The user is always in control. There is no automatic switching. You facilitate switching by using `use-tag <name>`.
218: - **Full CLI & MCP Support**: All tag management commands are available through both the CLI and MCP tools for you to use. Refer to @`taskmaster.md` for a full command list.
219: 
220: ---
221: 
222: ## Task Complexity Analysis
223: 
224: -   Run `analyze_project_complexity` / `task-master analyze-complexity --research` (see @`taskmaster.md`) for comprehensive analysis
225: -   Review complexity report via `complexity_report` / `task-master complexity-report` (see @`taskmaster.md`) for a formatted, readable version.
226: -   Focus on tasks with highest complexity scores (8-10) for detailed breakdown
227: -   Use analysis results to determine appropriate subtask allocation
228: -   Note that reports are automatically used by the `expand_task` tool/command
229: 
230: ## Task Breakdown Process
231: 
232: -   Use `expand_task` / `task-master expand --id=<id>`. It automatically uses the complexity report if found, otherwise generates default number of subtasks.
233: -   Use `--num=<number>` to specify an explicit number of subtasks, overriding defaults or complexity report recommendations.
234: -   Add `--research` flag to leverage Perplexity AI for research-backed expansion.
235: -   Add `--force` flag to clear existing subtasks before generating new ones (default is to append).
236: -   Use `--prompt="<context>"` to provide additional context when needed.
237: -   Review and adjust generated subtasks as necessary.
238: -   Use `expand_all` tool or `task-master expand --all` to expand multiple pending tasks at once, respecting flags like `--force` and `--research`.
239: -   If subtasks need complete replacement (regardless of the `--force` flag on `expand`), clear them first with `clear_subtasks` / `task-master clear-subtasks --id=<id>`.
240: 
241: ## Implementation Drift Handling
242: 
243: -   When implementation differs significantly from planned approach
244: -   When future tasks need modification due to current implementation choices
245: -   When new dependencies or requirements emerge
246: -   Use `update` / `task-master update --from=<futureTaskId> --prompt='<explanation>\nUpdate context...' --research` to update multiple future tasks.
247: -   Use `update_task` / `task-master update-task --id=<taskId> --prompt='<explanation>\nUpdate context...' --research` to update a single specific task.
248: 
249: ## Task Status Management
250: 
251: -   Use 'pending' for tasks ready to be worked on
252: -   Use 'done' for completed and verified tasks
253: -   Use 'deferred' for postponed tasks
254: -   Add custom status values as needed for project-specific workflows
255: 
256: ## Task Structure Fields
257: 
258: - **id**: Unique identifier for the task (Example: `1`, `1.1`)
259: - **title**: Brief, descriptive title (Example: `"Initialize Repo"`)
260: - **description**: Concise summary of what the task involves (Example: `"Create a new repository, set up initial structure."`)
261: - **status**: Current state of the task (Example: `"pending"`, `"done"`, `"deferred"`)
262: - **dependencies**: IDs of prerequisite tasks (Example: `[1, 2.1]`)
263:     - Dependencies are displayed with status indicators ( for completed,  for pending)
264:     - This helps quickly identify which prerequisite tasks are blocking work
265: - **priority**: Importance level (Example: `"high"`, `"medium"`, `"low"`)
266: - **details**: In-depth implementation instructions (Example: `"Use GitHub client ID/secret, handle callback, set session token."`) 
267: - **testStrategy**: Verification approach (Example: `"Deploy and call endpoint to confirm 'Hello World' response."`) 
268: - **subtasks**: List of smaller, more specific tasks (Example: `[{"id": 1, "title": "Configure OAuth", ...}]`) 
269: - Refer to task structure details (previously linked to `tasks.md`).
270: 
271: ## Configuration Management (Updated)
272: 
273: Taskmaster configuration is managed through two main mechanisms:
274: 
275: 1.  **`.taskmaster/config.json` File (Primary):**
276:     *   Located in the project root directory.
277:     *   Stores most configuration settings: AI model selections (main, research, fallback), parameters (max tokens, temperature), logging level, default subtasks/priority, project name, etc.
278:     *   **Tagged System Settings**: Includes `global.defaultTag` (defaults to "master") and `tags` section for tag management configuration.
279:     *   **Managed via `task-master models --setup` command.** Do not edit manually unless you know what you are doing.
280:     *   **View/Set specific models via `task-master models` command or `models` MCP tool.**
281:     *   Created automatically when you run `task-master models --setup` for the first time or during tagged system migration.
282: 
283: 2.  **Environment Variables (`.env` / `mcp.json`):**
284:     *   Used **only** for sensitive API keys and specific endpoint URLs.
285:     *   Place API keys (one per provider) in a `.env` file in the project root for CLI usage.
286:     *   For MCP/Roo Code integration, configure these keys in the `env` section of `.roo/mcp.json`.
287:     *   Available keys/variables: See `assets/env.example` or the Configuration section in the command reference (previously linked to `taskmaster.md`).
288: 
289: 3.  **`.taskmaster/state.json` File (Tagged System State):**
290:     *   Tracks current tag context and migration status.
291:     *   Automatically created during tagged system migration.
292:     *   Contains: `currentTag`, `lastSwitched`, `migrationNoticeShown`.
293: 
294: **Important:** Non-API key settings (like model selections, `MAX_TOKENS`, `TASKMASTER_LOG_LEVEL`) are **no longer configured via environment variables**. Use the `task-master models` command (or `--setup` for interactive configuration) or the `models` MCP tool.
295: **If AI commands FAIL in MCP** verify that the API key for the selected provider is present in the `env` section of `.roo/mcp.json`.
296: **If AI commands FAIL in CLI** verify that the API key for the selected provider is present in the `.env` file in the root of the project.
297: 
298: ## Rules Management
299: 
300: Taskmaster supports multiple AI coding assistant rule sets that can be configured during project initialization or managed afterward:
301: 
302: - **Available Profiles**: Claude Code, Cline, Codex, Roo Code, Roo Code, Trae, Windsurf (claude, cline, codex, roo, roo, trae, windsurf)
303: - **During Initialization**: Use `task-master init --rules roo,windsurf` to specify which rule sets to include
304: - **After Initialization**: Use `task-master rules add <profiles>` or `task-master rules remove <profiles>` to manage rule sets
305: - **Interactive Setup**: Use `task-master rules setup` to launch an interactive prompt for selecting rule profiles
306: - **Default Behavior**: If no `--rules` flag is specified during initialization, all available rule profiles are included
307: - **Rule Structure**: Each profile creates its own directory (e.g., `.roo/rules`, `.roo/rules`) with appropriate configuration files
308: 
309: ## Determining the Next Task
310: 
311: - Run `next_task` / `task-master next` to show the next task to work on.
312: - The command identifies tasks with all dependencies satisfied
313: - Tasks are prioritized by priority level, dependency count, and ID
314: - The command shows comprehensive task information including:
315:     - Basic task details and description
316:     - Implementation details
317:     - Subtasks (if they exist)
318:     - Contextual suggested actions
319: - Recommended before starting any new development work
320: - Respects your project's dependency structure
321: - Ensures tasks are completed in the appropriate sequence
322: - Provides ready-to-use commands for common task actions
323: 
324: ## Viewing Specific Task Details
325: 
326: - Run `get_task` / `task-master show <id>` to view a specific task.
327: - Use dot notation for subtasks: `task-master show 1.2` (shows subtask 2 of task 1)
328: - Displays comprehensive information similar to the next command, but for a specific task
329: - For parent tasks, shows all subtasks and their current status
330: - For subtasks, shows parent task information and relationship
331: - Provides contextual suggested actions appropriate for the specific task
332: - Useful for examining task details before implementation or checking status
333: 
334: ## Managing Task Dependencies
335: 
336: - Use `add_dependency` / `task-master add-dependency --id=<id> --depends-on=<id>` to add a dependency.
337: - Use `remove_dependency` / `task-master remove-dependency --id=<id> --depends-on=<id>` to remove a dependency.
338: - The system prevents circular dependencies and duplicate dependency entries
339: - Dependencies are checked for existence before being added or removed
340: - Task files are automatically regenerated after dependency changes
341: - Dependencies are visualized with status indicators in task listings and files
342: 
343: ## Task Reorganization
344: 
345: - Use `move_task` / `task-master move --from=<id> --to=<id>` to move tasks or subtasks within the hierarchy
346: - This command supports several use cases:
347:   - Moving a standalone task to become a subtask (e.g., `--from=5 --to=7`)
348:   - Moving a subtask to become a standalone task (e.g., `--from=5.2 --to=7`) 
349:   - Moving a subtask to a different parent (e.g., `--from=5.2 --to=7.3`)
350:   - Reordering subtasks within the same parent (e.g., `--from=5.2 --to=5.4`)
351:   - Moving a task to a new, non-existent ID position (e.g., `--from=5 --to=25`)
352:   - Moving multiple tasks at once using comma-separated IDs (e.g., `--from=10,11,12 --to=16,17,18`)
353: - The system includes validation to prevent data loss:
354:   - Allows moving to non-existent IDs by creating placeholder tasks
355:   - Prevents moving to existing task IDs that have content (to avoid overwriting)
356:   - Validates source tasks exist before attempting to move them
357: - The system maintains proper parent-child relationships and dependency integrity
358: - Task files are automatically regenerated after the move operation
359: - This provides greater flexibility in organizing and refining your task structure as project understanding evolves
360: - This is especially useful when dealing with potential merge conflicts arising from teams creating tasks on separate branches. Solve these conflicts very easily by moving your tasks and keeping theirs.
361: 
362: ## Iterative Subtask Implementation
363: 
364: Once a task has been broken down into subtasks using `expand_task` or similar methods, follow this iterative process for implementation:
365: 
366: 1.  **Understand the Goal (Preparation):**
367:     *   Use `get_task` / `task-master show <subtaskId>` (see @`taskmaster.md`) to thoroughly understand the specific goals and requirements of the subtask.
368: 
369: 2.  **Initial Exploration & Planning (Iteration 1):**
370:     *   This is the first attempt at creating a concrete implementation plan.
371:     *   Explore the codebase to identify the precise files, functions, and even specific lines of code that will need modification.
372:     *   Determine the intended code changes (diffs) and their locations.
373:     *   Gather *all* relevant details from this exploration phase.
374: 
375: 3.  **Log the Plan:**
376:     *   Run `update_subtask` / `task-master update-subtask --id=<subtaskId> --prompt='<detailed plan>'`.
377:     *   Provide the *complete and detailed* findings from the exploration phase in the prompt. Include file paths, line numbers, proposed diffs, reasoning, and any potential challenges identified. Do not omit details. The goal is to create a rich, timestamped log within the subtask's `details`.
378: 
379: 4.  **Verify the Plan:**
380:     *   Run `get_task` / `task-master show <subtaskId>` again to confirm that the detailed implementation plan has been successfully appended to the subtask's details.
381: 
382: 5.  **Begin Implementation:**
383:     *   Set the subtask status using `set_task_status` / `task-master set-status --id=<subtaskId> --status=in-progress`.
384:     *   Start coding based on the logged plan.
385: 
386: 6.  **Refine and Log Progress (Iteration 2+):**
387:     *   As implementation progresses, you will encounter challenges, discover nuances, or confirm successful approaches.
388:     *   **Before appending new information**: Briefly review the *existing* details logged in the subtask (using `get_task` or recalling from context) to ensure the update adds fresh insights and avoids redundancy.
389:     *   **Regularly** use `update_subtask` / `task-master update-subtask --id=<subtaskId> --prompt='<update details>\n- What worked...\n- What didn't work...'` to append new findings.
390:     *   **Crucially, log:**
391:         *   What worked ("fundamental truths" discovered).
392:         *   What didn't work and why (to avoid repeating mistakes).
393:         *   Specific code snippets or configurations that were successful.
394:         *   Decisions made, especially if confirmed with user input.
395:         *   Any deviations from the initial plan and the reasoning.
396:     *   The objective is to continuously enrich the subtask's details, creating a log of the implementation journey that helps the AI (and human developers) learn, adapt, and avoid repeating errors.
397: 
398: 7.  **Review & Update Rules (Post-Implementation):**
399:     *   Once the implementation for the subtask is functionally complete, review all code changes and the relevant chat history.
400:     *   Identify any new or modified code patterns, conventions, or best practices established during the implementation.
401:     *   Create new or update existing rules following internal guidelines (previously linked to `cursor_rules.md` and `self_improve.md`).
402: 
403: 8.  **Mark Task Complete:**
404:     *   After verifying the implementation and updating any necessary rules, mark the subtask as completed: `set_task_status` / `task-master set-status --id=<subtaskId> --status=done`.
405: 
406: 9.  **Commit Changes (If using Git):**
407:     *   Stage the relevant code changes and any updated/new rule files (`git add .`).
408:     *   Craft a comprehensive Git commit message summarizing the work done for the subtask, including both code implementation and any rule adjustments.
409:     *   Execute the commit command directly in the terminal (e.g., `git commit -m 'feat(module): Implement feature X for subtask <subtaskId>\n\n- Details about changes...\n- Updated rule Y for pattern Z'`).
410:     *   Consider if a Changeset is needed according to internal versioning guidelines (previously linked to `changeset.md`). If so, run `npm run changeset`, stage the generated file, and amend the commit or create a new one.
411: 
412: 10. **Proceed to Next Subtask:**
413:     *   Identify the next subtask (e.g., using `next_task` / `task-master next`).
414: 
415: ## Code Analysis & Refactoring Techniques
416: 
417: - **Top-Level Function Search**:
418:     - Useful for understanding module structure or planning refactors.
419:     - Use grep/ripgrep to find exported functions/constants:
420:       `rg "export (async function|function|const) \w+"` or similar patterns.
421:     - Can help compare functions between files during migrations or identify potential naming conflicts.
422: 
423: ---
424: *This workflow provides a general guideline. Adapt it based on your specific project needs and team practices.*
</file>

<file path=".roo/rules/roo_rules.md">
 1: ---
 2: description: Guidelines for creating and maintaining Roo Code rules to ensure consistency and effectiveness.
 3: globs: .roo/rules/*.md
 4: alwaysApply: true
 5: ---
 6: 
 7: - **Required Rule Structure:**
 8:   ```markdown
 9:   ---
10:   description: Clear, one-line description of what the rule enforces
11:   globs: path/to/files/*.ext, other/path/**/*
12:   alwaysApply: boolean
13:   ---
14: 
15:   - **Main Points in Bold**
16:     - Sub-points with details
17:     - Examples and explanations
18:   ```
19: 
20: - **File References:**
21:   - Use `[filename](mdc:path/to/file)` ([filename](mdc:filename)) to reference files
22:   - Example: [prisma.md](.roo/rules/prisma.md) for rule references
23:   - Example: [schema.prisma](mdc:prisma/schema.prisma) for code references
24: 
25: - **Code Examples:**
26:   - Use language-specific code blocks
27:   ```typescript
28:   //  DO: Show good examples
29:   const goodExample = true;
30:   
31:   //  DON'T: Show anti-patterns
32:   const badExample = false;
33:   ```
34: 
35: - **Rule Content Guidelines:**
36:   - Start with high-level overview
37:   - Include specific, actionable requirements
38:   - Show examples of correct implementation
39:   - Reference existing code when possible
40:   - Keep rules DRY by referencing other rules
41: 
42: - **Rule Maintenance:**
43:   - Update rules when new patterns emerge
44:   - Add examples from actual codebase
45:   - Remove outdated patterns
46:   - Cross-reference related rules
47: 
48: - **Best Practices:**
49:   - Use bullet points for clarity
50:   - Keep descriptions concise
51:   - Include both DO and DON'T examples
52:   - Reference actual code over theoretical examples
53:   - Use consistent formatting across rules
</file>

<file path=".roo/rules/self_improve.md">
 1: ---
 2: description: Guidelines for continuously improving Roo Code rules based on emerging code patterns and best practices.
 3: globs: **/*
 4: alwaysApply: true
 5: ---
 6: 
 7: - **Rule Improvement Triggers:**
 8:   - New code patterns not covered by existing rules
 9:   - Repeated similar implementations across files
10:   - Common error patterns that could be prevented
11:   - New libraries or tools being used consistently
12:   - Emerging best practices in the codebase
13: 
14: - **Analysis Process:**
15:   - Compare new code with existing rules
16:   - Identify patterns that should be standardized
17:   - Look for references to external documentation
18:   - Check for consistent error handling patterns
19:   - Monitor test patterns and coverage
20: 
21: - **Rule Updates:**
22:   - **Add New Rules When:**
23:     - A new technology/pattern is used in 3+ files
24:     - Common bugs could be prevented by a rule
25:     - Code reviews repeatedly mention the same feedback
26:     - New security or performance patterns emerge
27: 
28:   - **Modify Existing Rules When:**
29:     - Better examples exist in the codebase
30:     - Additional edge cases are discovered
31:     - Related rules have been updated
32:     - Implementation details have changed
33: 
34: - **Example Pattern Recognition:**
35:   ```typescript
36:   // If you see repeated patterns like:
37:   const data = await prisma.user.findMany({
38:     select: { id: true, email: true },
39:     where: { status: 'ACTIVE' }
40:   });
41:   
42:   // Consider adding to [prisma.md](.roo/rules/prisma.md):
43:   // - Standard select fields
44:   // - Common where conditions
45:   // - Performance optimization patterns
46:   ```
47: 
48: - **Rule Quality Checks:**
49:   - Rules should be actionable and specific
50:   - Examples should come from actual code
51:   - References should be up to date
52:   - Patterns should be consistently enforced
53: 
54: - **Continuous Improvement:**
55:   - Monitor code review comments
56:   - Track common development questions
57:   - Update rules after major refactors
58:   - Add links to relevant documentation
59:   - Cross-reference related rules
60: 
61: - **Rule Deprecation:**
62:   - Mark outdated patterns as deprecated
63:   - Remove rules that no longer apply
64:   - Update references to deprecated rules
65:   - Document migration paths for old patterns
66: 
67: - **Documentation Updates:**
68:   - Keep examples synchronized with code
69:   - Update references to external docs
70:   - Maintain links between related rules
71:   - Document breaking changes
72: Follow [roo_rules.md](.roo/rules/roo_rules.md) for proper rule formatting and structure.
</file>

<file path=".roo/rules/taskmaster.md">
  1: ---
  2: description: Comprehensive reference for Taskmaster MCP tools and CLI commands.
  3: globs: **/*
  4: alwaysApply: true
  5: ---
  6: 
  7: # Taskmaster Tool & Command Reference
  8: 
  9: This document provides a detailed reference for interacting with Taskmaster, covering both the recommended MCP tools, suitable for integrations like Roo Code, and the corresponding `task-master` CLI commands, designed for direct user interaction or fallback.
 10: 
 11: **Note:** For interacting with Taskmaster programmatically or via integrated tools, using the **MCP tools is strongly recommended** due to better performance, structured data, and error handling. The CLI commands serve as a user-friendly alternative and fallback. 
 12: 
 13: **Important:** Several MCP tools involve AI processing... The AI-powered tools include `parse_prd`, `analyze_project_complexity`, `update_subtask`, `update_task`, `update`, `expand_all`, `expand_task`, and `add_task`.
 14: 
 15: ** Tagged Task Lists System:** Task Master now supports **tagged task lists** for multi-context task management. This allows you to maintain separate, isolated lists of tasks for different features, branches, or experiments. Existing projects are seamlessly migrated to use a default "master" tag. Most commands now support a `--tag <name>` flag to specify which context to operate on. If omitted, commands use the currently active tag.
 16: 
 17: ---
 18: 
 19: ## Initialization & Setup
 20: 
 21: ### 1. Initialize Project (`init`)
 22: 
 23: *   **MCP Tool:** `initialize_project`
 24: *   **CLI Command:** `task-master init [options]`
 25: *   **Description:** `Set up the basic Taskmaster file structure and configuration in the current directory for a new project.`
 26: *   **Key CLI Options:**
 27:     *   `--name <name>`: `Set the name for your project in Taskmaster's configuration.`
 28:     *   `--description <text>`: `Provide a brief description for your project.`
 29:     *   `--version <version>`: `Set the initial version for your project, e.g., '0.1.0'.`
 30:     *   `-y, --yes`: `Initialize Taskmaster quickly using default settings without interactive prompts.`
 31: *   **Usage:** Run this once at the beginning of a new project.
 32: *   **MCP Variant Description:** `Set up the basic Taskmaster file structure and configuration in the current directory for a new project by running the 'task-master init' command.`
 33: *   **Key MCP Parameters/Options:**
 34:     *   `projectName`: `Set the name for your project.` (CLI: `--name <name>`)
 35:     *   `projectDescription`: `Provide a brief description for your project.` (CLI: `--description <text>`)
 36:     *   `projectVersion`: `Set the initial version for your project, e.g., '0.1.0'.` (CLI: `--version <version>`)
 37:     *   `authorName`: `Author name.` (CLI: `--author <author>`)
 38:     *   `skipInstall`: `Skip installing dependencies. Default is false.` (CLI: `--skip-install`)
 39:     *   `addAliases`: `Add shell aliases tm and taskmaster. Default is false.` (CLI: `--aliases`)
 40:     *   `yes`: `Skip prompts and use defaults/provided arguments. Default is false.` (CLI: `-y, --yes`)
 41: *   **Usage:** Run this once at the beginning of a new project, typically via an integrated tool like Roo Code. Operates on the current working directory of the MCP server. 
 42: *   **Important:** Once complete, you *MUST* parse a prd in order to generate tasks. There will be no tasks files until then. The next step after initializing should be to create a PRD using the example PRD in .taskmaster/templates/example_prd.txt. 
 43: *   **Tagging:** Use the `--tag` option to parse the PRD into a specific, non-default tag context. If the tag doesn't exist, it will be created automatically. Example: `task-master parse-prd spec.txt --tag=new-feature`.
 44: 
 45: ### 2. Parse PRD (`parse_prd`)
 46: 
 47: *   **MCP Tool:** `parse_prd`
 48: *   **CLI Command:** `task-master parse-prd [file] [options]`
 49: *   **Description:** `Parse a Product Requirements Document, PRD, or text file with Taskmaster to automatically generate an initial set of tasks in tasks.json.`
 50: *   **Key Parameters/Options:**
 51:     *   `input`: `Path to your PRD or requirements text file that Taskmaster should parse for tasks.` (CLI: `[file]` positional or `-i, --input <file>`)
 52:     *   `output`: `Specify where Taskmaster should save the generated 'tasks.json' file. Defaults to '.taskmaster/tasks/tasks.json'.` (CLI: `-o, --output <file>`)
 53:     *   `numTasks`: `Approximate number of top-level tasks Taskmaster should aim to generate from the document.` (CLI: `-n, --num-tasks <number>`)
 54:     *   `force`: `Use this to allow Taskmaster to overwrite an existing 'tasks.json' without asking for confirmation.` (CLI: `-f, --force`)
 55: *   **Usage:** Useful for bootstrapping a project from an existing requirements document.
 56: *   **Notes:** Task Master will strictly adhere to any specific requirements mentioned in the PRD, such as libraries, database schemas, frameworks, tech stacks, etc., while filling in any gaps where the PRD isn't fully specified. Tasks are designed to provide the most direct implementation path while avoiding over-engineering.
 57: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress. If the user does not have a PRD, suggest discussing their idea and then use the example PRD in `.taskmaster/templates/example_prd.txt` as a template for creating the PRD based on their idea, for use with `parse-prd`.
 58: 
 59: ---
 60: 
 61: ## AI Model Configuration
 62: 
 63: ### 2. Manage Models (`models`)
 64: *   **MCP Tool:** `models`
 65: *   **CLI Command:** `task-master models [options]`
 66: *   **Description:** `View the current AI model configuration or set specific models for different roles (main, research, fallback). Allows setting custom model IDs for Ollama and OpenRouter.`
 67: *   **Key MCP Parameters/Options:**
 68:     *   `setMain <model_id>`: `Set the primary model ID for task generation/updates.` (CLI: `--set-main <model_id>`)
 69:     *   `setResearch <model_id>`: `Set the model ID for research-backed operations.` (CLI: `--set-research <model_id>`)
 70:     *   `setFallback <model_id>`: `Set the model ID to use if the primary fails.` (CLI: `--set-fallback <model_id>`)
 71:     *   `ollama <boolean>`: `Indicates the set model ID is a custom Ollama model.` (CLI: `--ollama`)
 72:     *   `openrouter <boolean>`: `Indicates the set model ID is a custom OpenRouter model.` (CLI: `--openrouter`)
 73:     *   `listAvailableModels <boolean>`: `If true, lists available models not currently assigned to a role.` (CLI: No direct equivalent; CLI lists available automatically)
 74:     *   `projectRoot <string>`: `Optional. Absolute path to the project root directory.` (CLI: Determined automatically)
 75: *   **Key CLI Options:**
 76:     *   `--set-main <model_id>`: `Set the primary model.`
 77:     *   `--set-research <model_id>`: `Set the research model.`
 78:     *   `--set-fallback <model_id>`: `Set the fallback model.`
 79:     *   `--ollama`: `Specify that the provided model ID is for Ollama (use with --set-*).`
 80:     *   `--openrouter`: `Specify that the provided model ID is for OpenRouter (use with --set-*). Validates against OpenRouter API.`
 81:     *   `--bedrock`: `Specify that the provided model ID is for AWS Bedrock (use with --set-*).`
 82:     *   `--setup`: `Run interactive setup to configure models, including custom Ollama/OpenRouter IDs.`
 83: *   **Usage (MCP):** Call without set flags to get current config. Use `setMain`, `setResearch`, or `setFallback` with a valid model ID to update the configuration. Use `listAvailableModels: true` to get a list of unassigned models. To set a custom model, provide the model ID and set `ollama: true` or `openrouter: true`.
 84: *   **Usage (CLI):** Run without flags to view current configuration and available models. Use set flags to update specific roles. Use `--setup` for guided configuration, including custom models. To set a custom model via flags, use `--set-<role>=<model_id>` along with either `--ollama` or `--openrouter`.
 85: *   **Notes:** Configuration is stored in `.taskmaster/config.json` in the project root. This command/tool modifies that file. Use `listAvailableModels` or `task-master models` to see internally supported models. OpenRouter custom models are validated against their live API. Ollama custom models are not validated live.
 86: *   **API note:** API keys for selected AI providers (based on their model) need to exist in the mcp.json file to be accessible in MCP context. The API keys must be present in the local .env file for the CLI to be able to read them.
 87: *   **Model costs:** The costs in supported models are expressed in dollars. An input/output value of 3 is $3.00. A value of 0.8 is $0.80. 
 88: *   **Warning:** DO NOT MANUALLY EDIT THE .taskmaster/config.json FILE. Use the included commands either in the MCP or CLI format as needed. Always prioritize MCP tools when available and use the CLI as a fallback.
 89: 
 90: ---
 91: 
 92: ## Task Listing & Viewing
 93: 
 94: ### 3. Get Tasks (`get_tasks`)
 95: 
 96: *   **MCP Tool:** `get_tasks`
 97: *   **CLI Command:** `task-master list [options]`
 98: *   **Description:** `List your Taskmaster tasks, optionally filtering by status and showing subtasks.`
 99: *   **Key Parameters/Options:**
100:     *   `status`: `Show only Taskmaster tasks matching this status (or multiple statuses, comma-separated), e.g., 'pending' or 'done,in-progress'.` (CLI: `-s, --status <status>`)
101:     *   `withSubtasks`: `Include subtasks indented under their parent tasks in the list.` (CLI: `--with-subtasks`)
102:     *   `tag`: `Specify which tag context to list tasks from. Defaults to the current active tag.` (CLI: `--tag <name>`)
103:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
104: *   **Usage:** Get an overview of the project status, often used at the start of a work session.
105: 
106: ### 4. Get Next Task (`next_task`)
107: 
108: *   **MCP Tool:** `next_task`
109: *   **CLI Command:** `task-master next [options]`
110: *   **Description:** `Ask Taskmaster to show the next available task you can work on, based on status and completed dependencies.`
111: *   **Key Parameters/Options:**
112:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
113:     *   `tag`: `Specify which tag context to use. Defaults to the current active tag.` (CLI: `--tag <name>`)
114: *   **Usage:** Identify what to work on next according to the plan.
115: 
116: ### 5. Get Task Details (`get_task`)
117: 
118: *   **MCP Tool:** `get_task`
119: *   **CLI Command:** `task-master show [id] [options]`
120: *   **Description:** `Display detailed information for one or more specific Taskmaster tasks or subtasks by ID.`
121: *   **Key Parameters/Options:**
122:     *   `id`: `Required. The ID of the Taskmaster task (e.g., '15'), subtask (e.g., '15.2'), or a comma-separated list of IDs ('1,5,10.2') you want to view.` (CLI: `[id]` positional or `-i, --id <id>`)
123:     *   `tag`: `Specify which tag context to get the task(s) from. Defaults to the current active tag.` (CLI: `--tag <name>`)
124:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
125: *   **Usage:** Understand the full details for a specific task. When multiple IDs are provided, a summary table is shown.
126: *   **CRITICAL INFORMATION** If you need to collect information from multiple tasks, use comma-separated IDs (i.e. 1,2,3) to receive an array of tasks. Do not needlessly get tasks one at a time if you need to get many as that is wasteful.
127: 
128: ---
129: 
130: ## Task Creation & Modification
131: 
132: ### 6. Add Task (`add_task`)
133: 
134: *   **MCP Tool:** `add_task`
135: *   **CLI Command:** `task-master add-task [options]`
136: *   **Description:** `Add a new task to Taskmaster by describing it; AI will structure it.`
137: *   **Key Parameters/Options:**
138:     *   `prompt`: `Required. Describe the new task you want Taskmaster to create, e.g., "Implement user authentication using JWT".` (CLI: `-p, --prompt <text>`)
139:     *   `dependencies`: `Specify the IDs of any Taskmaster tasks that must be completed before this new one can start, e.g., '12,14'.` (CLI: `-d, --dependencies <ids>`)
140:     *   `priority`: `Set the priority for the new task: 'high', 'medium', or 'low'. Default is 'medium'.` (CLI: `--priority <priority>`)
141:     *   `research`: `Enable Taskmaster to use the research role for potentially more informed task creation.` (CLI: `-r, --research`)
142:     *   `tag`: `Specify which tag context to add the task to. Defaults to the current active tag.` (CLI: `--tag <name>`)
143:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
144: *   **Usage:** Quickly add newly identified tasks during development.
145: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
146: 
147: ### 7. Add Subtask (`add_subtask`)
148: 
149: *   **MCP Tool:** `add_subtask`
150: *   **CLI Command:** `task-master add-subtask [options]`
151: *   **Description:** `Add a new subtask to a Taskmaster parent task, or convert an existing task into a subtask.`
152: *   **Key Parameters/Options:**
153:     *   `id` / `parent`: `Required. The ID of the Taskmaster task that will be the parent.` (MCP: `id`, CLI: `-p, --parent <id>`)
154:     *   `taskId`: `Use this if you want to convert an existing top-level Taskmaster task into a subtask of the specified parent.` (CLI: `-i, --task-id <id>`)
155:     *   `title`: `Required if not using taskId. The title for the new subtask Taskmaster should create.` (CLI: `-t, --title <title>`)
156:     *   `description`: `A brief description for the new subtask.` (CLI: `-d, --description <text>`)
157:     *   `details`: `Provide implementation notes or details for the new subtask.` (CLI: `--details <text>`)
158:     *   `dependencies`: `Specify IDs of other tasks or subtasks, e.g., '15' or '16.1', that must be done before this new subtask.` (CLI: `--dependencies <ids>`)
159:     *   `status`: `Set the initial status for the new subtask. Default is 'pending'.` (CLI: `-s, --status <status>`)
160:     *   `skipGenerate`: `Prevent Taskmaster from automatically regenerating markdown task files after adding the subtask.` (CLI: `--skip-generate`)
161:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
162:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
163: *   **Usage:** Break down tasks manually or reorganize existing tasks.
164: 
165: ### 8. Update Tasks (`update`)
166: 
167: *   **MCP Tool:** `update`
168: *   **CLI Command:** `task-master update [options]`
169: *   **Description:** `Update multiple upcoming tasks in Taskmaster based on new context or changes, starting from a specific task ID.`
170: *   **Key Parameters/Options:**
171:     *   `from`: `Required. The ID of the first task Taskmaster should update. All tasks with this ID or higher that are not 'done' will be considered.` (CLI: `--from <id>`)
172:     *   `prompt`: `Required. Explain the change or new context for Taskmaster to apply to the tasks, e.g., "We are now using React Query instead of Redux Toolkit for data fetching".` (CLI: `-p, --prompt <text>`)
173:     *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
174:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
175:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
176: *   **Usage:** Handle significant implementation changes or pivots that affect multiple future tasks. Example CLI: `task-master update --from='18' --prompt='Switching to React Query.\nNeed to refactor data fetching...'`
177: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
178: 
179: ### 9. Update Task (`update_task`)
180: 
181: *   **MCP Tool:** `update_task`
182: *   **CLI Command:** `task-master update-task [options]`
183: *   **Description:** `Modify a specific Taskmaster task by ID, incorporating new information or changes. By default, this replaces the existing task details.`
184: *   **Key Parameters/Options:**
185:     *   `id`: `Required. The specific ID of the Taskmaster task, e.g., '15', you want to update.` (CLI: `-i, --id <id>`)
186:     *   `prompt`: `Required. Explain the specific changes or provide the new information Taskmaster should incorporate into this task.` (CLI: `-p, --prompt <text>`)
187:     *   `append`: `If true, appends the prompt content to the task's details with a timestamp, rather than replacing them. Behaves like update-subtask.` (CLI: `--append`)
188:     *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
189:     *   `tag`: `Specify which tag context the task belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
190:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
191: *   **Usage:** Refine a specific task based on new understanding. Use `--append` to log progress without creating subtasks.
192: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
193: 
194: ### 10. Update Subtask (`update_subtask`)
195: 
196: *   **MCP Tool:** `update_subtask`
197: *   **CLI Command:** `task-master update-subtask [options]`
198: *   **Description:** `Append timestamped notes or details to a specific Taskmaster subtask without overwriting existing content. Intended for iterative implementation logging.`
199: *   **Key Parameters/Options:**
200:     *   `id`: `Required. The ID of the Taskmaster subtask, e.g., '5.2', to update with new information.` (CLI: `-i, --id <id>`)
201:     *   `prompt`: `Required. The information, findings, or progress notes to append to the subtask's details with a timestamp.` (CLI: `-p, --prompt <text>`)
202:     *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
203:     *   `tag`: `Specify which tag context the subtask belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
204:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
205: *   **Usage:** Log implementation progress, findings, and discoveries during subtask development. Each update is timestamped and appended to preserve the implementation journey.
206: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
207: 
208: ### 11. Set Task Status (`set_task_status`)
209: 
210: *   **MCP Tool:** `set_task_status`
211: *   **CLI Command:** `task-master set-status [options]`
212: *   **Description:** `Update the status of one or more Taskmaster tasks or subtasks, e.g., 'pending', 'in-progress', 'done'.`
213: *   **Key Parameters/Options:**
214:     *   `id`: `Required. The ID(s) of the Taskmaster task(s) or subtask(s), e.g., '15', '15.2', or '16,17.1', to update.` (CLI: `-i, --id <id>`)
215:     *   `status`: `Required. The new status to set, e.g., 'done', 'pending', 'in-progress', 'review', 'cancelled'.` (CLI: `-s, --status <status>`)
216:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
217:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
218: *   **Usage:** Mark progress as tasks move through the development cycle.
219: 
220: ### 12. Remove Task (`remove_task`)
221: 
222: *   **MCP Tool:** `remove_task`
223: *   **CLI Command:** `task-master remove-task [options]`
224: *   **Description:** `Permanently remove a task or subtask from the Taskmaster tasks list.`
225: *   **Key Parameters/Options:**
226:     *   `id`: `Required. The ID of the Taskmaster task, e.g., '5', or subtask, e.g., '5.2', to permanently remove.` (CLI: `-i, --id <id>`)
227:     *   `yes`: `Skip the confirmation prompt and immediately delete the task.` (CLI: `-y, --yes`)
228:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
229:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
230: *   **Usage:** Permanently delete tasks or subtasks that are no longer needed in the project.
231: *   **Notes:** Use with caution as this operation cannot be undone. Consider using 'blocked', 'cancelled', or 'deferred' status instead if you just want to exclude a task from active planning but keep it for reference. The command automatically cleans up dependency references in other tasks.
232: 
233: ---
234: 
235: ## Task Structure & Breakdown
236: 
237: ### 13. Expand Task (`expand_task`)
238: 
239: *   **MCP Tool:** `expand_task`
240: *   **CLI Command:** `task-master expand [options]`
241: *   **Description:** `Use Taskmaster's AI to break down a complex task into smaller, manageable subtasks. Appends subtasks by default.`
242: *   **Key Parameters/Options:**
243:     *   `id`: `The ID of the specific Taskmaster task you want to break down into subtasks.` (CLI: `-i, --id <id>`)
244:     *   `num`: `Optional: Suggests how many subtasks Taskmaster should aim to create. Uses complexity analysis/defaults otherwise.` (CLI: `-n, --num <number>`)
245:     *   `research`: `Enable Taskmaster to use the research role for more informed subtask generation. Requires appropriate API key.` (CLI: `-r, --research`)
246:     *   `prompt`: `Optional: Provide extra context or specific instructions to Taskmaster for generating the subtasks.` (CLI: `-p, --prompt <text>`)
247:     *   `force`: `Optional: If true, clear existing subtasks before generating new ones. Default is false (append).` (CLI: `--force`)
248:     *   `tag`: `Specify which tag context the task belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
249:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
250: *   **Usage:** Generate a detailed implementation plan for a complex task before starting coding. Automatically uses complexity report recommendations if available and `num` is not specified.
251: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
252: 
253: ### 14. Expand All Tasks (`expand_all`)
254: 
255: *   **MCP Tool:** `expand_all`
256: *   **CLI Command:** `task-master expand --all [options]` (Note: CLI uses the `expand` command with the `--all` flag)
257: *   **Description:** `Tell Taskmaster to automatically expand all eligible pending/in-progress tasks based on complexity analysis or defaults. Appends subtasks by default.`
258: *   **Key Parameters/Options:**
259:     *   `num`: `Optional: Suggests how many subtasks Taskmaster should aim to create per task.` (CLI: `-n, --num <number>`)
260:     *   `research`: `Enable research role for more informed subtask generation. Requires appropriate API key.` (CLI: `-r, --research`)
261:     *   `prompt`: `Optional: Provide extra context for Taskmaster to apply generally during expansion.` (CLI: `-p, --prompt <text>`)
262:     *   `force`: `Optional: If true, clear existing subtasks before generating new ones for each eligible task. Default is false (append).` (CLI: `--force`)
263:     *   `tag`: `Specify which tag context to expand. Defaults to the current active tag.` (CLI: `--tag <name>`)
264:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
265: *   **Usage:** Useful after initial task generation or complexity analysis to break down multiple tasks at once.
266: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
267: 
268: ### 15. Clear Subtasks (`clear_subtasks`)
269: 
270: *   **MCP Tool:** `clear_subtasks`
271: *   **CLI Command:** `task-master clear-subtasks [options]`
272: *   **Description:** `Remove all subtasks from one or more specified Taskmaster parent tasks.`
273: *   **Key Parameters/Options:**
274:     *   `id`: `The ID(s) of the Taskmaster parent task(s) whose subtasks you want to remove, e.g., '15' or '16,18'. Required unless using `all`.) (CLI: `-i, --id <ids>`)
275:     *   `all`: `Tell Taskmaster to remove subtasks from all parent tasks.` (CLI: `--all`)
276:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
277:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
278: *   **Usage:** Used before regenerating subtasks with `expand_task` if the previous breakdown needs replacement.
279: 
280: ### 16. Remove Subtask (`remove_subtask`)
281: 
282: *   **MCP Tool:** `remove_subtask`
283: *   **CLI Command:** `task-master remove-subtask [options]`
284: *   **Description:** `Remove a subtask from its Taskmaster parent, optionally converting it into a standalone task.`
285: *   **Key Parameters/Options:**
286:     *   `id`: `Required. The ID(s) of the Taskmaster subtask(s) to remove, e.g., '15.2' or '16.1,16.3'.` (CLI: `-i, --id <id>`)
287:     *   `convert`: `If used, Taskmaster will turn the subtask into a regular top-level task instead of deleting it.` (CLI: `-c, --convert`)
288:     *   `skipGenerate`: `Prevent Taskmaster from automatically regenerating markdown task files after removing the subtask.` (CLI: `--skip-generate`)
289:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
290:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
291: *   **Usage:** Delete unnecessary subtasks or promote a subtask to a top-level task.
292: 
293: ### 17. Move Task (`move_task`)
294: 
295: *   **MCP Tool:** `move_task`
296: *   **CLI Command:** `task-master move [options]`
297: *   **Description:** `Move a task or subtask to a new position within the task hierarchy.`
298: *   **Key Parameters/Options:**
299:     *   `from`: `Required. ID of the task/subtask to move (e.g., "5" or "5.2"). Can be comma-separated for multiple tasks.` (CLI: `--from <id>`)
300:     *   `to`: `Required. ID of the destination (e.g., "7" or "7.3"). Must match the number of source IDs if comma-separated.` (CLI: `--to <id>`)
301:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
302:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
303: *   **Usage:** Reorganize tasks by moving them within the hierarchy. Supports various scenarios like:
304:     *   Moving a task to become a subtask
305:     *   Moving a subtask to become a standalone task
306:     *   Moving a subtask to a different parent
307:     *   Reordering subtasks within the same parent
308:     *   Moving a task to a new, non-existent ID (automatically creates placeholders)
309:     *   Moving multiple tasks at once with comma-separated IDs
310: *   **Validation Features:**
311:     *   Allows moving tasks to non-existent destination IDs (creates placeholder tasks)
312:     *   Prevents moving to existing task IDs that already have content (to avoid overwriting)
313:     *   Validates that source tasks exist before attempting to move them
314:     *   Maintains proper parent-child relationships
315: *   **Example CLI:** `task-master move --from=5.2 --to=7.3` to move subtask 5.2 to become subtask 7.3.
316: *   **Example Multi-Move:** `task-master move --from=10,11,12 --to=16,17,18` to move multiple tasks to new positions.
317: *   **Common Use:** Resolving merge conflicts in tasks.json when multiple team members create tasks on different branches.
318: 
319: ---
320: 
321: ## Dependency Management
322: 
323: ### 18. Add Dependency (`add_dependency`)
324: 
325: *   **MCP Tool:** `add_dependency`
326: *   **CLI Command:** `task-master add-dependency [options]`
327: *   **Description:** `Define a dependency in Taskmaster, making one task a prerequisite for another.`
328: *   **Key Parameters/Options:**
329:     *   `id`: `Required. The ID of the Taskmaster task that will depend on another.` (CLI: `-i, --id <id>`)
330:     *   `dependsOn`: `Required. The ID of the Taskmaster task that must be completed first, the prerequisite.` (CLI: `-d, --depends-on <id>`)
331:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
332:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <path>`)
333: *   **Usage:** Establish the correct order of execution between tasks.
334: 
335: ### 19. Remove Dependency (`remove_dependency`)
336: 
337: *   **MCP Tool:** `remove_dependency`
338: *   **CLI Command:** `task-master remove-dependency [options]`
339: *   **Description:** `Remove a dependency relationship between two Taskmaster tasks.`
340: *   **Key Parameters/Options:**
341:     *   `id`: `Required. The ID of the Taskmaster task you want to remove a prerequisite from.` (CLI: `-i, --id <id>`)
342:     *   `dependsOn`: `Required. The ID of the Taskmaster task that should no longer be a prerequisite.` (CLI: `-d, --depends-on <id>`)
343:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
344:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
345: *   **Usage:** Update task relationships when the order of execution changes.
346: 
347: ### 20. Validate Dependencies (`validate_dependencies`)
348: 
349: *   **MCP Tool:** `validate_dependencies`
350: *   **CLI Command:** `task-master validate-dependencies [options]`
351: *   **Description:** `Check your Taskmaster tasks for dependency issues (like circular references or links to non-existent tasks) without making changes.`
352: *   **Key Parameters/Options:**
353:     *   `tag`: `Specify which tag context to validate. Defaults to the current active tag.` (CLI: `--tag <name>`)
354:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
355: *   **Usage:** Audit the integrity of your task dependencies.
356: 
357: ### 21. Fix Dependencies (`fix_dependencies`)
358: 
359: *   **MCP Tool:** `fix_dependencies`
360: *   **CLI Command:** `task-master fix-dependencies [options]`
361: *   **Description:** `Automatically fix dependency issues (like circular references or links to non-existent tasks) in your Taskmaster tasks.`
362: *   **Key Parameters/Options:**
363:     *   `tag`: `Specify which tag context to fix dependencies in. Defaults to the current active tag.` (CLI: `--tag <name>`)
364:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
365: *   **Usage:** Clean up dependency errors automatically.
366: 
367: ---
368: 
369: ## Analysis & Reporting
370: 
371: ### 22. Analyze Project Complexity (`analyze_project_complexity`)
372: 
373: *   **MCP Tool:** `analyze_project_complexity`
374: *   **CLI Command:** `task-master analyze-complexity [options]`
375: *   **Description:** `Have Taskmaster analyze your tasks to determine their complexity and suggest which ones need to be broken down further.`
376: *   **Key Parameters/Options:**
377:     *   `output`: `Where to save the complexity analysis report. Default is '.taskmaster/reports/task-complexity-report.json' (or '..._tagname.json' if a tag is used).` (CLI: `-o, --output <file>`)
378:     *   `threshold`: `The minimum complexity score (1-10) that should trigger a recommendation to expand a task.` (CLI: `-t, --threshold <number>`)
379:     *   `research`: `Enable research role for more accurate complexity analysis. Requires appropriate API key.` (CLI: `-r, --research`)
380:     *   `tag`: `Specify which tag context to analyze. Defaults to the current active tag.` (CLI: `--tag <name>`)
381:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
382: *   **Usage:** Used before breaking down tasks to identify which ones need the most attention.
383: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
384: 
385: ### 23. View Complexity Report (`complexity_report`)
386: 
387: *   **MCP Tool:** `complexity_report`
388: *   **CLI Command:** `task-master complexity-report [options]`
389: *   **Description:** `Display the task complexity analysis report in a readable format.`
390: *   **Key Parameters/Options:**
391:     *   `tag`: `Specify which tag context to show the report for. Defaults to the current active tag.` (CLI: `--tag <name>`)
392:     *   `file`: `Path to the complexity report (default: '.taskmaster/reports/task-complexity-report.json').` (CLI: `-f, --file <file>`)
393: *   **Usage:** Review and understand the complexity analysis results after running analyze-complexity.
394: 
395: ---
396: 
397: ## File Management
398: 
399: ### 24. Generate Task Files (`generate`)
400: 
401: *   **MCP Tool:** `generate`
402: *   **CLI Command:** `task-master generate [options]`
403: *   **Description:** `Create or update individual Markdown files for each task based on your tasks.json.`
404: *   **Key Parameters/Options:**
405:     *   `output`: `The directory where Taskmaster should save the task files (default: in a 'tasks' directory).` (CLI: `-o, --output <directory>`)
406:     *   `tag`: `Specify which tag context to generate files for. Defaults to the current active tag.` (CLI: `--tag <name>`)
407:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
408: *   **Usage:** Run this after making changes to tasks.json to keep individual task files up to date. This command is now manual and no longer runs automatically.
409: 
410: ---
411: 
412: ## AI-Powered Research
413: 
414: ### 25. Research (`research`)
415: 
416: *   **MCP Tool:** `research`
417: *   **CLI Command:** `task-master research [options]`
418: *   **Description:** `Perform AI-powered research queries with project context to get fresh, up-to-date information beyond the AI's knowledge cutoff.`
419: *   **Key Parameters/Options:**
420:     *   `query`: `Required. Research query/prompt (e.g., "What are the latest best practices for React Query v5?").` (CLI: `[query]` positional or `-q, --query <text>`)
421:     *   `taskIds`: `Comma-separated list of task/subtask IDs from the current tag context (e.g., "15,16.2,17").` (CLI: `-i, --id <ids>`)
422:     *   `filePaths`: `Comma-separated list of file paths for context (e.g., "src/api.js,docs/readme.md").` (CLI: `-f, --files <paths>`)
423:     *   `customContext`: `Additional custom context text to include in the research.` (CLI: `-c, --context <text>`)
424:     *   `includeProjectTree`: `Include project file tree structure in context (default: false).` (CLI: `--tree`)
425:     *   `detailLevel`: `Detail level for the research response: 'low', 'medium', 'high' (default: medium).` (CLI: `--detail <level>`)
426:     *   `saveTo`: `Task or subtask ID (e.g., "15", "15.2") to automatically save the research conversation to.` (CLI: `--save-to <id>`)
427:     *   `saveFile`: `If true, saves the research conversation to a markdown file in '.taskmaster/docs/research/'.` (CLI: `--save-file`)
428:     *   `noFollowup`: `Disables the interactive follow-up question menu in the CLI.` (CLI: `--no-followup`)
429:     *   `tag`: `Specify which tag context to use for task-based context gathering. Defaults to the current active tag.` (CLI: `--tag <name>`)
430:     *   `projectRoot`: `The directory of the project. Must be an absolute path.` (CLI: Determined automatically)
431: *   **Usage:** **This is a POWERFUL tool that agents should use FREQUENTLY** to:
432:     *   Get fresh information beyond knowledge cutoff dates
433:     *   Research latest best practices, library updates, security patches
434:     *   Find implementation examples for specific technologies
435:     *   Validate approaches against current industry standards
436:     *   Get contextual advice based on project files and tasks
437: *   **When to Consider Using Research:**
438:     *   **Before implementing any task** - Research current best practices
439:     *   **When encountering new technologies** - Get up-to-date implementation guidance (libraries, apis, etc)
440:     *   **For security-related tasks** - Find latest security recommendations
441:     *   **When updating dependencies** - Research breaking changes and migration guides
442:     *   **For performance optimization** - Get current performance best practices
443:     *   **When debugging complex issues** - Research known solutions and workarounds
444: *   **Research + Action Pattern:**
445:     *   Use `research` to gather fresh information
446:     *   Use `update_subtask` to commit findings with timestamps
447:     *   Use `update_task` to incorporate research into task details
448:     *   Use `add_task` with research flag for informed task creation
449: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. The research provides FRESH data beyond the AI's training cutoff, making it invaluable for current best practices and recent developments.
450: 
451: ---
452: 
453: ## Tag Management
454: 
455: This new suite of commands allows you to manage different task contexts (tags).
456: 
457: ### 26. List Tags (`tags`)
458: 
459: *   **MCP Tool:** `list_tags`
460: *   **CLI Command:** `task-master tags [options]`
461: *   **Description:** `List all available tags with task counts, completion status, and other metadata.`
462: *   **Key Parameters/Options:**
463:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
464:     *   `--show-metadata`: `Include detailed metadata in the output (e.g., creation date, description).` (CLI: `--show-metadata`)
465: 
466: ### 27. Add Tag (`add_tag`)
467: 
468: *   **MCP Tool:** `add_tag`
469: *   **CLI Command:** `task-master add-tag <tagName> [options]`
470: *   **Description:** `Create a new, empty tag context, or copy tasks from another tag.`
471: *   **Key Parameters/Options:**
472:     *   `tagName`: `Name of the new tag to create (alphanumeric, hyphens, underscores).` (CLI: `<tagName>` positional)
473:     *   `--from-branch`: `Creates a tag with a name derived from the current git branch, ignoring the <tagName> argument.` (CLI: `--from-branch`)
474:     *   `--copy-from-current`: `Copy tasks from the currently active tag to the new tag.` (CLI: `--copy-from-current`)
475:     *   `--copy-from <tag>`: `Copy tasks from a specific source tag to the new tag.` (CLI: `--copy-from <tag>`)
476:     *   `--description <text>`: `Provide an optional description for the new tag.` (CLI: `-d, --description <text>`)
477:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
478: 
479: ### 28. Delete Tag (`delete_tag`)
480: 
481: *   **MCP Tool:** `delete_tag`
482: *   **CLI Command:** `task-master delete-tag <tagName> [options]`
483: *   **Description:** `Permanently delete a tag and all of its associated tasks.`
484: *   **Key Parameters/Options:**
485:     *   `tagName`: `Name of the tag to delete.` (CLI: `<tagName>` positional)
486:     *   `--yes`: `Skip the confirmation prompt.` (CLI: `-y, --yes`)
487:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
488: 
489: ### 29. Use Tag (`use_tag`)
490: 
491: *   **MCP Tool:** `use_tag`
492: *   **CLI Command:** `task-master use-tag <tagName>`
493: *   **Description:** `Switch your active task context to a different tag.`
494: *   **Key Parameters/Options:**
495:     *   `tagName`: `Name of the tag to switch to.` (CLI: `<tagName>` positional)
496:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
497: 
498: ### 30. Rename Tag (`rename_tag`)
499: 
500: *   **MCP Tool:** `rename_tag`
501: *   **CLI Command:** `task-master rename-tag <oldName> <newName>`
502: *   **Description:** `Rename an existing tag.`
503: *   **Key Parameters/Options:**
504:     *   `oldName`: `The current name of the tag.` (CLI: `<oldName>` positional)
505:     *   `newName`: `The new name for the tag.` (CLI: `<newName>` positional)
506:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
507: 
508: ### 31. Copy Tag (`copy_tag`)
509: 
510: *   **MCP Tool:** `copy_tag`
511: *   **CLI Command:** `task-master copy-tag <sourceName> <targetName> [options]`
512: *   **Description:** `Copy an entire tag context, including all its tasks and metadata, to a new tag.`
513: *   **Key Parameters/Options:**
514:     *   `sourceName`: `Name of the tag to copy from.` (CLI: `<sourceName>` positional)
515:     *   `targetName`: `Name of the new tag to create.` (CLI: `<targetName>` positional)
516:     *   `--description <text>`: `Optional description for the new tag.` (CLI: `-d, --description <text>`)
517: 
518: ---
519: 
520: ## Miscellaneous
521: 
522: ### 32. Sync Readme (`sync-readme`) -- experimental
523: 
524: *   **MCP Tool:** N/A
525: *   **CLI Command:** `task-master sync-readme [options]`
526: *   **Description:** `Exports your task list to your project's README.md file, useful for showcasing progress.`
527: *   **Key Parameters/Options:**
528:     *   `status`: `Filter tasks by status (e.g., 'pending', 'done').` (CLI: `-s, --status <status>`)
529:     *   `withSubtasks`: `Include subtasks in the export.` (CLI: `--with-subtasks`)
530:     *   `tag`: `Specify which tag context to export from. Defaults to the current active tag.` (CLI: `--tag <name>`)
531: 
532: ---
533: 
534: ## Environment Variables Configuration (Updated)
535: 
536: Taskmaster primarily uses the **`.taskmaster/config.json`** file (in project root) for configuration (models, parameters, logging level, etc.), managed via `task-master models --setup`.
537: 
538: Environment variables are used **only** for sensitive API keys related to AI providers and specific overrides like the Ollama base URL:
539: 
540: *   **API Keys (Required for corresponding provider):**
541:     *   `ANTHROPIC_API_KEY`
542:     *   `PERPLEXITY_API_KEY`
543:     *   `OPENAI_API_KEY`
544:     *   `GOOGLE_API_KEY`
545:     *   `MISTRAL_API_KEY`
546:     *   `AZURE_OPENAI_API_KEY` (Requires `AZURE_OPENAI_ENDPOINT` too)
547:     *   `OPENROUTER_API_KEY`
548:     *   `XAI_API_KEY`
549:     *   `OLLAMA_API_KEY` (Requires `OLLAMA_BASE_URL` too)
550: *   **Endpoints (Optional/Provider Specific inside .taskmaster/config.json):**
551:     *   `AZURE_OPENAI_ENDPOINT`
552:     *   `OLLAMA_BASE_URL` (Default: `http://localhost:11434/api`)
553: 
554: **Set API keys** in your **`.env`** file in the project root (for CLI use) or within the `env` section of your **`.roo/mcp.json`** file (for MCP/Roo Code integration). All other settings (model choice, max tokens, temperature, log level, custom endpoints) are managed in `.taskmaster/config.json` via `task-master models` command or `models` MCP tool.
555: 
556: ---
557: 
558: For details on how these commands fit into the development process, see the [dev_workflow.md](.roo/rules/dev_workflow.md).
</file>

<file path=".roo/mcp.json">
 1: {
 2: 	"mcpServers": {
 3: 		"task-master-ai": {
 4: 			"command": "npx",
 5: 			"args": ["-y", "--package=task-master-ai", "task-master-ai"],
 6: 			"env": {
 7: 				"ANTHROPIC_API_KEY": "ANTHROPIC_API_KEY_HERE",
 8: 				"PERPLEXITY_API_KEY": "PERPLEXITY_API_KEY_HERE",
 9: 				"OPENAI_API_KEY": "OPENAI_API_KEY_HERE",
10: 				"GOOGLE_API_KEY": "GOOGLE_API_KEY_HERE",
11: 				"XAI_API_KEY": "XAI_API_KEY_HERE",
12: 				"OPENROUTER_API_KEY": "OPENROUTER_API_KEY_HERE",
13: 				"MISTRAL_API_KEY": "MISTRAL_API_KEY_HERE",
14: 				"AZURE_OPENAI_API_KEY": "AZURE_OPENAI_API_KEY_HERE",
15: 				"OLLAMA_API_KEY": "OLLAMA_API_KEY_HERE"
16: 			}
17: 		}
18: 	}
19: }
</file>

<file path=".trae/rules/dev_workflow.md">
  1: ---
  2: description: Guide for using Taskmaster to manage task-driven development workflows
  3: globs: **/*
  4: alwaysApply: true
  5: ---
  6: 
  7: # Taskmaster Development Workflow
  8: 
  9: This guide outlines the standard process for using Taskmaster to manage software development projects. It is written as a set of instructions for you, the AI agent.
 10: 
 11: - **Your Default Stance**: For most projects, the user can work directly within the `master` task context. Your initial actions should operate on this default context unless a clear pattern for multi-context work emerges.
 12: - **Your Goal**: Your role is to elevate the user's workflow by intelligently introducing advanced features like **Tagged Task Lists** when you detect the appropriate context. Do not force tags on the user; suggest them as a helpful solution to a specific need.
 13: 
 14: ## The Basic Loop
 15: The fundamental development cycle you will facilitate is:
 16: 1.  **`list`**: Show the user what needs to be done.
 17: 2.  **`next`**: Help the user decide what to work on.
 18: 3.  **`show <id>`**: Provide details for a specific task.
 19: 4.  **`expand <id>`**: Break down a complex task into smaller, manageable subtasks.
 20: 5.  **Implement**: The user writes the code and tests.
 21: 6.  **`update-subtask`**: Log progress and findings on behalf of the user.
 22: 7.  **`set-status`**: Mark tasks and subtasks as `done` as work is completed.
 23: 8.  **Repeat**.
 24: 
 25: All your standard command executions should operate on the user's current task context, which defaults to `master`.
 26: 
 27: ---
 28: 
 29: ## Standard Development Workflow Process
 30: 
 31: ### Simple Workflow (Default Starting Point)
 32: 
 33: For new projects or when users are getting started, operate within the `master` tag context:
 34: 
 35: -   Start new projects by running `initialize_project` tool / `task-master init` or `parse_prd` / `task-master parse-prd --input='<prd-file.txt>'` (see @`taskmaster.md`) to generate initial tasks.json with tagged structure
 36: -   Configure rule sets during initialization with `--rules` flag (e.g., `task-master init --rules trae,windsurf`) or manage them later with `task-master rules add/remove` commands  
 37: -   Begin coding sessions with `get_tasks` / `task-master list` (see @`taskmaster.md`) to see current tasks, status, and IDs
 38: -   Determine the next task to work on using `next_task` / `task-master next` (see @`taskmaster.md`)
 39: -   Analyze task complexity with `analyze_project_complexity` / `task-master analyze-complexity --research` (see @`taskmaster.md`) before breaking down tasks
 40: -   Review complexity report using `complexity_report` / `task-master complexity-report` (see @`taskmaster.md`)
 41: -   Select tasks based on dependencies (all marked 'done'), priority level, and ID order
 42: -   View specific task details using `get_task` / `task-master show <id>` (see @`taskmaster.md`) to understand implementation requirements
 43: -   Break down complex tasks using `expand_task` / `task-master expand --id=<id> --force --research` (see @`taskmaster.md`) with appropriate flags like `--force` (to replace existing subtasks) and `--research`
 44: -   Implement code following task details, dependencies, and project standards
 45: -   Mark completed tasks with `set_task_status` / `task-master set-status --id=<id> --status=done` (see @`taskmaster.md`)
 46: -   Update dependent tasks when implementation differs from original plan using `update` / `task-master update --from=<id> --prompt="..."` or `update_task` / `task-master update-task --id=<id> --prompt="..."` (see @`taskmaster.md`)
 47: 
 48: ---
 49: 
 50: ## Leveling Up: Agent-Led Multi-Context Workflows
 51: 
 52: While the basic workflow is powerful, your primary opportunity to add value is by identifying when to introduce **Tagged Task Lists**. These patterns are your tools for creating a more organized and efficient development environment for the user, especially if you detect agentic or parallel development happening across the same session.
 53: 
 54: **Critical Principle**: Most users should never see a difference in their experience. Only introduce advanced workflows when you detect clear indicators that the project has evolved beyond simple task management.
 55: 
 56: ### When to Introduce Tags: Your Decision Patterns
 57: 
 58: Here are the patterns to look for. When you detect one, you should propose the corresponding workflow to the user.
 59: 
 60: #### Pattern 1: Simple Git Feature Branching
 61: This is the most common and direct use case for tags.
 62: 
 63: - **Trigger**: The user creates a new git branch (e.g., `git checkout -b feature/user-auth`).
 64: - **Your Action**: Propose creating a new tag that mirrors the branch name to isolate the feature's tasks from `master`.
 65: - **Your Suggested Prompt**: *"I see you've created a new branch named 'feature/user-auth'. To keep all related tasks neatly organized and separate from your main list, I can create a corresponding task tag for you. This helps prevent merge conflicts in your `tasks.json` file later. Shall I create the 'feature-user-auth' tag?"*
 66: - **Tool to Use**: `task-master add-tag --from-branch`
 67: 
 68: #### Pattern 2: Team Collaboration
 69: - **Trigger**: The user mentions working with teammates (e.g., "My teammate Alice is handling the database schema," or "I need to review Bob's work on the API.").
 70: - **Your Action**: Suggest creating a separate tag for the user's work to prevent conflicts with shared master context.
 71: - **Your Suggested Prompt**: *"Since you're working with Alice, I can create a separate task context for your work to avoid conflicts. This way, Alice can continue working with the master list while you have your own isolated context. When you're ready to merge your work, we can coordinate the tasks back to master. Shall I create a tag for your current work?"*
 72: - **Tool to Use**: `task-master add-tag my-work --copy-from-current --description="My tasks while collaborating with Alice"`
 73: 
 74: #### Pattern 3: Experiments or Risky Refactors
 75: - **Trigger**: The user wants to try something that might not be kept (e.g., "I want to experiment with switching our state management library," or "Let's refactor the old API module, but I want to keep the current tasks as a reference.").
 76: - **Your Action**: Propose creating a sandboxed tag for the experimental work.
 77: - **Your Suggested Prompt**: *"This sounds like a great experiment. To keep these new tasks separate from our main plan, I can create a temporary 'experiment-zustand' tag for this work. If we decide not to proceed, we can simply delete the tag without affecting the main task list. Sound good?"*
 78: - **Tool to Use**: `task-master add-tag experiment-zustand --description="Exploring Zustand migration"`
 79: 
 80: #### Pattern 4: Large Feature Initiatives (PRD-Driven)
 81: This is a more structured approach for significant new features or epics.
 82: 
 83: - **Trigger**: The user describes a large, multi-step feature that would benefit from a formal plan.
 84: - **Your Action**: Propose a comprehensive, PRD-driven workflow.
 85: - **Your Suggested Prompt**: *"This sounds like a significant new feature. To manage this effectively, I suggest we create a dedicated task context for it. Here's the plan: I'll create a new tag called 'feature-xyz', then we can draft a Product Requirements Document (PRD) together to scope the work. Once the PRD is ready, I'll automatically generate all the necessary tasks within that new tag. How does that sound?"*
 86: - **Your Implementation Flow**:
 87:     1.  **Create an empty tag**: `task-master add-tag feature-xyz --description "Tasks for the new XYZ feature"`. You can also start by creating a git branch if applicable, and then create the tag from that branch.
 88:     2.  **Collaborate & Create PRD**: Work with the user to create a detailed PRD file (e.g., `.taskmaster/docs/feature-xyz-prd.txt`).
 89:     3.  **Parse PRD into the new tag**: `task-master parse-prd .taskmaster/docs/feature-xyz-prd.txt --tag feature-xyz`
 90:     4.  **Prepare the new task list**: Follow up by suggesting `analyze-complexity` and `expand-all` for the newly created tasks within the `feature-xyz` tag.
 91: 
 92: #### Pattern 5: Version-Based Development
 93: Tailor your approach based on the project maturity indicated by tag names.
 94: 
 95: - **Prototype/MVP Tags** (`prototype`, `mvp`, `poc`, `v0.x`):
 96:   - **Your Approach**: Focus on speed and functionality over perfection
 97:   - **Task Generation**: Create tasks that emphasize "get it working" over "get it perfect"
 98:   - **Complexity Level**: Lower complexity, fewer subtasks, more direct implementation paths
 99:   - **Research Prompts**: Include context like "This is a prototype - prioritize speed and basic functionality over optimization"
100:   - **Example Prompt Addition**: *"Since this is for the MVP, I'll focus on tasks that get core functionality working quickly rather than over-engineering."*
101: 
102: - **Production/Mature Tags** (`v1.0+`, `production`, `stable`):
103:   - **Your Approach**: Emphasize robustness, testing, and maintainability
104:   - **Task Generation**: Include comprehensive error handling, testing, documentation, and optimization
105:   - **Complexity Level**: Higher complexity, more detailed subtasks, thorough implementation paths
106:   - **Research Prompts**: Include context like "This is for production - prioritize reliability, performance, and maintainability"
107:   - **Example Prompt Addition**: *"Since this is for production, I'll ensure tasks include proper error handling, testing, and documentation."*
108: 
109: ### Advanced Workflow (Tag-Based & PRD-Driven)
110: 
111: **When to Transition**: Recognize when the project has evolved (or has initiated a project which existing code) beyond simple task management. Look for these indicators:
112: - User mentions teammates or collaboration needs
113: - Project has grown to 15+ tasks with mixed priorities
114: - User creates feature branches or mentions major initiatives
115: - User initializes Taskmaster on an existing, complex codebase
116: - User describes large features that would benefit from dedicated planning
117: 
118: **Your Role in Transition**: Guide the user to a more sophisticated workflow that leverages tags for organization and PRDs for comprehensive planning.
119: 
120: #### Master List Strategy (High-Value Focus)
121: Once you transition to tag-based workflows, the `master` tag should ideally contain only:
122: - **High-level deliverables** that provide significant business value
123: - **Major milestones** and epic-level features
124: - **Critical infrastructure** work that affects the entire project
125: - **Release-blocking** items
126: 
127: **What NOT to put in master**:
128: - Detailed implementation subtasks (these go in feature-specific tags' parent tasks)
129: - Refactoring work (create dedicated tags like `refactor-auth`)
130: - Experimental features (use `experiment-*` tags)
131: - Team member-specific tasks (use person-specific tags)
132: 
133: #### PRD-Driven Feature Development
134: 
135: **For New Major Features**:
136: 1. **Identify the Initiative**: When user describes a significant feature
137: 2. **Create Dedicated Tag**: `add_tag feature-[name] --description="[Feature description]"`
138: 3. **Collaborative PRD Creation**: Work with user to create comprehensive PRD in `.taskmaster/docs/feature-[name]-prd.txt`
139: 4. **Parse & Prepare**: 
140:    - `parse_prd .taskmaster/docs/feature-[name]-prd.txt --tag=feature-[name]`
141:    - `analyze_project_complexity --tag=feature-[name] --research`
142:    - `expand_all --tag=feature-[name] --research`
143: 5. **Add Master Reference**: Create a high-level task in `master` that references the feature tag
144: 
145: **For Existing Codebase Analysis**:
146: When users initialize Taskmaster on existing projects:
147: 1. **Codebase Discovery**: Use your native tools for producing deep context about the code base. You may use `research` tool with `--tree` and `--files` to collect up to date information using the existing architecture as context.
148: 2. **Collaborative Assessment**: Work with user to identify improvement areas, technical debt, or new features
149: 3. **Strategic PRD Creation**: Co-author PRDs that include:
150:    - Current state analysis (based on your codebase research)
151:    - Proposed improvements or new features
152:    - Implementation strategy considering existing code
153: 4. **Tag-Based Organization**: Parse PRDs into appropriate tags (`refactor-api`, `feature-dashboard`, `tech-debt`, etc.)
154: 5. **Master List Curation**: Keep only the most valuable initiatives in master
155: 
156: The parse-prd's `--append` flag enables the user to parse multple PRDs within tags or across tags. PRDs should be focused and the number of tasks they are parsed into should be strategically chosen relative to the PRD's complexity and level of detail.
157: 
158: ### Workflow Transition Examples
159: 
160: **Example 1: Simple  Team-Based**
161: ```
162: User: "Alice is going to help with the API work"
163: Your Response: "Great! To avoid conflicts, I'll create a separate task context for your work. Alice can continue with the master list while you work in your own context. When you're ready to merge, we can coordinate the tasks back together."
164: Action: add_tag my-api-work --copy-from-current --description="My API tasks while collaborating with Alice"
165: ```
166: 
167: **Example 2: Simple  PRD-Driven**
168: ```
169: User: "I want to add a complete user dashboard with analytics, user management, and reporting"
170: Your Response: "This sounds like a major feature that would benefit from detailed planning. Let me create a dedicated context for this work and we can draft a PRD together to ensure we capture all requirements."
171: Actions: 
172: 1. add_tag feature-dashboard --description="User dashboard with analytics and management"
173: 2. Collaborate on PRD creation
174: 3. parse_prd dashboard-prd.txt --tag=feature-dashboard
175: 4. Add high-level "User Dashboard" task to master
176: ```
177: 
178: **Example 3: Existing Project  Strategic Planning**
179: ```
180: User: "I just initialized Taskmaster on my existing React app. It's getting messy and I want to improve it."
181: Your Response: "Let me research your codebase to understand the current architecture, then we can create a strategic plan for improvements."
182: Actions:
183: 1. research "Current React app architecture and improvement opportunities" --tree --files=src/
184: 2. Collaborate on improvement PRD based on findings
185: 3. Create tags for different improvement areas (refactor-components, improve-state-management, etc.)
186: 4. Keep only major improvement initiatives in master
187: ```
188: 
189: ---
190: 
191: ## Primary Interaction: MCP Server vs. CLI
192: 
193: Taskmaster offers two primary ways to interact:
194: 
195: 1.  **MCP Server (Recommended for Integrated Tools)**:
196:     - For AI agents and integrated development environments (like Trae), interacting via the **MCP server is the preferred method**.
197:     - The MCP server exposes Taskmaster functionality through a set of tools (e.g., `get_tasks`, `add_subtask`).
198:     - This method offers better performance, structured data exchange, and richer error handling compared to CLI parsing.
199:     - Refer to @`mcp.md` for details on the MCP architecture and available tools.
200:     - A comprehensive list and description of MCP tools and their corresponding CLI commands can be found in @`taskmaster.md`.
201:     - **Restart the MCP server** if core logic in `scripts/modules` or MCP tool/direct function definitions change.
202:     - **Note**: MCP tools fully support tagged task lists with complete tag management capabilities.
203: 
204: 2.  **`task-master` CLI (For Users & Fallback)**:
205:     - The global `task-master` command provides a user-friendly interface for direct terminal interaction.
206:     - It can also serve as a fallback if the MCP server is inaccessible or a specific function isn't exposed via MCP.
207:     - Install globally with `npm install -g task-master-ai` or use locally via `npx task-master-ai ...`.
208:     - The CLI commands often mirror the MCP tools (e.g., `task-master list` corresponds to `get_tasks`).
209:     - Refer to @`taskmaster.md` for a detailed command reference.
210:     - **Tagged Task Lists**: CLI fully supports the new tagged system with seamless migration.
211: 
212: ## How the Tag System Works (For Your Reference)
213: 
214: - **Data Structure**: Tasks are organized into separate contexts (tags) like "master", "feature-branch", or "v2.0".
215: - **Silent Migration**: Existing projects automatically migrate to use a "master" tag with zero disruption.
216: - **Context Isolation**: Tasks in different tags are completely separate. Changes in one tag do not affect any other tag.
217: - **Manual Control**: The user is always in control. There is no automatic switching. You facilitate switching by using `use-tag <name>`.
218: - **Full CLI & MCP Support**: All tag management commands are available through both the CLI and MCP tools for you to use. Refer to @`taskmaster.md` for a full command list.
219: 
220: ---
221: 
222: ## Task Complexity Analysis
223: 
224: -   Run `analyze_project_complexity` / `task-master analyze-complexity --research` (see @`taskmaster.md`) for comprehensive analysis
225: -   Review complexity report via `complexity_report` / `task-master complexity-report` (see @`taskmaster.md`) for a formatted, readable version.
226: -   Focus on tasks with highest complexity scores (8-10) for detailed breakdown
227: -   Use analysis results to determine appropriate subtask allocation
228: -   Note that reports are automatically used by the `expand_task` tool/command
229: 
230: ## Task Breakdown Process
231: 
232: -   Use `expand_task` / `task-master expand --id=<id>`. It automatically uses the complexity report if found, otherwise generates default number of subtasks.
233: -   Use `--num=<number>` to specify an explicit number of subtasks, overriding defaults or complexity report recommendations.
234: -   Add `--research` flag to leverage Perplexity AI for research-backed expansion.
235: -   Add `--force` flag to clear existing subtasks before generating new ones (default is to append).
236: -   Use `--prompt="<context>"` to provide additional context when needed.
237: -   Review and adjust generated subtasks as necessary.
238: -   Use `expand_all` tool or `task-master expand --all` to expand multiple pending tasks at once, respecting flags like `--force` and `--research`.
239: -   If subtasks need complete replacement (regardless of the `--force` flag on `expand`), clear them first with `clear_subtasks` / `task-master clear-subtasks --id=<id>`.
240: 
241: ## Implementation Drift Handling
242: 
243: -   When implementation differs significantly from planned approach
244: -   When future tasks need modification due to current implementation choices
245: -   When new dependencies or requirements emerge
246: -   Use `update` / `task-master update --from=<futureTaskId> --prompt='<explanation>\nUpdate context...' --research` to update multiple future tasks.
247: -   Use `update_task` / `task-master update-task --id=<taskId> --prompt='<explanation>\nUpdate context...' --research` to update a single specific task.
248: 
249: ## Task Status Management
250: 
251: -   Use 'pending' for tasks ready to be worked on
252: -   Use 'done' for completed and verified tasks
253: -   Use 'deferred' for postponed tasks
254: -   Add custom status values as needed for project-specific workflows
255: 
256: ## Task Structure Fields
257: 
258: - **id**: Unique identifier for the task (Example: `1`, `1.1`)
259: - **title**: Brief, descriptive title (Example: `"Initialize Repo"`)
260: - **description**: Concise summary of what the task involves (Example: `"Create a new repository, set up initial structure."`)
261: - **status**: Current state of the task (Example: `"pending"`, `"done"`, `"deferred"`)
262: - **dependencies**: IDs of prerequisite tasks (Example: `[1, 2.1]`)
263:     - Dependencies are displayed with status indicators ( for completed,  for pending)
264:     - This helps quickly identify which prerequisite tasks are blocking work
265: - **priority**: Importance level (Example: `"high"`, `"medium"`, `"low"`)
266: - **details**: In-depth implementation instructions (Example: `"Use GitHub client ID/secret, handle callback, set session token."`) 
267: - **testStrategy**: Verification approach (Example: `"Deploy and call endpoint to confirm 'Hello World' response."`) 
268: - **subtasks**: List of smaller, more specific tasks (Example: `[{"id": 1, "title": "Configure OAuth", ...}]`) 
269: - Refer to task structure details (previously linked to `tasks.md`).
270: 
271: ## Configuration Management (Updated)
272: 
273: Taskmaster configuration is managed through two main mechanisms:
274: 
275: 1.  **`.taskmaster/config.json` File (Primary):**
276:     *   Located in the project root directory.
277:     *   Stores most configuration settings: AI model selections (main, research, fallback), parameters (max tokens, temperature), logging level, default subtasks/priority, project name, etc.
278:     *   **Tagged System Settings**: Includes `global.defaultTag` (defaults to "master") and `tags` section for tag management configuration.
279:     *   **Managed via `task-master models --setup` command.** Do not edit manually unless you know what you are doing.
280:     *   **View/Set specific models via `task-master models` command or `models` MCP tool.**
281:     *   Created automatically when you run `task-master models --setup` for the first time or during tagged system migration.
282: 
283: 2.  **Environment Variables (`.env` / `mcp.json`):**
284:     *   Used **only** for sensitive API keys and specific endpoint URLs.
285:     *   Place API keys (one per provider) in a `.env` file in the project root for CLI usage.
286:     *   For MCP/Trae integration, configure these keys in the `env` section of `.trae/mcp.json`.
287:     *   Available keys/variables: See `assets/env.example` or the Configuration section in the command reference (previously linked to `taskmaster.md`).
288: 
289: 3.  **`.taskmaster/state.json` File (Tagged System State):**
290:     *   Tracks current tag context and migration status.
291:     *   Automatically created during tagged system migration.
292:     *   Contains: `currentTag`, `lastSwitched`, `migrationNoticeShown`.
293: 
294: **Important:** Non-API key settings (like model selections, `MAX_TOKENS`, `TASKMASTER_LOG_LEVEL`) are **no longer configured via environment variables**. Use the `task-master models` command (or `--setup` for interactive configuration) or the `models` MCP tool.
295: **If AI commands FAIL in MCP** verify that the API key for the selected provider is present in the `env` section of `.trae/mcp.json`.
296: **If AI commands FAIL in CLI** verify that the API key for the selected provider is present in the `.env` file in the root of the project.
297: 
298: ## Rules Management
299: 
300: Taskmaster supports multiple AI coding assistant rule sets that can be configured during project initialization or managed afterward:
301: 
302: - **Available Profiles**: Claude Code, Cline, Codex, Trae, Roo Code, Trae, Windsurf (claude, cline, codex, trae, roo, trae, windsurf)
303: - **During Initialization**: Use `task-master init --rules trae,windsurf` to specify which rule sets to include
304: - **After Initialization**: Use `task-master rules add <profiles>` or `task-master rules remove <profiles>` to manage rule sets
305: - **Interactive Setup**: Use `task-master rules setup` to launch an interactive prompt for selecting rule profiles
306: - **Default Behavior**: If no `--rules` flag is specified during initialization, all available rule profiles are included
307: - **Rule Structure**: Each profile creates its own directory (e.g., `.trae/rules`, `.roo/rules`) with appropriate configuration files
308: 
309: ## Determining the Next Task
310: 
311: - Run `next_task` / `task-master next` to show the next task to work on.
312: - The command identifies tasks with all dependencies satisfied
313: - Tasks are prioritized by priority level, dependency count, and ID
314: - The command shows comprehensive task information including:
315:     - Basic task details and description
316:     - Implementation details
317:     - Subtasks (if they exist)
318:     - Contextual suggested actions
319: - Recommended before starting any new development work
320: - Respects your project's dependency structure
321: - Ensures tasks are completed in the appropriate sequence
322: - Provides ready-to-use commands for common task actions
323: 
324: ## Viewing Specific Task Details
325: 
326: - Run `get_task` / `task-master show <id>` to view a specific task.
327: - Use dot notation for subtasks: `task-master show 1.2` (shows subtask 2 of task 1)
328: - Displays comprehensive information similar to the next command, but for a specific task
329: - For parent tasks, shows all subtasks and their current status
330: - For subtasks, shows parent task information and relationship
331: - Provides contextual suggested actions appropriate for the specific task
332: - Useful for examining task details before implementation or checking status
333: 
334: ## Managing Task Dependencies
335: 
336: - Use `add_dependency` / `task-master add-dependency --id=<id> --depends-on=<id>` to add a dependency.
337: - Use `remove_dependency` / `task-master remove-dependency --id=<id> --depends-on=<id>` to remove a dependency.
338: - The system prevents circular dependencies and duplicate dependency entries
339: - Dependencies are checked for existence before being added or removed
340: - Task files are automatically regenerated after dependency changes
341: - Dependencies are visualized with status indicators in task listings and files
342: 
343: ## Task Reorganization
344: 
345: - Use `move_task` / `task-master move --from=<id> --to=<id>` to move tasks or subtasks within the hierarchy
346: - This command supports several use cases:
347:   - Moving a standalone task to become a subtask (e.g., `--from=5 --to=7`)
348:   - Moving a subtask to become a standalone task (e.g., `--from=5.2 --to=7`) 
349:   - Moving a subtask to a different parent (e.g., `--from=5.2 --to=7.3`)
350:   - Reordering subtasks within the same parent (e.g., `--from=5.2 --to=5.4`)
351:   - Moving a task to a new, non-existent ID position (e.g., `--from=5 --to=25`)
352:   - Moving multiple tasks at once using comma-separated IDs (e.g., `--from=10,11,12 --to=16,17,18`)
353: - The system includes validation to prevent data loss:
354:   - Allows moving to non-existent IDs by creating placeholder tasks
355:   - Prevents moving to existing task IDs that have content (to avoid overwriting)
356:   - Validates source tasks exist before attempting to move them
357: - The system maintains proper parent-child relationships and dependency integrity
358: - Task files are automatically regenerated after the move operation
359: - This provides greater flexibility in organizing and refining your task structure as project understanding evolves
360: - This is especially useful when dealing with potential merge conflicts arising from teams creating tasks on separate branches. Solve these conflicts very easily by moving your tasks and keeping theirs.
361: 
362: ## Iterative Subtask Implementation
363: 
364: Once a task has been broken down into subtasks using `expand_task` or similar methods, follow this iterative process for implementation:
365: 
366: 1.  **Understand the Goal (Preparation):**
367:     *   Use `get_task` / `task-master show <subtaskId>` (see @`taskmaster.md`) to thoroughly understand the specific goals and requirements of the subtask.
368: 
369: 2.  **Initial Exploration & Planning (Iteration 1):**
370:     *   This is the first attempt at creating a concrete implementation plan.
371:     *   Explore the codebase to identify the precise files, functions, and even specific lines of code that will need modification.
372:     *   Determine the intended code changes (diffs) and their locations.
373:     *   Gather *all* relevant details from this exploration phase.
374: 
375: 3.  **Log the Plan:**
376:     *   Run `update_subtask` / `task-master update-subtask --id=<subtaskId> --prompt='<detailed plan>'`.
377:     *   Provide the *complete and detailed* findings from the exploration phase in the prompt. Include file paths, line numbers, proposed diffs, reasoning, and any potential challenges identified. Do not omit details. The goal is to create a rich, timestamped log within the subtask's `details`.
378: 
379: 4.  **Verify the Plan:**
380:     *   Run `get_task` / `task-master show <subtaskId>` again to confirm that the detailed implementation plan has been successfully appended to the subtask's details.
381: 
382: 5.  **Begin Implementation:**
383:     *   Set the subtask status using `set_task_status` / `task-master set-status --id=<subtaskId> --status=in-progress`.
384:     *   Start coding based on the logged plan.
385: 
386: 6.  **Refine and Log Progress (Iteration 2+):**
387:     *   As implementation progresses, you will encounter challenges, discover nuances, or confirm successful approaches.
388:     *   **Before appending new information**: Briefly review the *existing* details logged in the subtask (using `get_task` or recalling from context) to ensure the update adds fresh insights and avoids redundancy.
389:     *   **Regularly** use `update_subtask` / `task-master update-subtask --id=<subtaskId> --prompt='<update details>\n- What worked...\n- What didn't work...'` to append new findings.
390:     *   **Crucially, log:**
391:         *   What worked ("fundamental truths" discovered).
392:         *   What didn't work and why (to avoid repeating mistakes).
393:         *   Specific code snippets or configurations that were successful.
394:         *   Decisions made, especially if confirmed with user input.
395:         *   Any deviations from the initial plan and the reasoning.
396:     *   The objective is to continuously enrich the subtask's details, creating a log of the implementation journey that helps the AI (and human developers) learn, adapt, and avoid repeating errors.
397: 
398: 7.  **Review & Update Rules (Post-Implementation):**
399:     *   Once the implementation for the subtask is functionally complete, review all code changes and the relevant chat history.
400:     *   Identify any new or modified code patterns, conventions, or best practices established during the implementation.
401:     *   Create new or update existing rules following internal guidelines (previously linked to `cursor_rules.md` and `self_improve.md`).
402: 
403: 8.  **Mark Task Complete:**
404:     *   After verifying the implementation and updating any necessary rules, mark the subtask as completed: `set_task_status` / `task-master set-status --id=<subtaskId> --status=done`.
405: 
406: 9.  **Commit Changes (If using Git):**
407:     *   Stage the relevant code changes and any updated/new rule files (`git add .`).
408:     *   Craft a comprehensive Git commit message summarizing the work done for the subtask, including both code implementation and any rule adjustments.
409:     *   Execute the commit command directly in the terminal (e.g., `git commit -m 'feat(module): Implement feature X for subtask <subtaskId>\n\n- Details about changes...\n- Updated rule Y for pattern Z'`).
410:     *   Consider if a Changeset is needed according to internal versioning guidelines (previously linked to `changeset.md`). If so, run `npm run changeset`, stage the generated file, and amend the commit or create a new one.
411: 
412: 10. **Proceed to Next Subtask:**
413:     *   Identify the next subtask (e.g., using `next_task` / `task-master next`).
414: 
415: ## Code Analysis & Refactoring Techniques
416: 
417: - **Top-Level Function Search**:
418:     - Useful for understanding module structure or planning refactors.
419:     - Use grep/ripgrep to find exported functions/constants:
420:       `rg "export (async function|function|const) \w+"` or similar patterns.
421:     - Can help compare functions between files during migrations or identify potential naming conflicts.
422: 
423: ---
424: *This workflow provides a general guideline. Adapt it based on your specific project needs and team practices.*
</file>

<file path=".trae/rules/self_improve.md">
 1: ---
 2: description: Guidelines for continuously improving Trae rules based on emerging code patterns and best practices.
 3: globs: **/*
 4: alwaysApply: true
 5: ---
 6: 
 7: - **Rule Improvement Triggers:**
 8:   - New code patterns not covered by existing rules
 9:   - Repeated similar implementations across files
10:   - Common error patterns that could be prevented
11:   - New libraries or tools being used consistently
12:   - Emerging best practices in the codebase
13: 
14: - **Analysis Process:**
15:   - Compare new code with existing rules
16:   - Identify patterns that should be standardized
17:   - Look for references to external documentation
18:   - Check for consistent error handling patterns
19:   - Monitor test patterns and coverage
20: 
21: - **Rule Updates:**
22:   - **Add New Rules When:**
23:     - A new technology/pattern is used in 3+ files
24:     - Common bugs could be prevented by a rule
25:     - Code reviews repeatedly mention the same feedback
26:     - New security or performance patterns emerge
27: 
28:   - **Modify Existing Rules When:**
29:     - Better examples exist in the codebase
30:     - Additional edge cases are discovered
31:     - Related rules have been updated
32:     - Implementation details have changed
33: 
34: - **Example Pattern Recognition:**
35:   ```typescript
36:   // If you see repeated patterns like:
37:   const data = await prisma.user.findMany({
38:     select: { id: true, email: true },
39:     where: { status: 'ACTIVE' }
40:   });
41:   
42:   // Consider adding to [prisma.md](.trae/rules/prisma.md):
43:   // - Standard select fields
44:   // - Common where conditions
45:   // - Performance optimization patterns
46:   ```
47: 
48: - **Rule Quality Checks:**
49:   - Rules should be actionable and specific
50:   - Examples should come from actual code
51:   - References should be up to date
52:   - Patterns should be consistently enforced
53: 
54: - **Continuous Improvement:**
55:   - Monitor code review comments
56:   - Track common development questions
57:   - Update rules after major refactors
58:   - Add links to relevant documentation
59:   - Cross-reference related rules
60: 
61: - **Rule Deprecation:**
62:   - Mark outdated patterns as deprecated
63:   - Remove rules that no longer apply
64:   - Update references to deprecated rules
65:   - Document migration paths for old patterns
66: 
67: - **Documentation Updates:**
68:   - Keep examples synchronized with code
69:   - Update references to external docs
70:   - Maintain links between related rules
71:   - Document breaking changes
72: Follow [trae_rules.md](.trae/rules/trae_rules.md) for proper rule formatting and structure.
</file>

<file path=".trae/rules/taskmaster.md">
  1: ---
  2: description: Comprehensive reference for Taskmaster MCP tools and CLI commands.
  3: globs: **/*
  4: alwaysApply: true
  5: ---
  6: 
  7: # Taskmaster Tool & Command Reference
  8: 
  9: This document provides a detailed reference for interacting with Taskmaster, covering both the recommended MCP tools, suitable for integrations like Trae, and the corresponding `task-master` CLI commands, designed for direct user interaction or fallback.
 10: 
 11: **Note:** For interacting with Taskmaster programmatically or via integrated tools, using the **MCP tools is strongly recommended** due to better performance, structured data, and error handling. The CLI commands serve as a user-friendly alternative and fallback. 
 12: 
 13: **Important:** Several MCP tools involve AI processing... The AI-powered tools include `parse_prd`, `analyze_project_complexity`, `update_subtask`, `update_task`, `update`, `expand_all`, `expand_task`, and `add_task`.
 14: 
 15: ** Tagged Task Lists System:** Task Master now supports **tagged task lists** for multi-context task management. This allows you to maintain separate, isolated lists of tasks for different features, branches, or experiments. Existing projects are seamlessly migrated to use a default "master" tag. Most commands now support a `--tag <name>` flag to specify which context to operate on. If omitted, commands use the currently active tag.
 16: 
 17: ---
 18: 
 19: ## Initialization & Setup
 20: 
 21: ### 1. Initialize Project (`init`)
 22: 
 23: *   **MCP Tool:** `initialize_project`
 24: *   **CLI Command:** `task-master init [options]`
 25: *   **Description:** `Set up the basic Taskmaster file structure and configuration in the current directory for a new project.`
 26: *   **Key CLI Options:**
 27:     *   `--name <name>`: `Set the name for your project in Taskmaster's configuration.`
 28:     *   `--description <text>`: `Provide a brief description for your project.`
 29:     *   `--version <version>`: `Set the initial version for your project, e.g., '0.1.0'.`
 30:     *   `-y, --yes`: `Initialize Taskmaster quickly using default settings without interactive prompts.`
 31: *   **Usage:** Run this once at the beginning of a new project.
 32: *   **MCP Variant Description:** `Set up the basic Taskmaster file structure and configuration in the current directory for a new project by running the 'task-master init' command.`
 33: *   **Key MCP Parameters/Options:**
 34:     *   `projectName`: `Set the name for your project.` (CLI: `--name <name>`)
 35:     *   `projectDescription`: `Provide a brief description for your project.` (CLI: `--description <text>`)
 36:     *   `projectVersion`: `Set the initial version for your project, e.g., '0.1.0'.` (CLI: `--version <version>`)
 37:     *   `authorName`: `Author name.` (CLI: `--author <author>`)
 38:     *   `skipInstall`: `Skip installing dependencies. Default is false.` (CLI: `--skip-install`)
 39:     *   `addAliases`: `Add shell aliases tm and taskmaster. Default is false.` (CLI: `--aliases`)
 40:     *   `yes`: `Skip prompts and use defaults/provided arguments. Default is false.` (CLI: `-y, --yes`)
 41: *   **Usage:** Run this once at the beginning of a new project, typically via an integrated tool like Trae. Operates on the current working directory of the MCP server. 
 42: *   **Important:** Once complete, you *MUST* parse a prd in order to generate tasks. There will be no tasks files until then. The next step after initializing should be to create a PRD using the example PRD in .taskmaster/templates/example_prd.txt. 
 43: *   **Tagging:** Use the `--tag` option to parse the PRD into a specific, non-default tag context. If the tag doesn't exist, it will be created automatically. Example: `task-master parse-prd spec.txt --tag=new-feature`.
 44: 
 45: ### 2. Parse PRD (`parse_prd`)
 46: 
 47: *   **MCP Tool:** `parse_prd`
 48: *   **CLI Command:** `task-master parse-prd [file] [options]`
 49: *   **Description:** `Parse a Product Requirements Document, PRD, or text file with Taskmaster to automatically generate an initial set of tasks in tasks.json.`
 50: *   **Key Parameters/Options:**
 51:     *   `input`: `Path to your PRD or requirements text file that Taskmaster should parse for tasks.` (CLI: `[file]` positional or `-i, --input <file>`)
 52:     *   `output`: `Specify where Taskmaster should save the generated 'tasks.json' file. Defaults to '.taskmaster/tasks/tasks.json'.` (CLI: `-o, --output <file>`)
 53:     *   `numTasks`: `Approximate number of top-level tasks Taskmaster should aim to generate from the document.` (CLI: `-n, --num-tasks <number>`)
 54:     *   `force`: `Use this to allow Taskmaster to overwrite an existing 'tasks.json' without asking for confirmation.` (CLI: `-f, --force`)
 55: *   **Usage:** Useful for bootstrapping a project from an existing requirements document.
 56: *   **Notes:** Task Master will strictly adhere to any specific requirements mentioned in the PRD, such as libraries, database schemas, frameworks, tech stacks, etc., while filling in any gaps where the PRD isn't fully specified. Tasks are designed to provide the most direct implementation path while avoiding over-engineering.
 57: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress. If the user does not have a PRD, suggest discussing their idea and then use the example PRD in `.taskmaster/templates/example_prd.txt` as a template for creating the PRD based on their idea, for use with `parse-prd`.
 58: 
 59: ---
 60: 
 61: ## AI Model Configuration
 62: 
 63: ### 2. Manage Models (`models`)
 64: *   **MCP Tool:** `models`
 65: *   **CLI Command:** `task-master models [options]`
 66: *   **Description:** `View the current AI model configuration or set specific models for different roles (main, research, fallback). Allows setting custom model IDs for Ollama and OpenRouter.`
 67: *   **Key MCP Parameters/Options:**
 68:     *   `setMain <model_id>`: `Set the primary model ID for task generation/updates.` (CLI: `--set-main <model_id>`)
 69:     *   `setResearch <model_id>`: `Set the model ID for research-backed operations.` (CLI: `--set-research <model_id>`)
 70:     *   `setFallback <model_id>`: `Set the model ID to use if the primary fails.` (CLI: `--set-fallback <model_id>`)
 71:     *   `ollama <boolean>`: `Indicates the set model ID is a custom Ollama model.` (CLI: `--ollama`)
 72:     *   `openrouter <boolean>`: `Indicates the set model ID is a custom OpenRouter model.` (CLI: `--openrouter`)
 73:     *   `listAvailableModels <boolean>`: `If true, lists available models not currently assigned to a role.` (CLI: No direct equivalent; CLI lists available automatically)
 74:     *   `projectRoot <string>`: `Optional. Absolute path to the project root directory.` (CLI: Determined automatically)
 75: *   **Key CLI Options:**
 76:     *   `--set-main <model_id>`: `Set the primary model.`
 77:     *   `--set-research <model_id>`: `Set the research model.`
 78:     *   `--set-fallback <model_id>`: `Set the fallback model.`
 79:     *   `--ollama`: `Specify that the provided model ID is for Ollama (use with --set-*).`
 80:     *   `--openrouter`: `Specify that the provided model ID is for OpenRouter (use with --set-*). Validates against OpenRouter API.`
 81:     *   `--bedrock`: `Specify that the provided model ID is for AWS Bedrock (use with --set-*).`
 82:     *   `--setup`: `Run interactive setup to configure models, including custom Ollama/OpenRouter IDs.`
 83: *   **Usage (MCP):** Call without set flags to get current config. Use `setMain`, `setResearch`, or `setFallback` with a valid model ID to update the configuration. Use `listAvailableModels: true` to get a list of unassigned models. To set a custom model, provide the model ID and set `ollama: true` or `openrouter: true`.
 84: *   **Usage (CLI):** Run without flags to view current configuration and available models. Use set flags to update specific roles. Use `--setup` for guided configuration, including custom models. To set a custom model via flags, use `--set-<role>=<model_id>` along with either `--ollama` or `--openrouter`.
 85: *   **Notes:** Configuration is stored in `.taskmaster/config.json` in the project root. This command/tool modifies that file. Use `listAvailableModels` or `task-master models` to see internally supported models. OpenRouter custom models are validated against their live API. Ollama custom models are not validated live.
 86: *   **API note:** API keys for selected AI providers (based on their model) need to exist in the mcp.json file to be accessible in MCP context. The API keys must be present in the local .env file for the CLI to be able to read them.
 87: *   **Model costs:** The costs in supported models are expressed in dollars. An input/output value of 3 is $3.00. A value of 0.8 is $0.80. 
 88: *   **Warning:** DO NOT MANUALLY EDIT THE .taskmaster/config.json FILE. Use the included commands either in the MCP or CLI format as needed. Always prioritize MCP tools when available and use the CLI as a fallback.
 89: 
 90: ---
 91: 
 92: ## Task Listing & Viewing
 93: 
 94: ### 3. Get Tasks (`get_tasks`)
 95: 
 96: *   **MCP Tool:** `get_tasks`
 97: *   **CLI Command:** `task-master list [options]`
 98: *   **Description:** `List your Taskmaster tasks, optionally filtering by status and showing subtasks.`
 99: *   **Key Parameters/Options:**
100:     *   `status`: `Show only Taskmaster tasks matching this status (or multiple statuses, comma-separated), e.g., 'pending' or 'done,in-progress'.` (CLI: `-s, --status <status>`)
101:     *   `withSubtasks`: `Include subtasks indented under their parent tasks in the list.` (CLI: `--with-subtasks`)
102:     *   `tag`: `Specify which tag context to list tasks from. Defaults to the current active tag.` (CLI: `--tag <name>`)
103:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
104: *   **Usage:** Get an overview of the project status, often used at the start of a work session.
105: 
106: ### 4. Get Next Task (`next_task`)
107: 
108: *   **MCP Tool:** `next_task`
109: *   **CLI Command:** `task-master next [options]`
110: *   **Description:** `Ask Taskmaster to show the next available task you can work on, based on status and completed dependencies.`
111: *   **Key Parameters/Options:**
112:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
113:     *   `tag`: `Specify which tag context to use. Defaults to the current active tag.` (CLI: `--tag <name>`)
114: *   **Usage:** Identify what to work on next according to the plan.
115: 
116: ### 5. Get Task Details (`get_task`)
117: 
118: *   **MCP Tool:** `get_task`
119: *   **CLI Command:** `task-master show [id] [options]`
120: *   **Description:** `Display detailed information for one or more specific Taskmaster tasks or subtasks by ID.`
121: *   **Key Parameters/Options:**
122:     *   `id`: `Required. The ID of the Taskmaster task (e.g., '15'), subtask (e.g., '15.2'), or a comma-separated list of IDs ('1,5,10.2') you want to view.` (CLI: `[id]` positional or `-i, --id <id>`)
123:     *   `tag`: `Specify which tag context to get the task(s) from. Defaults to the current active tag.` (CLI: `--tag <name>`)
124:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
125: *   **Usage:** Understand the full details for a specific task. When multiple IDs are provided, a summary table is shown.
126: *   **CRITICAL INFORMATION** If you need to collect information from multiple tasks, use comma-separated IDs (i.e. 1,2,3) to receive an array of tasks. Do not needlessly get tasks one at a time if you need to get many as that is wasteful.
127: 
128: ---
129: 
130: ## Task Creation & Modification
131: 
132: ### 6. Add Task (`add_task`)
133: 
134: *   **MCP Tool:** `add_task`
135: *   **CLI Command:** `task-master add-task [options]`
136: *   **Description:** `Add a new task to Taskmaster by describing it; AI will structure it.`
137: *   **Key Parameters/Options:**
138:     *   `prompt`: `Required. Describe the new task you want Taskmaster to create, e.g., "Implement user authentication using JWT".` (CLI: `-p, --prompt <text>`)
139:     *   `dependencies`: `Specify the IDs of any Taskmaster tasks that must be completed before this new one can start, e.g., '12,14'.` (CLI: `-d, --dependencies <ids>`)
140:     *   `priority`: `Set the priority for the new task: 'high', 'medium', or 'low'. Default is 'medium'.` (CLI: `--priority <priority>`)
141:     *   `research`: `Enable Taskmaster to use the research role for potentially more informed task creation.` (CLI: `-r, --research`)
142:     *   `tag`: `Specify which tag context to add the task to. Defaults to the current active tag.` (CLI: `--tag <name>`)
143:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
144: *   **Usage:** Quickly add newly identified tasks during development.
145: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
146: 
147: ### 7. Add Subtask (`add_subtask`)
148: 
149: *   **MCP Tool:** `add_subtask`
150: *   **CLI Command:** `task-master add-subtask [options]`
151: *   **Description:** `Add a new subtask to a Taskmaster parent task, or convert an existing task into a subtask.`
152: *   **Key Parameters/Options:**
153:     *   `id` / `parent`: `Required. The ID of the Taskmaster task that will be the parent.` (MCP: `id`, CLI: `-p, --parent <id>`)
154:     *   `taskId`: `Use this if you want to convert an existing top-level Taskmaster task into a subtask of the specified parent.` (CLI: `-i, --task-id <id>`)
155:     *   `title`: `Required if not using taskId. The title for the new subtask Taskmaster should create.` (CLI: `-t, --title <title>`)
156:     *   `description`: `A brief description for the new subtask.` (CLI: `-d, --description <text>`)
157:     *   `details`: `Provide implementation notes or details for the new subtask.` (CLI: `--details <text>`)
158:     *   `dependencies`: `Specify IDs of other tasks or subtasks, e.g., '15' or '16.1', that must be done before this new subtask.` (CLI: `--dependencies <ids>`)
159:     *   `status`: `Set the initial status for the new subtask. Default is 'pending'.` (CLI: `-s, --status <status>`)
160:     *   `skipGenerate`: `Prevent Taskmaster from automatically regenerating markdown task files after adding the subtask.` (CLI: `--skip-generate`)
161:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
162:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
163: *   **Usage:** Break down tasks manually or reorganize existing tasks.
164: 
165: ### 8. Update Tasks (`update`)
166: 
167: *   **MCP Tool:** `update`
168: *   **CLI Command:** `task-master update [options]`
169: *   **Description:** `Update multiple upcoming tasks in Taskmaster based on new context or changes, starting from a specific task ID.`
170: *   **Key Parameters/Options:**
171:     *   `from`: `Required. The ID of the first task Taskmaster should update. All tasks with this ID or higher that are not 'done' will be considered.` (CLI: `--from <id>`)
172:     *   `prompt`: `Required. Explain the change or new context for Taskmaster to apply to the tasks, e.g., "We are now using React Query instead of Redux Toolkit for data fetching".` (CLI: `-p, --prompt <text>`)
173:     *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
174:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
175:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
176: *   **Usage:** Handle significant implementation changes or pivots that affect multiple future tasks. Example CLI: `task-master update --from='18' --prompt='Switching to React Query.\nNeed to refactor data fetching...'`
177: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
178: 
179: ### 9. Update Task (`update_task`)
180: 
181: *   **MCP Tool:** `update_task`
182: *   **CLI Command:** `task-master update-task [options]`
183: *   **Description:** `Modify a specific Taskmaster task by ID, incorporating new information or changes. By default, this replaces the existing task details.`
184: *   **Key Parameters/Options:**
185:     *   `id`: `Required. The specific ID of the Taskmaster task, e.g., '15', you want to update.` (CLI: `-i, --id <id>`)
186:     *   `prompt`: `Required. Explain the specific changes or provide the new information Taskmaster should incorporate into this task.` (CLI: `-p, --prompt <text>`)
187:     *   `append`: `If true, appends the prompt content to the task's details with a timestamp, rather than replacing them. Behaves like update-subtask.` (CLI: `--append`)
188:     *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
189:     *   `tag`: `Specify which tag context the task belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
190:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
191: *   **Usage:** Refine a specific task based on new understanding. Use `--append` to log progress without creating subtasks.
192: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
193: 
194: ### 10. Update Subtask (`update_subtask`)
195: 
196: *   **MCP Tool:** `update_subtask`
197: *   **CLI Command:** `task-master update-subtask [options]`
198: *   **Description:** `Append timestamped notes or details to a specific Taskmaster subtask without overwriting existing content. Intended for iterative implementation logging.`
199: *   **Key Parameters/Options:**
200:     *   `id`: `Required. The ID of the Taskmaster subtask, e.g., '5.2', to update with new information.` (CLI: `-i, --id <id>`)
201:     *   `prompt`: `Required. The information, findings, or progress notes to append to the subtask's details with a timestamp.` (CLI: `-p, --prompt <text>`)
202:     *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
203:     *   `tag`: `Specify which tag context the subtask belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
204:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
205: *   **Usage:** Log implementation progress, findings, and discoveries during subtask development. Each update is timestamped and appended to preserve the implementation journey.
206: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
207: 
208: ### 11. Set Task Status (`set_task_status`)
209: 
210: *   **MCP Tool:** `set_task_status`
211: *   **CLI Command:** `task-master set-status [options]`
212: *   **Description:** `Update the status of one or more Taskmaster tasks or subtasks, e.g., 'pending', 'in-progress', 'done'.`
213: *   **Key Parameters/Options:**
214:     *   `id`: `Required. The ID(s) of the Taskmaster task(s) or subtask(s), e.g., '15', '15.2', or '16,17.1', to update.` (CLI: `-i, --id <id>`)
215:     *   `status`: `Required. The new status to set, e.g., 'done', 'pending', 'in-progress', 'review', 'cancelled'.` (CLI: `-s, --status <status>`)
216:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
217:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
218: *   **Usage:** Mark progress as tasks move through the development cycle.
219: 
220: ### 12. Remove Task (`remove_task`)
221: 
222: *   **MCP Tool:** `remove_task`
223: *   **CLI Command:** `task-master remove-task [options]`
224: *   **Description:** `Permanently remove a task or subtask from the Taskmaster tasks list.`
225: *   **Key Parameters/Options:**
226:     *   `id`: `Required. The ID of the Taskmaster task, e.g., '5', or subtask, e.g., '5.2', to permanently remove.` (CLI: `-i, --id <id>`)
227:     *   `yes`: `Skip the confirmation prompt and immediately delete the task.` (CLI: `-y, --yes`)
228:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
229:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
230: *   **Usage:** Permanently delete tasks or subtasks that are no longer needed in the project.
231: *   **Notes:** Use with caution as this operation cannot be undone. Consider using 'blocked', 'cancelled', or 'deferred' status instead if you just want to exclude a task from active planning but keep it for reference. The command automatically cleans up dependency references in other tasks.
232: 
233: ---
234: 
235: ## Task Structure & Breakdown
236: 
237: ### 13. Expand Task (`expand_task`)
238: 
239: *   **MCP Tool:** `expand_task`
240: *   **CLI Command:** `task-master expand [options]`
241: *   **Description:** `Use Taskmaster's AI to break down a complex task into smaller, manageable subtasks. Appends subtasks by default.`
242: *   **Key Parameters/Options:**
243:     *   `id`: `The ID of the specific Taskmaster task you want to break down into subtasks.` (CLI: `-i, --id <id>`)
244:     *   `num`: `Optional: Suggests how many subtasks Taskmaster should aim to create. Uses complexity analysis/defaults otherwise.` (CLI: `-n, --num <number>`)
245:     *   `research`: `Enable Taskmaster to use the research role for more informed subtask generation. Requires appropriate API key.` (CLI: `-r, --research`)
246:     *   `prompt`: `Optional: Provide extra context or specific instructions to Taskmaster for generating the subtasks.` (CLI: `-p, --prompt <text>`)
247:     *   `force`: `Optional: If true, clear existing subtasks before generating new ones. Default is false (append).` (CLI: `--force`)
248:     *   `tag`: `Specify which tag context the task belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
249:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
250: *   **Usage:** Generate a detailed implementation plan for a complex task before starting coding. Automatically uses complexity report recommendations if available and `num` is not specified.
251: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
252: 
253: ### 14. Expand All Tasks (`expand_all`)
254: 
255: *   **MCP Tool:** `expand_all`
256: *   **CLI Command:** `task-master expand --all [options]` (Note: CLI uses the `expand` command with the `--all` flag)
257: *   **Description:** `Tell Taskmaster to automatically expand all eligible pending/in-progress tasks based on complexity analysis or defaults. Appends subtasks by default.`
258: *   **Key Parameters/Options:**
259:     *   `num`: `Optional: Suggests how many subtasks Taskmaster should aim to create per task.` (CLI: `-n, --num <number>`)
260:     *   `research`: `Enable research role for more informed subtask generation. Requires appropriate API key.` (CLI: `-r, --research`)
261:     *   `prompt`: `Optional: Provide extra context for Taskmaster to apply generally during expansion.` (CLI: `-p, --prompt <text>`)
262:     *   `force`: `Optional: If true, clear existing subtasks before generating new ones for each eligible task. Default is false (append).` (CLI: `--force`)
263:     *   `tag`: `Specify which tag context to expand. Defaults to the current active tag.` (CLI: `--tag <name>`)
264:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
265: *   **Usage:** Useful after initial task generation or complexity analysis to break down multiple tasks at once.
266: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
267: 
268: ### 15. Clear Subtasks (`clear_subtasks`)
269: 
270: *   **MCP Tool:** `clear_subtasks`
271: *   **CLI Command:** `task-master clear-subtasks [options]`
272: *   **Description:** `Remove all subtasks from one or more specified Taskmaster parent tasks.`
273: *   **Key Parameters/Options:**
274:     *   `id`: `The ID(s) of the Taskmaster parent task(s) whose subtasks you want to remove, e.g., '15' or '16,18'. Required unless using `all`.) (CLI: `-i, --id <ids>`)
275:     *   `all`: `Tell Taskmaster to remove subtasks from all parent tasks.` (CLI: `--all`)
276:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
277:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
278: *   **Usage:** Used before regenerating subtasks with `expand_task` if the previous breakdown needs replacement.
279: 
280: ### 16. Remove Subtask (`remove_subtask`)
281: 
282: *   **MCP Tool:** `remove_subtask`
283: *   **CLI Command:** `task-master remove-subtask [options]`
284: *   **Description:** `Remove a subtask from its Taskmaster parent, optionally converting it into a standalone task.`
285: *   **Key Parameters/Options:**
286:     *   `id`: `Required. The ID(s) of the Taskmaster subtask(s) to remove, e.g., '15.2' or '16.1,16.3'.` (CLI: `-i, --id <id>`)
287:     *   `convert`: `If used, Taskmaster will turn the subtask into a regular top-level task instead of deleting it.` (CLI: `-c, --convert`)
288:     *   `skipGenerate`: `Prevent Taskmaster from automatically regenerating markdown task files after removing the subtask.` (CLI: `--skip-generate`)
289:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
290:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
291: *   **Usage:** Delete unnecessary subtasks or promote a subtask to a top-level task.
292: 
293: ### 17. Move Task (`move_task`)
294: 
295: *   **MCP Tool:** `move_task`
296: *   **CLI Command:** `task-master move [options]`
297: *   **Description:** `Move a task or subtask to a new position within the task hierarchy.`
298: *   **Key Parameters/Options:**
299:     *   `from`: `Required. ID of the task/subtask to move (e.g., "5" or "5.2"). Can be comma-separated for multiple tasks.` (CLI: `--from <id>`)
300:     *   `to`: `Required. ID of the destination (e.g., "7" or "7.3"). Must match the number of source IDs if comma-separated.` (CLI: `--to <id>`)
301:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
302:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
303: *   **Usage:** Reorganize tasks by moving them within the hierarchy. Supports various scenarios like:
304:     *   Moving a task to become a subtask
305:     *   Moving a subtask to become a standalone task
306:     *   Moving a subtask to a different parent
307:     *   Reordering subtasks within the same parent
308:     *   Moving a task to a new, non-existent ID (automatically creates placeholders)
309:     *   Moving multiple tasks at once with comma-separated IDs
310: *   **Validation Features:**
311:     *   Allows moving tasks to non-existent destination IDs (creates placeholder tasks)
312:     *   Prevents moving to existing task IDs that already have content (to avoid overwriting)
313:     *   Validates that source tasks exist before attempting to move them
314:     *   Maintains proper parent-child relationships
315: *   **Example CLI:** `task-master move --from=5.2 --to=7.3` to move subtask 5.2 to become subtask 7.3.
316: *   **Example Multi-Move:** `task-master move --from=10,11,12 --to=16,17,18` to move multiple tasks to new positions.
317: *   **Common Use:** Resolving merge conflicts in tasks.json when multiple team members create tasks on different branches.
318: 
319: ---
320: 
321: ## Dependency Management
322: 
323: ### 18. Add Dependency (`add_dependency`)
324: 
325: *   **MCP Tool:** `add_dependency`
326: *   **CLI Command:** `task-master add-dependency [options]`
327: *   **Description:** `Define a dependency in Taskmaster, making one task a prerequisite for another.`
328: *   **Key Parameters/Options:**
329:     *   `id`: `Required. The ID of the Taskmaster task that will depend on another.` (CLI: `-i, --id <id>`)
330:     *   `dependsOn`: `Required. The ID of the Taskmaster task that must be completed first, the prerequisite.` (CLI: `-d, --depends-on <id>`)
331:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
332:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <path>`)
333: *   **Usage:** Establish the correct order of execution between tasks.
334: 
335: ### 19. Remove Dependency (`remove_dependency`)
336: 
337: *   **MCP Tool:** `remove_dependency`
338: *   **CLI Command:** `task-master remove-dependency [options]`
339: *   **Description:** `Remove a dependency relationship between two Taskmaster tasks.`
340: *   **Key Parameters/Options:**
341:     *   `id`: `Required. The ID of the Taskmaster task you want to remove a prerequisite from.` (CLI: `-i, --id <id>`)
342:     *   `dependsOn`: `Required. The ID of the Taskmaster task that should no longer be a prerequisite.` (CLI: `-d, --depends-on <id>`)
343:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
344:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
345: *   **Usage:** Update task relationships when the order of execution changes.
346: 
347: ### 20. Validate Dependencies (`validate_dependencies`)
348: 
349: *   **MCP Tool:** `validate_dependencies`
350: *   **CLI Command:** `task-master validate-dependencies [options]`
351: *   **Description:** `Check your Taskmaster tasks for dependency issues (like circular references or links to non-existent tasks) without making changes.`
352: *   **Key Parameters/Options:**
353:     *   `tag`: `Specify which tag context to validate. Defaults to the current active tag.` (CLI: `--tag <name>`)
354:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
355: *   **Usage:** Audit the integrity of your task dependencies.
356: 
357: ### 21. Fix Dependencies (`fix_dependencies`)
358: 
359: *   **MCP Tool:** `fix_dependencies`
360: *   **CLI Command:** `task-master fix-dependencies [options]`
361: *   **Description:** `Automatically fix dependency issues (like circular references or links to non-existent tasks) in your Taskmaster tasks.`
362: *   **Key Parameters/Options:**
363:     *   `tag`: `Specify which tag context to fix dependencies in. Defaults to the current active tag.` (CLI: `--tag <name>`)
364:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
365: *   **Usage:** Clean up dependency errors automatically.
366: 
367: ---
368: 
369: ## Analysis & Reporting
370: 
371: ### 22. Analyze Project Complexity (`analyze_project_complexity`)
372: 
373: *   **MCP Tool:** `analyze_project_complexity`
374: *   **CLI Command:** `task-master analyze-complexity [options]`
375: *   **Description:** `Have Taskmaster analyze your tasks to determine their complexity and suggest which ones need to be broken down further.`
376: *   **Key Parameters/Options:**
377:     *   `output`: `Where to save the complexity analysis report. Default is '.taskmaster/reports/task-complexity-report.json' (or '..._tagname.json' if a tag is used).` (CLI: `-o, --output <file>`)
378:     *   `threshold`: `The minimum complexity score (1-10) that should trigger a recommendation to expand a task.` (CLI: `-t, --threshold <number>`)
379:     *   `research`: `Enable research role for more accurate complexity analysis. Requires appropriate API key.` (CLI: `-r, --research`)
380:     *   `tag`: `Specify which tag context to analyze. Defaults to the current active tag.` (CLI: `--tag <name>`)
381:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
382: *   **Usage:** Used before breaking down tasks to identify which ones need the most attention.
383: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
384: 
385: ### 23. View Complexity Report (`complexity_report`)
386: 
387: *   **MCP Tool:** `complexity_report`
388: *   **CLI Command:** `task-master complexity-report [options]`
389: *   **Description:** `Display the task complexity analysis report in a readable format.`
390: *   **Key Parameters/Options:**
391:     *   `tag`: `Specify which tag context to show the report for. Defaults to the current active tag.` (CLI: `--tag <name>`)
392:     *   `file`: `Path to the complexity report (default: '.taskmaster/reports/task-complexity-report.json').` (CLI: `-f, --file <file>`)
393: *   **Usage:** Review and understand the complexity analysis results after running analyze-complexity.
394: 
395: ---
396: 
397: ## File Management
398: 
399: ### 24. Generate Task Files (`generate`)
400: 
401: *   **MCP Tool:** `generate`
402: *   **CLI Command:** `task-master generate [options]`
403: *   **Description:** `Create or update individual Markdown files for each task based on your tasks.json.`
404: *   **Key Parameters/Options:**
405:     *   `output`: `The directory where Taskmaster should save the task files (default: in a 'tasks' directory).` (CLI: `-o, --output <directory>`)
406:     *   `tag`: `Specify which tag context to generate files for. Defaults to the current active tag.` (CLI: `--tag <name>`)
407:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
408: *   **Usage:** Run this after making changes to tasks.json to keep individual task files up to date. This command is now manual and no longer runs automatically.
409: 
410: ---
411: 
412: ## AI-Powered Research
413: 
414: ### 25. Research (`research`)
415: 
416: *   **MCP Tool:** `research`
417: *   **CLI Command:** `task-master research [options]`
418: *   **Description:** `Perform AI-powered research queries with project context to get fresh, up-to-date information beyond the AI's knowledge cutoff.`
419: *   **Key Parameters/Options:**
420:     *   `query`: `Required. Research query/prompt (e.g., "What are the latest best practices for React Query v5?").` (CLI: `[query]` positional or `-q, --query <text>`)
421:     *   `taskIds`: `Comma-separated list of task/subtask IDs from the current tag context (e.g., "15,16.2,17").` (CLI: `-i, --id <ids>`)
422:     *   `filePaths`: `Comma-separated list of file paths for context (e.g., "src/api.js,docs/readme.md").` (CLI: `-f, --files <paths>`)
423:     *   `customContext`: `Additional custom context text to include in the research.` (CLI: `-c, --context <text>`)
424:     *   `includeProjectTree`: `Include project file tree structure in context (default: false).` (CLI: `--tree`)
425:     *   `detailLevel`: `Detail level for the research response: 'low', 'medium', 'high' (default: medium).` (CLI: `--detail <level>`)
426:     *   `saveTo`: `Task or subtask ID (e.g., "15", "15.2") to automatically save the research conversation to.` (CLI: `--save-to <id>`)
427:     *   `saveFile`: `If true, saves the research conversation to a markdown file in '.taskmaster/docs/research/'.` (CLI: `--save-file`)
428:     *   `noFollowup`: `Disables the interactive follow-up question menu in the CLI.` (CLI: `--no-followup`)
429:     *   `tag`: `Specify which tag context to use for task-based context gathering. Defaults to the current active tag.` (CLI: `--tag <name>`)
430:     *   `projectRoot`: `The directory of the project. Must be an absolute path.` (CLI: Determined automatically)
431: *   **Usage:** **This is a POWERFUL tool that agents should use FREQUENTLY** to:
432:     *   Get fresh information beyond knowledge cutoff dates
433:     *   Research latest best practices, library updates, security patches
434:     *   Find implementation examples for specific technologies
435:     *   Validate approaches against current industry standards
436:     *   Get contextual advice based on project files and tasks
437: *   **When to Consider Using Research:**
438:     *   **Before implementing any task** - Research current best practices
439:     *   **When encountering new technologies** - Get up-to-date implementation guidance (libraries, apis, etc)
440:     *   **For security-related tasks** - Find latest security recommendations
441:     *   **When updating dependencies** - Research breaking changes and migration guides
442:     *   **For performance optimization** - Get current performance best practices
443:     *   **When debugging complex issues** - Research known solutions and workarounds
444: *   **Research + Action Pattern:**
445:     *   Use `research` to gather fresh information
446:     *   Use `update_subtask` to commit findings with timestamps
447:     *   Use `update_task` to incorporate research into task details
448:     *   Use `add_task` with research flag for informed task creation
449: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. The research provides FRESH data beyond the AI's training cutoff, making it invaluable for current best practices and recent developments.
450: 
451: ---
452: 
453: ## Tag Management
454: 
455: This new suite of commands allows you to manage different task contexts (tags).
456: 
457: ### 26. List Tags (`tags`)
458: 
459: *   **MCP Tool:** `list_tags`
460: *   **CLI Command:** `task-master tags [options]`
461: *   **Description:** `List all available tags with task counts, completion status, and other metadata.`
462: *   **Key Parameters/Options:**
463:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
464:     *   `--show-metadata`: `Include detailed metadata in the output (e.g., creation date, description).` (CLI: `--show-metadata`)
465: 
466: ### 27. Add Tag (`add_tag`)
467: 
468: *   **MCP Tool:** `add_tag`
469: *   **CLI Command:** `task-master add-tag <tagName> [options]`
470: *   **Description:** `Create a new, empty tag context, or copy tasks from another tag.`
471: *   **Key Parameters/Options:**
472:     *   `tagName`: `Name of the new tag to create (alphanumeric, hyphens, underscores).` (CLI: `<tagName>` positional)
473:     *   `--from-branch`: `Creates a tag with a name derived from the current git branch, ignoring the <tagName> argument.` (CLI: `--from-branch`)
474:     *   `--copy-from-current`: `Copy tasks from the currently active tag to the new tag.` (CLI: `--copy-from-current`)
475:     *   `--copy-from <tag>`: `Copy tasks from a specific source tag to the new tag.` (CLI: `--copy-from <tag>`)
476:     *   `--description <text>`: `Provide an optional description for the new tag.` (CLI: `-d, --description <text>`)
477:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
478: 
479: ### 28. Delete Tag (`delete_tag`)
480: 
481: *   **MCP Tool:** `delete_tag`
482: *   **CLI Command:** `task-master delete-tag <tagName> [options]`
483: *   **Description:** `Permanently delete a tag and all of its associated tasks.`
484: *   **Key Parameters/Options:**
485:     *   `tagName`: `Name of the tag to delete.` (CLI: `<tagName>` positional)
486:     *   `--yes`: `Skip the confirmation prompt.` (CLI: `-y, --yes`)
487:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
488: 
489: ### 29. Use Tag (`use_tag`)
490: 
491: *   **MCP Tool:** `use_tag`
492: *   **CLI Command:** `task-master use-tag <tagName>`
493: *   **Description:** `Switch your active task context to a different tag.`
494: *   **Key Parameters/Options:**
495:     *   `tagName`: `Name of the tag to switch to.` (CLI: `<tagName>` positional)
496:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
497: 
498: ### 30. Rename Tag (`rename_tag`)
499: 
500: *   **MCP Tool:** `rename_tag`
501: *   **CLI Command:** `task-master rename-tag <oldName> <newName>`
502: *   **Description:** `Rename an existing tag.`
503: *   **Key Parameters/Options:**
504:     *   `oldName`: `The current name of the tag.` (CLI: `<oldName>` positional)
505:     *   `newName`: `The new name for the tag.` (CLI: `<newName>` positional)
506:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
507: 
508: ### 31. Copy Tag (`copy_tag`)
509: 
510: *   **MCP Tool:** `copy_tag`
511: *   **CLI Command:** `task-master copy-tag <sourceName> <targetName> [options]`
512: *   **Description:** `Copy an entire tag context, including all its tasks and metadata, to a new tag.`
513: *   **Key Parameters/Options:**
514:     *   `sourceName`: `Name of the tag to copy from.` (CLI: `<sourceName>` positional)
515:     *   `targetName`: `Name of the new tag to create.` (CLI: `<targetName>` positional)
516:     *   `--description <text>`: `Optional description for the new tag.` (CLI: `-d, --description <text>`)
517: 
518: ---
519: 
520: ## Miscellaneous
521: 
522: ### 32. Sync Readme (`sync-readme`) -- experimental
523: 
524: *   **MCP Tool:** N/A
525: *   **CLI Command:** `task-master sync-readme [options]`
526: *   **Description:** `Exports your task list to your project's README.md file, useful for showcasing progress.`
527: *   **Key Parameters/Options:**
528:     *   `status`: `Filter tasks by status (e.g., 'pending', 'done').` (CLI: `-s, --status <status>`)
529:     *   `withSubtasks`: `Include subtasks in the export.` (CLI: `--with-subtasks`)
530:     *   `tag`: `Specify which tag context to export from. Defaults to the current active tag.` (CLI: `--tag <name>`)
531: 
532: ---
533: 
534: ## Environment Variables Configuration (Updated)
535: 
536: Taskmaster primarily uses the **`.taskmaster/config.json`** file (in project root) for configuration (models, parameters, logging level, etc.), managed via `task-master models --setup`.
537: 
538: Environment variables are used **only** for sensitive API keys related to AI providers and specific overrides like the Ollama base URL:
539: 
540: *   **API Keys (Required for corresponding provider):**
541:     *   `ANTHROPIC_API_KEY`
542:     *   `PERPLEXITY_API_KEY`
543:     *   `OPENAI_API_KEY`
544:     *   `GOOGLE_API_KEY`
545:     *   `MISTRAL_API_KEY`
546:     *   `AZURE_OPENAI_API_KEY` (Requires `AZURE_OPENAI_ENDPOINT` too)
547:     *   `OPENROUTER_API_KEY`
548:     *   `XAI_API_KEY`
549:     *   `OLLAMA_API_KEY` (Requires `OLLAMA_BASE_URL` too)
550: *   **Endpoints (Optional/Provider Specific inside .taskmaster/config.json):**
551:     *   `AZURE_OPENAI_ENDPOINT`
552:     *   `OLLAMA_BASE_URL` (Default: `http://localhost:11434/api`)
553: 
554: **Set API keys** in your **`.env`** file in the project root (for CLI use) or within the `env` section of your **`.trae/mcp.json`** file (for MCP/Trae integration). All other settings (model choice, max tokens, temperature, log level, custom endpoints) are managed in `.taskmaster/config.json` via `task-master models` command or `models` MCP tool.
555: 
556: ---
557: 
558: For details on how these commands fit into the development process, see the [dev_workflow.md](.trae/rules/dev_workflow.md).
</file>

<file path=".trae/rules/trae_rules.md">
 1: ---
 2: description: Guidelines for creating and maintaining Trae rules to ensure consistency and effectiveness.
 3: globs: .trae/rules/*.md
 4: alwaysApply: true
 5: ---
 6: 
 7: - **Required Rule Structure:**
 8:   ```markdown
 9:   ---
10:   description: Clear, one-line description of what the rule enforces
11:   globs: path/to/files/*.ext, other/path/**/*
12:   alwaysApply: boolean
13:   ---
14: 
15:   - **Main Points in Bold**
16:     - Sub-points with details
17:     - Examples and explanations
18:   ```
19: 
20: - **File References:**
21:   - Use `[filename](mdc:path/to/file)` ([filename](mdc:filename)) to reference files
22:   - Example: [prisma.md](.trae/rules/prisma.md) for rule references
23:   - Example: [schema.prisma](mdc:prisma/schema.prisma) for code references
24: 
25: - **Code Examples:**
26:   - Use language-specific code blocks
27:   ```typescript
28:   //  DO: Show good examples
29:   const goodExample = true;
30:   
31:   //  DON'T: Show anti-patterns
32:   const badExample = false;
33:   ```
34: 
35: - **Rule Content Guidelines:**
36:   - Start with high-level overview
37:   - Include specific, actionable requirements
38:   - Show examples of correct implementation
39:   - Reference existing code when possible
40:   - Keep rules DRY by referencing other rules
41: 
42: - **Rule Maintenance:**
43:   - Update rules when new patterns emerge
44:   - Add examples from actual codebase
45:   - Remove outdated patterns
46:   - Cross-reference related rules
47: 
48: - **Best Practices:**
49:   - Use bullet points for clarity
50:   - Keep descriptions concise
51:   - Include both DO and DON'T examples
52:   - Reference actual code over theoretical examples
53:   - Use consistent formatting across rules
</file>

<file path=".windsurf/rules/dev_workflow.md">
  1: ---
  2: description: Guide for using Taskmaster to manage task-driven development workflows
  3: globs: **/*
  4: alwaysApply: true
  5: ---
  6: 
  7: # Taskmaster Development Workflow
  8: 
  9: This guide outlines the standard process for using Taskmaster to manage software development projects. It is written as a set of instructions for you, the AI agent.
 10: 
 11: - **Your Default Stance**: For most projects, the user can work directly within the `master` task context. Your initial actions should operate on this default context unless a clear pattern for multi-context work emerges.
 12: - **Your Goal**: Your role is to elevate the user's workflow by intelligently introducing advanced features like **Tagged Task Lists** when you detect the appropriate context. Do not force tags on the user; suggest them as a helpful solution to a specific need.
 13: 
 14: ## The Basic Loop
 15: The fundamental development cycle you will facilitate is:
 16: 1.  **`list`**: Show the user what needs to be done.
 17: 2.  **`next`**: Help the user decide what to work on.
 18: 3.  **`show <id>`**: Provide details for a specific task.
 19: 4.  **`expand <id>`**: Break down a complex task into smaller, manageable subtasks.
 20: 5.  **Implement**: The user writes the code and tests.
 21: 6.  **`update-subtask`**: Log progress and findings on behalf of the user.
 22: 7.  **`set-status`**: Mark tasks and subtasks as `done` as work is completed.
 23: 8.  **Repeat**.
 24: 
 25: All your standard command executions should operate on the user's current task context, which defaults to `master`.
 26: 
 27: ---
 28: 
 29: ## Standard Development Workflow Process
 30: 
 31: ### Simple Workflow (Default Starting Point)
 32: 
 33: For new projects or when users are getting started, operate within the `master` tag context:
 34: 
 35: -   Start new projects by running `initialize_project` tool / `task-master init` or `parse_prd` / `task-master parse-prd --input='<prd-file.txt>'` (see @`taskmaster.md`) to generate initial tasks.json with tagged structure
 36: -   Configure rule sets during initialization with `--rules` flag (e.g., `task-master init --rules windsurf,windsurf`) or manage them later with `task-master rules add/remove` commands  
 37: -   Begin coding sessions with `get_tasks` / `task-master list` (see @`taskmaster.md`) to see current tasks, status, and IDs
 38: -   Determine the next task to work on using `next_task` / `task-master next` (see @`taskmaster.md`)
 39: -   Analyze task complexity with `analyze_project_complexity` / `task-master analyze-complexity --research` (see @`taskmaster.md`) before breaking down tasks
 40: -   Review complexity report using `complexity_report` / `task-master complexity-report` (see @`taskmaster.md`)
 41: -   Select tasks based on dependencies (all marked 'done'), priority level, and ID order
 42: -   View specific task details using `get_task` / `task-master show <id>` (see @`taskmaster.md`) to understand implementation requirements
 43: -   Break down complex tasks using `expand_task` / `task-master expand --id=<id> --force --research` (see @`taskmaster.md`) with appropriate flags like `--force` (to replace existing subtasks) and `--research`
 44: -   Implement code following task details, dependencies, and project standards
 45: -   Mark completed tasks with `set_task_status` / `task-master set-status --id=<id> --status=done` (see @`taskmaster.md`)
 46: -   Update dependent tasks when implementation differs from original plan using `update` / `task-master update --from=<id> --prompt="..."` or `update_task` / `task-master update-task --id=<id> --prompt="..."` (see @`taskmaster.md`)
 47: 
 48: ---
 49: 
 50: ## Leveling Up: Agent-Led Multi-Context Workflows
 51: 
 52: While the basic workflow is powerful, your primary opportunity to add value is by identifying when to introduce **Tagged Task Lists**. These patterns are your tools for creating a more organized and efficient development environment for the user, especially if you detect agentic or parallel development happening across the same session.
 53: 
 54: **Critical Principle**: Most users should never see a difference in their experience. Only introduce advanced workflows when you detect clear indicators that the project has evolved beyond simple task management.
 55: 
 56: ### When to Introduce Tags: Your Decision Patterns
 57: 
 58: Here are the patterns to look for. When you detect one, you should propose the corresponding workflow to the user.
 59: 
 60: #### Pattern 1: Simple Git Feature Branching
 61: This is the most common and direct use case for tags.
 62: 
 63: - **Trigger**: The user creates a new git branch (e.g., `git checkout -b feature/user-auth`).
 64: - **Your Action**: Propose creating a new tag that mirrors the branch name to isolate the feature's tasks from `master`.
 65: - **Your Suggested Prompt**: *"I see you've created a new branch named 'feature/user-auth'. To keep all related tasks neatly organized and separate from your main list, I can create a corresponding task tag for you. This helps prevent merge conflicts in your `tasks.json` file later. Shall I create the 'feature-user-auth' tag?"*
 66: - **Tool to Use**: `task-master add-tag --from-branch`
 67: 
 68: #### Pattern 2: Team Collaboration
 69: - **Trigger**: The user mentions working with teammates (e.g., "My teammate Alice is handling the database schema," or "I need to review Bob's work on the API.").
 70: - **Your Action**: Suggest creating a separate tag for the user's work to prevent conflicts with shared master context.
 71: - **Your Suggested Prompt**: *"Since you're working with Alice, I can create a separate task context for your work to avoid conflicts. This way, Alice can continue working with the master list while you have your own isolated context. When you're ready to merge your work, we can coordinate the tasks back to master. Shall I create a tag for your current work?"*
 72: - **Tool to Use**: `task-master add-tag my-work --copy-from-current --description="My tasks while collaborating with Alice"`
 73: 
 74: #### Pattern 3: Experiments or Risky Refactors
 75: - **Trigger**: The user wants to try something that might not be kept (e.g., "I want to experiment with switching our state management library," or "Let's refactor the old API module, but I want to keep the current tasks as a reference.").
 76: - **Your Action**: Propose creating a sandboxed tag for the experimental work.
 77: - **Your Suggested Prompt**: *"This sounds like a great experiment. To keep these new tasks separate from our main plan, I can create a temporary 'experiment-zustand' tag for this work. If we decide not to proceed, we can simply delete the tag without affecting the main task list. Sound good?"*
 78: - **Tool to Use**: `task-master add-tag experiment-zustand --description="Exploring Zustand migration"`
 79: 
 80: #### Pattern 4: Large Feature Initiatives (PRD-Driven)
 81: This is a more structured approach for significant new features or epics.
 82: 
 83: - **Trigger**: The user describes a large, multi-step feature that would benefit from a formal plan.
 84: - **Your Action**: Propose a comprehensive, PRD-driven workflow.
 85: - **Your Suggested Prompt**: *"This sounds like a significant new feature. To manage this effectively, I suggest we create a dedicated task context for it. Here's the plan: I'll create a new tag called 'feature-xyz', then we can draft a Product Requirements Document (PRD) together to scope the work. Once the PRD is ready, I'll automatically generate all the necessary tasks within that new tag. How does that sound?"*
 86: - **Your Implementation Flow**:
 87:     1.  **Create an empty tag**: `task-master add-tag feature-xyz --description "Tasks for the new XYZ feature"`. You can also start by creating a git branch if applicable, and then create the tag from that branch.
 88:     2.  **Collaborate & Create PRD**: Work with the user to create a detailed PRD file (e.g., `.taskmaster/docs/feature-xyz-prd.txt`).
 89:     3.  **Parse PRD into the new tag**: `task-master parse-prd .taskmaster/docs/feature-xyz-prd.txt --tag feature-xyz`
 90:     4.  **Prepare the new task list**: Follow up by suggesting `analyze-complexity` and `expand-all` for the newly created tasks within the `feature-xyz` tag.
 91: 
 92: #### Pattern 5: Version-Based Development
 93: Tailor your approach based on the project maturity indicated by tag names.
 94: 
 95: - **Prototype/MVP Tags** (`prototype`, `mvp`, `poc`, `v0.x`):
 96:   - **Your Approach**: Focus on speed and functionality over perfection
 97:   - **Task Generation**: Create tasks that emphasize "get it working" over "get it perfect"
 98:   - **Complexity Level**: Lower complexity, fewer subtasks, more direct implementation paths
 99:   - **Research Prompts**: Include context like "This is a prototype - prioritize speed and basic functionality over optimization"
100:   - **Example Prompt Addition**: *"Since this is for the MVP, I'll focus on tasks that get core functionality working quickly rather than over-engineering."*
101: 
102: - **Production/Mature Tags** (`v1.0+`, `production`, `stable`):
103:   - **Your Approach**: Emphasize robustness, testing, and maintainability
104:   - **Task Generation**: Include comprehensive error handling, testing, documentation, and optimization
105:   - **Complexity Level**: Higher complexity, more detailed subtasks, thorough implementation paths
106:   - **Research Prompts**: Include context like "This is for production - prioritize reliability, performance, and maintainability"
107:   - **Example Prompt Addition**: *"Since this is for production, I'll ensure tasks include proper error handling, testing, and documentation."*
108: 
109: ### Advanced Workflow (Tag-Based & PRD-Driven)
110: 
111: **When to Transition**: Recognize when the project has evolved (or has initiated a project which existing code) beyond simple task management. Look for these indicators:
112: - User mentions teammates or collaboration needs
113: - Project has grown to 15+ tasks with mixed priorities
114: - User creates feature branches or mentions major initiatives
115: - User initializes Taskmaster on an existing, complex codebase
116: - User describes large features that would benefit from dedicated planning
117: 
118: **Your Role in Transition**: Guide the user to a more sophisticated workflow that leverages tags for organization and PRDs for comprehensive planning.
119: 
120: #### Master List Strategy (High-Value Focus)
121: Once you transition to tag-based workflows, the `master` tag should ideally contain only:
122: - **High-level deliverables** that provide significant business value
123: - **Major milestones** and epic-level features
124: - **Critical infrastructure** work that affects the entire project
125: - **Release-blocking** items
126: 
127: **What NOT to put in master**:
128: - Detailed implementation subtasks (these go in feature-specific tags' parent tasks)
129: - Refactoring work (create dedicated tags like `refactor-auth`)
130: - Experimental features (use `experiment-*` tags)
131: - Team member-specific tasks (use person-specific tags)
132: 
133: #### PRD-Driven Feature Development
134: 
135: **For New Major Features**:
136: 1. **Identify the Initiative**: When user describes a significant feature
137: 2. **Create Dedicated Tag**: `add_tag feature-[name] --description="[Feature description]"`
138: 3. **Collaborative PRD Creation**: Work with user to create comprehensive PRD in `.taskmaster/docs/feature-[name]-prd.txt`
139: 4. **Parse & Prepare**: 
140:    - `parse_prd .taskmaster/docs/feature-[name]-prd.txt --tag=feature-[name]`
141:    - `analyze_project_complexity --tag=feature-[name] --research`
142:    - `expand_all --tag=feature-[name] --research`
143: 5. **Add Master Reference**: Create a high-level task in `master` that references the feature tag
144: 
145: **For Existing Codebase Analysis**:
146: When users initialize Taskmaster on existing projects:
147: 1. **Codebase Discovery**: Use your native tools for producing deep context about the code base. You may use `research` tool with `--tree` and `--files` to collect up to date information using the existing architecture as context.
148: 2. **Collaborative Assessment**: Work with user to identify improvement areas, technical debt, or new features
149: 3. **Strategic PRD Creation**: Co-author PRDs that include:
150:    - Current state analysis (based on your codebase research)
151:    - Proposed improvements or new features
152:    - Implementation strategy considering existing code
153: 4. **Tag-Based Organization**: Parse PRDs into appropriate tags (`refactor-api`, `feature-dashboard`, `tech-debt`, etc.)
154: 5. **Master List Curation**: Keep only the most valuable initiatives in master
155: 
156: The parse-prd's `--append` flag enables the user to parse multple PRDs within tags or across tags. PRDs should be focused and the number of tasks they are parsed into should be strategically chosen relative to the PRD's complexity and level of detail.
157: 
158: ### Workflow Transition Examples
159: 
160: **Example 1: Simple  Team-Based**
161: ```
162: User: "Alice is going to help with the API work"
163: Your Response: "Great! To avoid conflicts, I'll create a separate task context for your work. Alice can continue with the master list while you work in your own context. When you're ready to merge, we can coordinate the tasks back together."
164: Action: add_tag my-api-work --copy-from-current --description="My API tasks while collaborating with Alice"
165: ```
166: 
167: **Example 2: Simple  PRD-Driven**
168: ```
169: User: "I want to add a complete user dashboard with analytics, user management, and reporting"
170: Your Response: "This sounds like a major feature that would benefit from detailed planning. Let me create a dedicated context for this work and we can draft a PRD together to ensure we capture all requirements."
171: Actions: 
172: 1. add_tag feature-dashboard --description="User dashboard with analytics and management"
173: 2. Collaborate on PRD creation
174: 3. parse_prd dashboard-prd.txt --tag=feature-dashboard
175: 4. Add high-level "User Dashboard" task to master
176: ```
177: 
178: **Example 3: Existing Project  Strategic Planning**
179: ```
180: User: "I just initialized Taskmaster on my existing React app. It's getting messy and I want to improve it."
181: Your Response: "Let me research your codebase to understand the current architecture, then we can create a strategic plan for improvements."
182: Actions:
183: 1. research "Current React app architecture and improvement opportunities" --tree --files=src/
184: 2. Collaborate on improvement PRD based on findings
185: 3. Create tags for different improvement areas (refactor-components, improve-state-management, etc.)
186: 4. Keep only major improvement initiatives in master
187: ```
188: 
189: ---
190: 
191: ## Primary Interaction: MCP Server vs. CLI
192: 
193: Taskmaster offers two primary ways to interact:
194: 
195: 1.  **MCP Server (Recommended for Integrated Tools)**:
196:     - For AI agents and integrated development environments (like Windsurf), interacting via the **MCP server is the preferred method**.
197:     - The MCP server exposes Taskmaster functionality through a set of tools (e.g., `get_tasks`, `add_subtask`).
198:     - This method offers better performance, structured data exchange, and richer error handling compared to CLI parsing.
199:     - Refer to @`mcp.md` for details on the MCP architecture and available tools.
200:     - A comprehensive list and description of MCP tools and their corresponding CLI commands can be found in @`taskmaster.md`.
201:     - **Restart the MCP server** if core logic in `scripts/modules` or MCP tool/direct function definitions change.
202:     - **Note**: MCP tools fully support tagged task lists with complete tag management capabilities.
203: 
204: 2.  **`task-master` CLI (For Users & Fallback)**:
205:     - The global `task-master` command provides a user-friendly interface for direct terminal interaction.
206:     - It can also serve as a fallback if the MCP server is inaccessible or a specific function isn't exposed via MCP.
207:     - Install globally with `npm install -g task-master-ai` or use locally via `npx task-master-ai ...`.
208:     - The CLI commands often mirror the MCP tools (e.g., `task-master list` corresponds to `get_tasks`).
209:     - Refer to @`taskmaster.md` for a detailed command reference.
210:     - **Tagged Task Lists**: CLI fully supports the new tagged system with seamless migration.
211: 
212: ## How the Tag System Works (For Your Reference)
213: 
214: - **Data Structure**: Tasks are organized into separate contexts (tags) like "master", "feature-branch", or "v2.0".
215: - **Silent Migration**: Existing projects automatically migrate to use a "master" tag with zero disruption.
216: - **Context Isolation**: Tasks in different tags are completely separate. Changes in one tag do not affect any other tag.
217: - **Manual Control**: The user is always in control. There is no automatic switching. You facilitate switching by using `use-tag <name>`.
218: - **Full CLI & MCP Support**: All tag management commands are available through both the CLI and MCP tools for you to use. Refer to @`taskmaster.md` for a full command list.
219: 
220: ---
221: 
222: ## Task Complexity Analysis
223: 
224: -   Run `analyze_project_complexity` / `task-master analyze-complexity --research` (see @`taskmaster.md`) for comprehensive analysis
225: -   Review complexity report via `complexity_report` / `task-master complexity-report` (see @`taskmaster.md`) for a formatted, readable version.
226: -   Focus on tasks with highest complexity scores (8-10) for detailed breakdown
227: -   Use analysis results to determine appropriate subtask allocation
228: -   Note that reports are automatically used by the `expand_task` tool/command
229: 
230: ## Task Breakdown Process
231: 
232: -   Use `expand_task` / `task-master expand --id=<id>`. It automatically uses the complexity report if found, otherwise generates default number of subtasks.
233: -   Use `--num=<number>` to specify an explicit number of subtasks, overriding defaults or complexity report recommendations.
234: -   Add `--research` flag to leverage Perplexity AI for research-backed expansion.
235: -   Add `--force` flag to clear existing subtasks before generating new ones (default is to append).
236: -   Use `--prompt="<context>"` to provide additional context when needed.
237: -   Review and adjust generated subtasks as necessary.
238: -   Use `expand_all` tool or `task-master expand --all` to expand multiple pending tasks at once, respecting flags like `--force` and `--research`.
239: -   If subtasks need complete replacement (regardless of the `--force` flag on `expand`), clear them first with `clear_subtasks` / `task-master clear-subtasks --id=<id>`.
240: 
241: ## Implementation Drift Handling
242: 
243: -   When implementation differs significantly from planned approach
244: -   When future tasks need modification due to current implementation choices
245: -   When new dependencies or requirements emerge
246: -   Use `update` / `task-master update --from=<futureTaskId> --prompt='<explanation>\nUpdate context...' --research` to update multiple future tasks.
247: -   Use `update_task` / `task-master update-task --id=<taskId> --prompt='<explanation>\nUpdate context...' --research` to update a single specific task.
248: 
249: ## Task Status Management
250: 
251: -   Use 'pending' for tasks ready to be worked on
252: -   Use 'done' for completed and verified tasks
253: -   Use 'deferred' for postponed tasks
254: -   Add custom status values as needed for project-specific workflows
255: 
256: ## Task Structure Fields
257: 
258: - **id**: Unique identifier for the task (Example: `1`, `1.1`)
259: - **title**: Brief, descriptive title (Example: `"Initialize Repo"`)
260: - **description**: Concise summary of what the task involves (Example: `"Create a new repository, set up initial structure."`)
261: - **status**: Current state of the task (Example: `"pending"`, `"done"`, `"deferred"`)
262: - **dependencies**: IDs of prerequisite tasks (Example: `[1, 2.1]`)
263:     - Dependencies are displayed with status indicators ( for completed,  for pending)
264:     - This helps quickly identify which prerequisite tasks are blocking work
265: - **priority**: Importance level (Example: `"high"`, `"medium"`, `"low"`)
266: - **details**: In-depth implementation instructions (Example: `"Use GitHub client ID/secret, handle callback, set session token."`) 
267: - **testStrategy**: Verification approach (Example: `"Deploy and call endpoint to confirm 'Hello World' response."`) 
268: - **subtasks**: List of smaller, more specific tasks (Example: `[{"id": 1, "title": "Configure OAuth", ...}]`) 
269: - Refer to task structure details (previously linked to `tasks.md`).
270: 
271: ## Configuration Management (Updated)
272: 
273: Taskmaster configuration is managed through two main mechanisms:
274: 
275: 1.  **`.taskmaster/config.json` File (Primary):**
276:     *   Located in the project root directory.
277:     *   Stores most configuration settings: AI model selections (main, research, fallback), parameters (max tokens, temperature), logging level, default subtasks/priority, project name, etc.
278:     *   **Tagged System Settings**: Includes `global.defaultTag` (defaults to "master") and `tags` section for tag management configuration.
279:     *   **Managed via `task-master models --setup` command.** Do not edit manually unless you know what you are doing.
280:     *   **View/Set specific models via `task-master models` command or `models` MCP tool.**
281:     *   Created automatically when you run `task-master models --setup` for the first time or during tagged system migration.
282: 
283: 2.  **Environment Variables (`.env` / `mcp.json`):**
284:     *   Used **only** for sensitive API keys and specific endpoint URLs.
285:     *   Place API keys (one per provider) in a `.env` file in the project root for CLI usage.
286:     *   For MCP/Windsurf integration, configure these keys in the `env` section of `.windsurf/mcp.json`.
287:     *   Available keys/variables: See `assets/env.example` or the Configuration section in the command reference (previously linked to `taskmaster.md`).
288: 
289: 3.  **`.taskmaster/state.json` File (Tagged System State):**
290:     *   Tracks current tag context and migration status.
291:     *   Automatically created during tagged system migration.
292:     *   Contains: `currentTag`, `lastSwitched`, `migrationNoticeShown`.
293: 
294: **Important:** Non-API key settings (like model selections, `MAX_TOKENS`, `TASKMASTER_LOG_LEVEL`) are **no longer configured via environment variables**. Use the `task-master models` command (or `--setup` for interactive configuration) or the `models` MCP tool.
295: **If AI commands FAIL in MCP** verify that the API key for the selected provider is present in the `env` section of `.windsurf/mcp.json`.
296: **If AI commands FAIL in CLI** verify that the API key for the selected provider is present in the `.env` file in the root of the project.
297: 
298: ## Rules Management
299: 
300: Taskmaster supports multiple AI coding assistant rule sets that can be configured during project initialization or managed afterward:
301: 
302: - **Available Profiles**: Claude Code, Cline, Codex, Windsurf, Roo Code, Trae, Windsurf (claude, cline, codex, windsurf, roo, trae, windsurf)
303: - **During Initialization**: Use `task-master init --rules windsurf,windsurf` to specify which rule sets to include
304: - **After Initialization**: Use `task-master rules add <profiles>` or `task-master rules remove <profiles>` to manage rule sets
305: - **Interactive Setup**: Use `task-master rules setup` to launch an interactive prompt for selecting rule profiles
306: - **Default Behavior**: If no `--rules` flag is specified during initialization, all available rule profiles are included
307: - **Rule Structure**: Each profile creates its own directory (e.g., `.windsurf/rules`, `.roo/rules`) with appropriate configuration files
308: 
309: ## Determining the Next Task
310: 
311: - Run `next_task` / `task-master next` to show the next task to work on.
312: - The command identifies tasks with all dependencies satisfied
313: - Tasks are prioritized by priority level, dependency count, and ID
314: - The command shows comprehensive task information including:
315:     - Basic task details and description
316:     - Implementation details
317:     - Subtasks (if they exist)
318:     - Contextual suggested actions
319: - Recommended before starting any new development work
320: - Respects your project's dependency structure
321: - Ensures tasks are completed in the appropriate sequence
322: - Provides ready-to-use commands for common task actions
323: 
324: ## Viewing Specific Task Details
325: 
326: - Run `get_task` / `task-master show <id>` to view a specific task.
327: - Use dot notation for subtasks: `task-master show 1.2` (shows subtask 2 of task 1)
328: - Displays comprehensive information similar to the next command, but for a specific task
329: - For parent tasks, shows all subtasks and their current status
330: - For subtasks, shows parent task information and relationship
331: - Provides contextual suggested actions appropriate for the specific task
332: - Useful for examining task details before implementation or checking status
333: 
334: ## Managing Task Dependencies
335: 
336: - Use `add_dependency` / `task-master add-dependency --id=<id> --depends-on=<id>` to add a dependency.
337: - Use `remove_dependency` / `task-master remove-dependency --id=<id> --depends-on=<id>` to remove a dependency.
338: - The system prevents circular dependencies and duplicate dependency entries
339: - Dependencies are checked for existence before being added or removed
340: - Task files are automatically regenerated after dependency changes
341: - Dependencies are visualized with status indicators in task listings and files
342: 
343: ## Task Reorganization
344: 
345: - Use `move_task` / `task-master move --from=<id> --to=<id>` to move tasks or subtasks within the hierarchy
346: - This command supports several use cases:
347:   - Moving a standalone task to become a subtask (e.g., `--from=5 --to=7`)
348:   - Moving a subtask to become a standalone task (e.g., `--from=5.2 --to=7`) 
349:   - Moving a subtask to a different parent (e.g., `--from=5.2 --to=7.3`)
350:   - Reordering subtasks within the same parent (e.g., `--from=5.2 --to=5.4`)
351:   - Moving a task to a new, non-existent ID position (e.g., `--from=5 --to=25`)
352:   - Moving multiple tasks at once using comma-separated IDs (e.g., `--from=10,11,12 --to=16,17,18`)
353: - The system includes validation to prevent data loss:
354:   - Allows moving to non-existent IDs by creating placeholder tasks
355:   - Prevents moving to existing task IDs that have content (to avoid overwriting)
356:   - Validates source tasks exist before attempting to move them
357: - The system maintains proper parent-child relationships and dependency integrity
358: - Task files are automatically regenerated after the move operation
359: - This provides greater flexibility in organizing and refining your task structure as project understanding evolves
360: - This is especially useful when dealing with potential merge conflicts arising from teams creating tasks on separate branches. Solve these conflicts very easily by moving your tasks and keeping theirs.
361: 
362: ## Iterative Subtask Implementation
363: 
364: Once a task has been broken down into subtasks using `expand_task` or similar methods, follow this iterative process for implementation:
365: 
366: 1.  **Understand the Goal (Preparation):**
367:     *   Use `get_task` / `task-master show <subtaskId>` (see @`taskmaster.md`) to thoroughly understand the specific goals and requirements of the subtask.
368: 
369: 2.  **Initial Exploration & Planning (Iteration 1):**
370:     *   This is the first attempt at creating a concrete implementation plan.
371:     *   Explore the codebase to identify the precise files, functions, and even specific lines of code that will need modification.
372:     *   Determine the intended code changes (diffs) and their locations.
373:     *   Gather *all* relevant details from this exploration phase.
374: 
375: 3.  **Log the Plan:**
376:     *   Run `update_subtask` / `task-master update-subtask --id=<subtaskId> --prompt='<detailed plan>'`.
377:     *   Provide the *complete and detailed* findings from the exploration phase in the prompt. Include file paths, line numbers, proposed diffs, reasoning, and any potential challenges identified. Do not omit details. The goal is to create a rich, timestamped log within the subtask's `details`.
378: 
379: 4.  **Verify the Plan:**
380:     *   Run `get_task` / `task-master show <subtaskId>` again to confirm that the detailed implementation plan has been successfully appended to the subtask's details.
381: 
382: 5.  **Begin Implementation:**
383:     *   Set the subtask status using `set_task_status` / `task-master set-status --id=<subtaskId> --status=in-progress`.
384:     *   Start coding based on the logged plan.
385: 
386: 6.  **Refine and Log Progress (Iteration 2+):**
387:     *   As implementation progresses, you will encounter challenges, discover nuances, or confirm successful approaches.
388:     *   **Before appending new information**: Briefly review the *existing* details logged in the subtask (using `get_task` or recalling from context) to ensure the update adds fresh insights and avoids redundancy.
389:     *   **Regularly** use `update_subtask` / `task-master update-subtask --id=<subtaskId> --prompt='<update details>\n- What worked...\n- What didn't work...'` to append new findings.
390:     *   **Crucially, log:**
391:         *   What worked ("fundamental truths" discovered).
392:         *   What didn't work and why (to avoid repeating mistakes).
393:         *   Specific code snippets or configurations that were successful.
394:         *   Decisions made, especially if confirmed with user input.
395:         *   Any deviations from the initial plan and the reasoning.
396:     *   The objective is to continuously enrich the subtask's details, creating a log of the implementation journey that helps the AI (and human developers) learn, adapt, and avoid repeating errors.
397: 
398: 7.  **Review & Update Rules (Post-Implementation):**
399:     *   Once the implementation for the subtask is functionally complete, review all code changes and the relevant chat history.
400:     *   Identify any new or modified code patterns, conventions, or best practices established during the implementation.
401:     *   Create new or update existing rules following internal guidelines (previously linked to `cursor_rules.md` and `self_improve.md`).
402: 
403: 8.  **Mark Task Complete:**
404:     *   After verifying the implementation and updating any necessary rules, mark the subtask as completed: `set_task_status` / `task-master set-status --id=<subtaskId> --status=done`.
405: 
406: 9.  **Commit Changes (If using Git):**
407:     *   Stage the relevant code changes and any updated/new rule files (`git add .`).
408:     *   Craft a comprehensive Git commit message summarizing the work done for the subtask, including both code implementation and any rule adjustments.
409:     *   Execute the commit command directly in the terminal (e.g., `git commit -m 'feat(module): Implement feature X for subtask <subtaskId>\n\n- Details about changes...\n- Updated rule Y for pattern Z'`).
410:     *   Consider if a Changeset is needed according to internal versioning guidelines (previously linked to `changeset.md`). If so, run `npm run changeset`, stage the generated file, and amend the commit or create a new one.
411: 
412: 10. **Proceed to Next Subtask:**
413:     *   Identify the next subtask (e.g., using `next_task` / `task-master next`).
414: 
415: ## Code Analysis & Refactoring Techniques
416: 
417: - **Top-Level Function Search**:
418:     - Useful for understanding module structure or planning refactors.
419:     - Use grep/ripgrep to find exported functions/constants:
420:       `rg "export (async function|function|const) \w+"` or similar patterns.
421:     - Can help compare functions between files during migrations or identify potential naming conflicts.
422: 
423: ---
424: *This workflow provides a general guideline. Adapt it based on your specific project needs and team practices.*
</file>

<file path=".windsurf/rules/self_improve.md">
 1: ---
 2: description: Guidelines for continuously improving Windsurf rules based on emerging code patterns and best practices.
 3: globs: **/*
 4: alwaysApply: true
 5: ---
 6: 
 7: - **Rule Improvement Triggers:**
 8:   - New code patterns not covered by existing rules
 9:   - Repeated similar implementations across files
10:   - Common error patterns that could be prevented
11:   - New libraries or tools being used consistently
12:   - Emerging best practices in the codebase
13: 
14: - **Analysis Process:**
15:   - Compare new code with existing rules
16:   - Identify patterns that should be standardized
17:   - Look for references to external documentation
18:   - Check for consistent error handling patterns
19:   - Monitor test patterns and coverage
20: 
21: - **Rule Updates:**
22:   - **Add New Rules When:**
23:     - A new technology/pattern is used in 3+ files
24:     - Common bugs could be prevented by a rule
25:     - Code reviews repeatedly mention the same feedback
26:     - New security or performance patterns emerge
27: 
28:   - **Modify Existing Rules When:**
29:     - Better examples exist in the codebase
30:     - Additional edge cases are discovered
31:     - Related rules have been updated
32:     - Implementation details have changed
33: 
34: - **Example Pattern Recognition:**
35:   ```typescript
36:   // If you see repeated patterns like:
37:   const data = await prisma.user.findMany({
38:     select: { id: true, email: true },
39:     where: { status: 'ACTIVE' }
40:   });
41:   
42:   // Consider adding to [prisma.md](.windsurf/rules/prisma.md):
43:   // - Standard select fields
44:   // - Common where conditions
45:   // - Performance optimization patterns
46:   ```
47: 
48: - **Rule Quality Checks:**
49:   - Rules should be actionable and specific
50:   - Examples should come from actual code
51:   - References should be up to date
52:   - Patterns should be consistently enforced
53: 
54: - **Continuous Improvement:**
55:   - Monitor code review comments
56:   - Track common development questions
57:   - Update rules after major refactors
58:   - Add links to relevant documentation
59:   - Cross-reference related rules
60: 
61: - **Rule Deprecation:**
62:   - Mark outdated patterns as deprecated
63:   - Remove rules that no longer apply
64:   - Update references to deprecated rules
65:   - Document migration paths for old patterns
66: 
67: - **Documentation Updates:**
68:   - Keep examples synchronized with code
69:   - Update references to external docs
70:   - Maintain links between related rules
71:   - Document breaking changes
72: Follow [windsurf_rules.md](.windsurf/rules/windsurf_rules.md) for proper rule formatting and structure.
</file>

<file path=".windsurf/rules/taskmaster.md">
  1: ---
  2: description: Comprehensive reference for Taskmaster MCP tools and CLI commands.
  3: globs: **/*
  4: alwaysApply: true
  5: ---
  6: 
  7: # Taskmaster Tool & Command Reference
  8: 
  9: This document provides a detailed reference for interacting with Taskmaster, covering both the recommended MCP tools, suitable for integrations like Windsurf, and the corresponding `task-master` CLI commands, designed for direct user interaction or fallback.
 10: 
 11: **Note:** For interacting with Taskmaster programmatically or via integrated tools, using the **MCP tools is strongly recommended** due to better performance, structured data, and error handling. The CLI commands serve as a user-friendly alternative and fallback. 
 12: 
 13: **Important:** Several MCP tools involve AI processing... The AI-powered tools include `parse_prd`, `analyze_project_complexity`, `update_subtask`, `update_task`, `update`, `expand_all`, `expand_task`, and `add_task`.
 14: 
 15: ** Tagged Task Lists System:** Task Master now supports **tagged task lists** for multi-context task management. This allows you to maintain separate, isolated lists of tasks for different features, branches, or experiments. Existing projects are seamlessly migrated to use a default "master" tag. Most commands now support a `--tag <name>` flag to specify which context to operate on. If omitted, commands use the currently active tag.
 16: 
 17: ---
 18: 
 19: ## Initialization & Setup
 20: 
 21: ### 1. Initialize Project (`init`)
 22: 
 23: *   **MCP Tool:** `initialize_project`
 24: *   **CLI Command:** `task-master init [options]`
 25: *   **Description:** `Set up the basic Taskmaster file structure and configuration in the current directory for a new project.`
 26: *   **Key CLI Options:**
 27:     *   `--name <name>`: `Set the name for your project in Taskmaster's configuration.`
 28:     *   `--description <text>`: `Provide a brief description for your project.`
 29:     *   `--version <version>`: `Set the initial version for your project, e.g., '0.1.0'.`
 30:     *   `-y, --yes`: `Initialize Taskmaster quickly using default settings without interactive prompts.`
 31: *   **Usage:** Run this once at the beginning of a new project.
 32: *   **MCP Variant Description:** `Set up the basic Taskmaster file structure and configuration in the current directory for a new project by running the 'task-master init' command.`
 33: *   **Key MCP Parameters/Options:**
 34:     *   `projectName`: `Set the name for your project.` (CLI: `--name <name>`)
 35:     *   `projectDescription`: `Provide a brief description for your project.` (CLI: `--description <text>`)
 36:     *   `projectVersion`: `Set the initial version for your project, e.g., '0.1.0'.` (CLI: `--version <version>`)
 37:     *   `authorName`: `Author name.` (CLI: `--author <author>`)
 38:     *   `skipInstall`: `Skip installing dependencies. Default is false.` (CLI: `--skip-install`)
 39:     *   `addAliases`: `Add shell aliases tm and taskmaster. Default is false.` (CLI: `--aliases`)
 40:     *   `yes`: `Skip prompts and use defaults/provided arguments. Default is false.` (CLI: `-y, --yes`)
 41: *   **Usage:** Run this once at the beginning of a new project, typically via an integrated tool like Windsurf. Operates on the current working directory of the MCP server. 
 42: *   **Important:** Once complete, you *MUST* parse a prd in order to generate tasks. There will be no tasks files until then. The next step after initializing should be to create a PRD using the example PRD in .taskmaster/templates/example_prd.txt. 
 43: *   **Tagging:** Use the `--tag` option to parse the PRD into a specific, non-default tag context. If the tag doesn't exist, it will be created automatically. Example: `task-master parse-prd spec.txt --tag=new-feature`.
 44: 
 45: ### 2. Parse PRD (`parse_prd`)
 46: 
 47: *   **MCP Tool:** `parse_prd`
 48: *   **CLI Command:** `task-master parse-prd [file] [options]`
 49: *   **Description:** `Parse a Product Requirements Document, PRD, or text file with Taskmaster to automatically generate an initial set of tasks in tasks.json.`
 50: *   **Key Parameters/Options:**
 51:     *   `input`: `Path to your PRD or requirements text file that Taskmaster should parse for tasks.` (CLI: `[file]` positional or `-i, --input <file>`)
 52:     *   `output`: `Specify where Taskmaster should save the generated 'tasks.json' file. Defaults to '.taskmaster/tasks/tasks.json'.` (CLI: `-o, --output <file>`)
 53:     *   `numTasks`: `Approximate number of top-level tasks Taskmaster should aim to generate from the document.` (CLI: `-n, --num-tasks <number>`)
 54:     *   `force`: `Use this to allow Taskmaster to overwrite an existing 'tasks.json' without asking for confirmation.` (CLI: `-f, --force`)
 55: *   **Usage:** Useful for bootstrapping a project from an existing requirements document.
 56: *   **Notes:** Task Master will strictly adhere to any specific requirements mentioned in the PRD, such as libraries, database schemas, frameworks, tech stacks, etc., while filling in any gaps where the PRD isn't fully specified. Tasks are designed to provide the most direct implementation path while avoiding over-engineering.
 57: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress. If the user does not have a PRD, suggest discussing their idea and then use the example PRD in `.taskmaster/templates/example_prd.txt` as a template for creating the PRD based on their idea, for use with `parse-prd`.
 58: 
 59: ---
 60: 
 61: ## AI Model Configuration
 62: 
 63: ### 2. Manage Models (`models`)
 64: *   **MCP Tool:** `models`
 65: *   **CLI Command:** `task-master models [options]`
 66: *   **Description:** `View the current AI model configuration or set specific models for different roles (main, research, fallback). Allows setting custom model IDs for Ollama and OpenRouter.`
 67: *   **Key MCP Parameters/Options:**
 68:     *   `setMain <model_id>`: `Set the primary model ID for task generation/updates.` (CLI: `--set-main <model_id>`)
 69:     *   `setResearch <model_id>`: `Set the model ID for research-backed operations.` (CLI: `--set-research <model_id>`)
 70:     *   `setFallback <model_id>`: `Set the model ID to use if the primary fails.` (CLI: `--set-fallback <model_id>`)
 71:     *   `ollama <boolean>`: `Indicates the set model ID is a custom Ollama model.` (CLI: `--ollama`)
 72:     *   `openrouter <boolean>`: `Indicates the set model ID is a custom OpenRouter model.` (CLI: `--openrouter`)
 73:     *   `listAvailableModels <boolean>`: `If true, lists available models not currently assigned to a role.` (CLI: No direct equivalent; CLI lists available automatically)
 74:     *   `projectRoot <string>`: `Optional. Absolute path to the project root directory.` (CLI: Determined automatically)
 75: *   **Key CLI Options:**
 76:     *   `--set-main <model_id>`: `Set the primary model.`
 77:     *   `--set-research <model_id>`: `Set the research model.`
 78:     *   `--set-fallback <model_id>`: `Set the fallback model.`
 79:     *   `--ollama`: `Specify that the provided model ID is for Ollama (use with --set-*).`
 80:     *   `--openrouter`: `Specify that the provided model ID is for OpenRouter (use with --set-*). Validates against OpenRouter API.`
 81:     *   `--bedrock`: `Specify that the provided model ID is for AWS Bedrock (use with --set-*).`
 82:     *   `--setup`: `Run interactive setup to configure models, including custom Ollama/OpenRouter IDs.`
 83: *   **Usage (MCP):** Call without set flags to get current config. Use `setMain`, `setResearch`, or `setFallback` with a valid model ID to update the configuration. Use `listAvailableModels: true` to get a list of unassigned models. To set a custom model, provide the model ID and set `ollama: true` or `openrouter: true`.
 84: *   **Usage (CLI):** Run without flags to view current configuration and available models. Use set flags to update specific roles. Use `--setup` for guided configuration, including custom models. To set a custom model via flags, use `--set-<role>=<model_id>` along with either `--ollama` or `--openrouter`.
 85: *   **Notes:** Configuration is stored in `.taskmaster/config.json` in the project root. This command/tool modifies that file. Use `listAvailableModels` or `task-master models` to see internally supported models. OpenRouter custom models are validated against their live API. Ollama custom models are not validated live.
 86: *   **API note:** API keys for selected AI providers (based on their model) need to exist in the mcp.json file to be accessible in MCP context. The API keys must be present in the local .env file for the CLI to be able to read them.
 87: *   **Model costs:** The costs in supported models are expressed in dollars. An input/output value of 3 is $3.00. A value of 0.8 is $0.80. 
 88: *   **Warning:** DO NOT MANUALLY EDIT THE .taskmaster/config.json FILE. Use the included commands either in the MCP or CLI format as needed. Always prioritize MCP tools when available and use the CLI as a fallback.
 89: 
 90: ---
 91: 
 92: ## Task Listing & Viewing
 93: 
 94: ### 3. Get Tasks (`get_tasks`)
 95: 
 96: *   **MCP Tool:** `get_tasks`
 97: *   **CLI Command:** `task-master list [options]`
 98: *   **Description:** `List your Taskmaster tasks, optionally filtering by status and showing subtasks.`
 99: *   **Key Parameters/Options:**
100:     *   `status`: `Show only Taskmaster tasks matching this status (or multiple statuses, comma-separated), e.g., 'pending' or 'done,in-progress'.` (CLI: `-s, --status <status>`)
101:     *   `withSubtasks`: `Include subtasks indented under their parent tasks in the list.` (CLI: `--with-subtasks`)
102:     *   `tag`: `Specify which tag context to list tasks from. Defaults to the current active tag.` (CLI: `--tag <name>`)
103:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
104: *   **Usage:** Get an overview of the project status, often used at the start of a work session.
105: 
106: ### 4. Get Next Task (`next_task`)
107: 
108: *   **MCP Tool:** `next_task`
109: *   **CLI Command:** `task-master next [options]`
110: *   **Description:** `Ask Taskmaster to show the next available task you can work on, based on status and completed dependencies.`
111: *   **Key Parameters/Options:**
112:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
113:     *   `tag`: `Specify which tag context to use. Defaults to the current active tag.` (CLI: `--tag <name>`)
114: *   **Usage:** Identify what to work on next according to the plan.
115: 
116: ### 5. Get Task Details (`get_task`)
117: 
118: *   **MCP Tool:** `get_task`
119: *   **CLI Command:** `task-master show [id] [options]`
120: *   **Description:** `Display detailed information for one or more specific Taskmaster tasks or subtasks by ID.`
121: *   **Key Parameters/Options:**
122:     *   `id`: `Required. The ID of the Taskmaster task (e.g., '15'), subtask (e.g., '15.2'), or a comma-separated list of IDs ('1,5,10.2') you want to view.` (CLI: `[id]` positional or `-i, --id <id>`)
123:     *   `tag`: `Specify which tag context to get the task(s) from. Defaults to the current active tag.` (CLI: `--tag <name>`)
124:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
125: *   **Usage:** Understand the full details for a specific task. When multiple IDs are provided, a summary table is shown.
126: *   **CRITICAL INFORMATION** If you need to collect information from multiple tasks, use comma-separated IDs (i.e. 1,2,3) to receive an array of tasks. Do not needlessly get tasks one at a time if you need to get many as that is wasteful.
127: 
128: ---
129: 
130: ## Task Creation & Modification
131: 
132: ### 6. Add Task (`add_task`)
133: 
134: *   **MCP Tool:** `add_task`
135: *   **CLI Command:** `task-master add-task [options]`
136: *   **Description:** `Add a new task to Taskmaster by describing it; AI will structure it.`
137: *   **Key Parameters/Options:**
138:     *   `prompt`: `Required. Describe the new task you want Taskmaster to create, e.g., "Implement user authentication using JWT".` (CLI: `-p, --prompt <text>`)
139:     *   `dependencies`: `Specify the IDs of any Taskmaster tasks that must be completed before this new one can start, e.g., '12,14'.` (CLI: `-d, --dependencies <ids>`)
140:     *   `priority`: `Set the priority for the new task: 'high', 'medium', or 'low'. Default is 'medium'.` (CLI: `--priority <priority>`)
141:     *   `research`: `Enable Taskmaster to use the research role for potentially more informed task creation.` (CLI: `-r, --research`)
142:     *   `tag`: `Specify which tag context to add the task to. Defaults to the current active tag.` (CLI: `--tag <name>`)
143:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
144: *   **Usage:** Quickly add newly identified tasks during development.
145: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
146: 
147: ### 7. Add Subtask (`add_subtask`)
148: 
149: *   **MCP Tool:** `add_subtask`
150: *   **CLI Command:** `task-master add-subtask [options]`
151: *   **Description:** `Add a new subtask to a Taskmaster parent task, or convert an existing task into a subtask.`
152: *   **Key Parameters/Options:**
153:     *   `id` / `parent`: `Required. The ID of the Taskmaster task that will be the parent.` (MCP: `id`, CLI: `-p, --parent <id>`)
154:     *   `taskId`: `Use this if you want to convert an existing top-level Taskmaster task into a subtask of the specified parent.` (CLI: `-i, --task-id <id>`)
155:     *   `title`: `Required if not using taskId. The title for the new subtask Taskmaster should create.` (CLI: `-t, --title <title>`)
156:     *   `description`: `A brief description for the new subtask.` (CLI: `-d, --description <text>`)
157:     *   `details`: `Provide implementation notes or details for the new subtask.` (CLI: `--details <text>`)
158:     *   `dependencies`: `Specify IDs of other tasks or subtasks, e.g., '15' or '16.1', that must be done before this new subtask.` (CLI: `--dependencies <ids>`)
159:     *   `status`: `Set the initial status for the new subtask. Default is 'pending'.` (CLI: `-s, --status <status>`)
160:     *   `skipGenerate`: `Prevent Taskmaster from automatically regenerating markdown task files after adding the subtask.` (CLI: `--skip-generate`)
161:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
162:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
163: *   **Usage:** Break down tasks manually or reorganize existing tasks.
164: 
165: ### 8. Update Tasks (`update`)
166: 
167: *   **MCP Tool:** `update`
168: *   **CLI Command:** `task-master update [options]`
169: *   **Description:** `Update multiple upcoming tasks in Taskmaster based on new context or changes, starting from a specific task ID.`
170: *   **Key Parameters/Options:**
171:     *   `from`: `Required. The ID of the first task Taskmaster should update. All tasks with this ID or higher that are not 'done' will be considered.` (CLI: `--from <id>`)
172:     *   `prompt`: `Required. Explain the change or new context for Taskmaster to apply to the tasks, e.g., "We are now using React Query instead of Redux Toolkit for data fetching".` (CLI: `-p, --prompt <text>`)
173:     *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
174:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
175:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
176: *   **Usage:** Handle significant implementation changes or pivots that affect multiple future tasks. Example CLI: `task-master update --from='18' --prompt='Switching to React Query.\nNeed to refactor data fetching...'`
177: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
178: 
179: ### 9. Update Task (`update_task`)
180: 
181: *   **MCP Tool:** `update_task`
182: *   **CLI Command:** `task-master update-task [options]`
183: *   **Description:** `Modify a specific Taskmaster task by ID, incorporating new information or changes. By default, this replaces the existing task details.`
184: *   **Key Parameters/Options:**
185:     *   `id`: `Required. The specific ID of the Taskmaster task, e.g., '15', you want to update.` (CLI: `-i, --id <id>`)
186:     *   `prompt`: `Required. Explain the specific changes or provide the new information Taskmaster should incorporate into this task.` (CLI: `-p, --prompt <text>`)
187:     *   `append`: `If true, appends the prompt content to the task's details with a timestamp, rather than replacing them. Behaves like update-subtask.` (CLI: `--append`)
188:     *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
189:     *   `tag`: `Specify which tag context the task belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
190:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
191: *   **Usage:** Refine a specific task based on new understanding. Use `--append` to log progress without creating subtasks.
192: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
193: 
194: ### 10. Update Subtask (`update_subtask`)
195: 
196: *   **MCP Tool:** `update_subtask`
197: *   **CLI Command:** `task-master update-subtask [options]`
198: *   **Description:** `Append timestamped notes or details to a specific Taskmaster subtask without overwriting existing content. Intended for iterative implementation logging.`
199: *   **Key Parameters/Options:**
200:     *   `id`: `Required. The ID of the Taskmaster subtask, e.g., '5.2', to update with new information.` (CLI: `-i, --id <id>`)
201:     *   `prompt`: `Required. The information, findings, or progress notes to append to the subtask's details with a timestamp.` (CLI: `-p, --prompt <text>`)
202:     *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)
203:     *   `tag`: `Specify which tag context the subtask belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
204:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
205: *   **Usage:** Log implementation progress, findings, and discoveries during subtask development. Each update is timestamped and appended to preserve the implementation journey.
206: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
207: 
208: ### 11. Set Task Status (`set_task_status`)
209: 
210: *   **MCP Tool:** `set_task_status`
211: *   **CLI Command:** `task-master set-status [options]`
212: *   **Description:** `Update the status of one or more Taskmaster tasks or subtasks, e.g., 'pending', 'in-progress', 'done'.`
213: *   **Key Parameters/Options:**
214:     *   `id`: `Required. The ID(s) of the Taskmaster task(s) or subtask(s), e.g., '15', '15.2', or '16,17.1', to update.` (CLI: `-i, --id <id>`)
215:     *   `status`: `Required. The new status to set, e.g., 'done', 'pending', 'in-progress', 'review', 'cancelled'.` (CLI: `-s, --status <status>`)
216:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
217:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
218: *   **Usage:** Mark progress as tasks move through the development cycle.
219: 
220: ### 12. Remove Task (`remove_task`)
221: 
222: *   **MCP Tool:** `remove_task`
223: *   **CLI Command:** `task-master remove-task [options]`
224: *   **Description:** `Permanently remove a task or subtask from the Taskmaster tasks list.`
225: *   **Key Parameters/Options:**
226:     *   `id`: `Required. The ID of the Taskmaster task, e.g., '5', or subtask, e.g., '5.2', to permanently remove.` (CLI: `-i, --id <id>`)
227:     *   `yes`: `Skip the confirmation prompt and immediately delete the task.` (CLI: `-y, --yes`)
228:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
229:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
230: *   **Usage:** Permanently delete tasks or subtasks that are no longer needed in the project.
231: *   **Notes:** Use with caution as this operation cannot be undone. Consider using 'blocked', 'cancelled', or 'deferred' status instead if you just want to exclude a task from active planning but keep it for reference. The command automatically cleans up dependency references in other tasks.
232: 
233: ---
234: 
235: ## Task Structure & Breakdown
236: 
237: ### 13. Expand Task (`expand_task`)
238: 
239: *   **MCP Tool:** `expand_task`
240: *   **CLI Command:** `task-master expand [options]`
241: *   **Description:** `Use Taskmaster's AI to break down a complex task into smaller, manageable subtasks. Appends subtasks by default.`
242: *   **Key Parameters/Options:**
243:     *   `id`: `The ID of the specific Taskmaster task you want to break down into subtasks.` (CLI: `-i, --id <id>`)
244:     *   `num`: `Optional: Suggests how many subtasks Taskmaster should aim to create. Uses complexity analysis/defaults otherwise.` (CLI: `-n, --num <number>`)
245:     *   `research`: `Enable Taskmaster to use the research role for more informed subtask generation. Requires appropriate API key.` (CLI: `-r, --research`)
246:     *   `prompt`: `Optional: Provide extra context or specific instructions to Taskmaster for generating the subtasks.` (CLI: `-p, --prompt <text>`)
247:     *   `force`: `Optional: If true, clear existing subtasks before generating new ones. Default is false (append).` (CLI: `--force`)
248:     *   `tag`: `Specify which tag context the task belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)
249:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
250: *   **Usage:** Generate a detailed implementation plan for a complex task before starting coding. Automatically uses complexity report recommendations if available and `num` is not specified.
251: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
252: 
253: ### 14. Expand All Tasks (`expand_all`)
254: 
255: *   **MCP Tool:** `expand_all`
256: *   **CLI Command:** `task-master expand --all [options]` (Note: CLI uses the `expand` command with the `--all` flag)
257: *   **Description:** `Tell Taskmaster to automatically expand all eligible pending/in-progress tasks based on complexity analysis or defaults. Appends subtasks by default.`
258: *   **Key Parameters/Options:**
259:     *   `num`: `Optional: Suggests how many subtasks Taskmaster should aim to create per task.` (CLI: `-n, --num <number>`)
260:     *   `research`: `Enable research role for more informed subtask generation. Requires appropriate API key.` (CLI: `-r, --research`)
261:     *   `prompt`: `Optional: Provide extra context for Taskmaster to apply generally during expansion.` (CLI: `-p, --prompt <text>`)
262:     *   `force`: `Optional: If true, clear existing subtasks before generating new ones for each eligible task. Default is false (append).` (CLI: `--force`)
263:     *   `tag`: `Specify which tag context to expand. Defaults to the current active tag.` (CLI: `--tag <name>`)
264:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
265: *   **Usage:** Useful after initial task generation or complexity analysis to break down multiple tasks at once.
266: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
267: 
268: ### 15. Clear Subtasks (`clear_subtasks`)
269: 
270: *   **MCP Tool:** `clear_subtasks`
271: *   **CLI Command:** `task-master clear-subtasks [options]`
272: *   **Description:** `Remove all subtasks from one or more specified Taskmaster parent tasks.`
273: *   **Key Parameters/Options:**
274:     *   `id`: `The ID(s) of the Taskmaster parent task(s) whose subtasks you want to remove, e.g., '15' or '16,18'. Required unless using `all`.) (CLI: `-i, --id <ids>`)
275:     *   `all`: `Tell Taskmaster to remove subtasks from all parent tasks.` (CLI: `--all`)
276:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
277:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
278: *   **Usage:** Used before regenerating subtasks with `expand_task` if the previous breakdown needs replacement.
279: 
280: ### 16. Remove Subtask (`remove_subtask`)
281: 
282: *   **MCP Tool:** `remove_subtask`
283: *   **CLI Command:** `task-master remove-subtask [options]`
284: *   **Description:** `Remove a subtask from its Taskmaster parent, optionally converting it into a standalone task.`
285: *   **Key Parameters/Options:**
286:     *   `id`: `Required. The ID(s) of the Taskmaster subtask(s) to remove, e.g., '15.2' or '16.1,16.3'.` (CLI: `-i, --id <id>`)
287:     *   `convert`: `If used, Taskmaster will turn the subtask into a regular top-level task instead of deleting it.` (CLI: `-c, --convert`)
288:     *   `skipGenerate`: `Prevent Taskmaster from automatically regenerating markdown task files after removing the subtask.` (CLI: `--skip-generate`)
289:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
290:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
291: *   **Usage:** Delete unnecessary subtasks or promote a subtask to a top-level task.
292: 
293: ### 17. Move Task (`move_task`)
294: 
295: *   **MCP Tool:** `move_task`
296: *   **CLI Command:** `task-master move [options]`
297: *   **Description:** `Move a task or subtask to a new position within the task hierarchy.`
298: *   **Key Parameters/Options:**
299:     *   `from`: `Required. ID of the task/subtask to move (e.g., "5" or "5.2"). Can be comma-separated for multiple tasks.` (CLI: `--from <id>`)
300:     *   `to`: `Required. ID of the destination (e.g., "7" or "7.3"). Must match the number of source IDs if comma-separated.` (CLI: `--to <id>`)
301:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
302:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
303: *   **Usage:** Reorganize tasks by moving them within the hierarchy. Supports various scenarios like:
304:     *   Moving a task to become a subtask
305:     *   Moving a subtask to become a standalone task
306:     *   Moving a subtask to a different parent
307:     *   Reordering subtasks within the same parent
308:     *   Moving a task to a new, non-existent ID (automatically creates placeholders)
309:     *   Moving multiple tasks at once with comma-separated IDs
310: *   **Validation Features:**
311:     *   Allows moving tasks to non-existent destination IDs (creates placeholder tasks)
312:     *   Prevents moving to existing task IDs that already have content (to avoid overwriting)
313:     *   Validates that source tasks exist before attempting to move them
314:     *   Maintains proper parent-child relationships
315: *   **Example CLI:** `task-master move --from=5.2 --to=7.3` to move subtask 5.2 to become subtask 7.3.
316: *   **Example Multi-Move:** `task-master move --from=10,11,12 --to=16,17,18` to move multiple tasks to new positions.
317: *   **Common Use:** Resolving merge conflicts in tasks.json when multiple team members create tasks on different branches.
318: 
319: ---
320: 
321: ## Dependency Management
322: 
323: ### 18. Add Dependency (`add_dependency`)
324: 
325: *   **MCP Tool:** `add_dependency`
326: *   **CLI Command:** `task-master add-dependency [options]`
327: *   **Description:** `Define a dependency in Taskmaster, making one task a prerequisite for another.`
328: *   **Key Parameters/Options:**
329:     *   `id`: `Required. The ID of the Taskmaster task that will depend on another.` (CLI: `-i, --id <id>`)
330:     *   `dependsOn`: `Required. The ID of the Taskmaster task that must be completed first, the prerequisite.` (CLI: `-d, --depends-on <id>`)
331:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
332:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <path>`)
333: *   **Usage:** Establish the correct order of execution between tasks.
334: 
335: ### 19. Remove Dependency (`remove_dependency`)
336: 
337: *   **MCP Tool:** `remove_dependency`
338: *   **CLI Command:** `task-master remove-dependency [options]`
339: *   **Description:** `Remove a dependency relationship between two Taskmaster tasks.`
340: *   **Key Parameters/Options:**
341:     *   `id`: `Required. The ID of the Taskmaster task you want to remove a prerequisite from.` (CLI: `-i, --id <id>`)
342:     *   `dependsOn`: `Required. The ID of the Taskmaster task that should no longer be a prerequisite.` (CLI: `-d, --depends-on <id>`)
343:     *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)
344:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
345: *   **Usage:** Update task relationships when the order of execution changes.
346: 
347: ### 20. Validate Dependencies (`validate_dependencies`)
348: 
349: *   **MCP Tool:** `validate_dependencies`
350: *   **CLI Command:** `task-master validate-dependencies [options]`
351: *   **Description:** `Check your Taskmaster tasks for dependency issues (like circular references or links to non-existent tasks) without making changes.`
352: *   **Key Parameters/Options:**
353:     *   `tag`: `Specify which tag context to validate. Defaults to the current active tag.` (CLI: `--tag <name>`)
354:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
355: *   **Usage:** Audit the integrity of your task dependencies.
356: 
357: ### 21. Fix Dependencies (`fix_dependencies`)
358: 
359: *   **MCP Tool:** `fix_dependencies`
360: *   **CLI Command:** `task-master fix-dependencies [options]`
361: *   **Description:** `Automatically fix dependency issues (like circular references or links to non-existent tasks) in your Taskmaster tasks.`
362: *   **Key Parameters/Options:**
363:     *   `tag`: `Specify which tag context to fix dependencies in. Defaults to the current active tag.` (CLI: `--tag <name>`)
364:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
365: *   **Usage:** Clean up dependency errors automatically.
366: 
367: ---
368: 
369: ## Analysis & Reporting
370: 
371: ### 22. Analyze Project Complexity (`analyze_project_complexity`)
372: 
373: *   **MCP Tool:** `analyze_project_complexity`
374: *   **CLI Command:** `task-master analyze-complexity [options]`
375: *   **Description:** `Have Taskmaster analyze your tasks to determine their complexity and suggest which ones need to be broken down further.`
376: *   **Key Parameters/Options:**
377:     *   `output`: `Where to save the complexity analysis report. Default is '.taskmaster/reports/task-complexity-report.json' (or '..._tagname.json' if a tag is used).` (CLI: `-o, --output <file>`)
378:     *   `threshold`: `The minimum complexity score (1-10) that should trigger a recommendation to expand a task.` (CLI: `-t, --threshold <number>`)
379:     *   `research`: `Enable research role for more accurate complexity analysis. Requires appropriate API key.` (CLI: `-r, --research`)
380:     *   `tag`: `Specify which tag context to analyze. Defaults to the current active tag.` (CLI: `--tag <name>`)
381:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
382: *   **Usage:** Used before breaking down tasks to identify which ones need the most attention.
383: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.
384: 
385: ### 23. View Complexity Report (`complexity_report`)
386: 
387: *   **MCP Tool:** `complexity_report`
388: *   **CLI Command:** `task-master complexity-report [options]`
389: *   **Description:** `Display the task complexity analysis report in a readable format.`
390: *   **Key Parameters/Options:**
391:     *   `tag`: `Specify which tag context to show the report for. Defaults to the current active tag.` (CLI: `--tag <name>`)
392:     *   `file`: `Path to the complexity report (default: '.taskmaster/reports/task-complexity-report.json').` (CLI: `-f, --file <file>`)
393: *   **Usage:** Review and understand the complexity analysis results after running analyze-complexity.
394: 
395: ---
396: 
397: ## File Management
398: 
399: ### 24. Generate Task Files (`generate`)
400: 
401: *   **MCP Tool:** `generate`
402: *   **CLI Command:** `task-master generate [options]`
403: *   **Description:** `Create or update individual Markdown files for each task based on your tasks.json.`
404: *   **Key Parameters/Options:**
405:     *   `output`: `The directory where Taskmaster should save the task files (default: in a 'tasks' directory).` (CLI: `-o, --output <directory>`)
406:     *   `tag`: `Specify which tag context to generate files for. Defaults to the current active tag.` (CLI: `--tag <name>`)
407:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
408: *   **Usage:** Run this after making changes to tasks.json to keep individual task files up to date. This command is now manual and no longer runs automatically.
409: 
410: ---
411: 
412: ## AI-Powered Research
413: 
414: ### 25. Research (`research`)
415: 
416: *   **MCP Tool:** `research`
417: *   **CLI Command:** `task-master research [options]`
418: *   **Description:** `Perform AI-powered research queries with project context to get fresh, up-to-date information beyond the AI's knowledge cutoff.`
419: *   **Key Parameters/Options:**
420:     *   `query`: `Required. Research query/prompt (e.g., "What are the latest best practices for React Query v5?").` (CLI: `[query]` positional or `-q, --query <text>`)
421:     *   `taskIds`: `Comma-separated list of task/subtask IDs from the current tag context (e.g., "15,16.2,17").` (CLI: `-i, --id <ids>`)
422:     *   `filePaths`: `Comma-separated list of file paths for context (e.g., "src/api.js,docs/readme.md").` (CLI: `-f, --files <paths>`)
423:     *   `customContext`: `Additional custom context text to include in the research.` (CLI: `-c, --context <text>`)
424:     *   `includeProjectTree`: `Include project file tree structure in context (default: false).` (CLI: `--tree`)
425:     *   `detailLevel`: `Detail level for the research response: 'low', 'medium', 'high' (default: medium).` (CLI: `--detail <level>`)
426:     *   `saveTo`: `Task or subtask ID (e.g., "15", "15.2") to automatically save the research conversation to.` (CLI: `--save-to <id>`)
427:     *   `saveFile`: `If true, saves the research conversation to a markdown file in '.taskmaster/docs/research/'.` (CLI: `--save-file`)
428:     *   `noFollowup`: `Disables the interactive follow-up question menu in the CLI.` (CLI: `--no-followup`)
429:     *   `tag`: `Specify which tag context to use for task-based context gathering. Defaults to the current active tag.` (CLI: `--tag <name>`)
430:     *   `projectRoot`: `The directory of the project. Must be an absolute path.` (CLI: Determined automatically)
431: *   **Usage:** **This is a POWERFUL tool that agents should use FREQUENTLY** to:
432:     *   Get fresh information beyond knowledge cutoff dates
433:     *   Research latest best practices, library updates, security patches
434:     *   Find implementation examples for specific technologies
435:     *   Validate approaches against current industry standards
436:     *   Get contextual advice based on project files and tasks
437: *   **When to Consider Using Research:**
438:     *   **Before implementing any task** - Research current best practices
439:     *   **When encountering new technologies** - Get up-to-date implementation guidance (libraries, apis, etc)
440:     *   **For security-related tasks** - Find latest security recommendations
441:     *   **When updating dependencies** - Research breaking changes and migration guides
442:     *   **For performance optimization** - Get current performance best practices
443:     *   **When debugging complex issues** - Research known solutions and workarounds
444: *   **Research + Action Pattern:**
445:     *   Use `research` to gather fresh information
446:     *   Use `update_subtask` to commit findings with timestamps
447:     *   Use `update_task` to incorporate research into task details
448:     *   Use `add_task` with research flag for informed task creation
449: *   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. The research provides FRESH data beyond the AI's training cutoff, making it invaluable for current best practices and recent developments.
450: 
451: ---
452: 
453: ## Tag Management
454: 
455: This new suite of commands allows you to manage different task contexts (tags).
456: 
457: ### 26. List Tags (`tags`)
458: 
459: *   **MCP Tool:** `list_tags`
460: *   **CLI Command:** `task-master tags [options]`
461: *   **Description:** `List all available tags with task counts, completion status, and other metadata.`
462: *   **Key Parameters/Options:**
463:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
464:     *   `--show-metadata`: `Include detailed metadata in the output (e.g., creation date, description).` (CLI: `--show-metadata`)
465: 
466: ### 27. Add Tag (`add_tag`)
467: 
468: *   **MCP Tool:** `add_tag`
469: *   **CLI Command:** `task-master add-tag <tagName> [options]`
470: *   **Description:** `Create a new, empty tag context, or copy tasks from another tag.`
471: *   **Key Parameters/Options:**
472:     *   `tagName`: `Name of the new tag to create (alphanumeric, hyphens, underscores).` (CLI: `<tagName>` positional)
473:     *   `--from-branch`: `Creates a tag with a name derived from the current git branch, ignoring the <tagName> argument.` (CLI: `--from-branch`)
474:     *   `--copy-from-current`: `Copy tasks from the currently active tag to the new tag.` (CLI: `--copy-from-current`)
475:     *   `--copy-from <tag>`: `Copy tasks from a specific source tag to the new tag.` (CLI: `--copy-from <tag>`)
476:     *   `--description <text>`: `Provide an optional description for the new tag.` (CLI: `-d, --description <text>`)
477:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
478: 
479: ### 28. Delete Tag (`delete_tag`)
480: 
481: *   **MCP Tool:** `delete_tag`
482: *   **CLI Command:** `task-master delete-tag <tagName> [options]`
483: *   **Description:** `Permanently delete a tag and all of its associated tasks.`
484: *   **Key Parameters/Options:**
485:     *   `tagName`: `Name of the tag to delete.` (CLI: `<tagName>` positional)
486:     *   `--yes`: `Skip the confirmation prompt.` (CLI: `-y, --yes`)
487:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
488: 
489: ### 29. Use Tag (`use_tag`)
490: 
491: *   **MCP Tool:** `use_tag`
492: *   **CLI Command:** `task-master use-tag <tagName>`
493: *   **Description:** `Switch your active task context to a different tag.`
494: *   **Key Parameters/Options:**
495:     *   `tagName`: `Name of the tag to switch to.` (CLI: `<tagName>` positional)
496:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
497: 
498: ### 30. Rename Tag (`rename_tag`)
499: 
500: *   **MCP Tool:** `rename_tag`
501: *   **CLI Command:** `task-master rename-tag <oldName> <newName>`
502: *   **Description:** `Rename an existing tag.`
503: *   **Key Parameters/Options:**
504:     *   `oldName`: `The current name of the tag.` (CLI: `<oldName>` positional)
505:     *   `newName`: `The new name for the tag.` (CLI: `<newName>` positional)
506:     *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)
507: 
508: ### 31. Copy Tag (`copy_tag`)
509: 
510: *   **MCP Tool:** `copy_tag`
511: *   **CLI Command:** `task-master copy-tag <sourceName> <targetName> [options]`
512: *   **Description:** `Copy an entire tag context, including all its tasks and metadata, to a new tag.`
513: *   **Key Parameters/Options:**
514:     *   `sourceName`: `Name of the tag to copy from.` (CLI: `<sourceName>` positional)
515:     *   `targetName`: `Name of the new tag to create.` (CLI: `<targetName>` positional)
516:     *   `--description <text>`: `Optional description for the new tag.` (CLI: `-d, --description <text>`)
517: 
518: ---
519: 
520: ## Miscellaneous
521: 
522: ### 32. Sync Readme (`sync-readme`) -- experimental
523: 
524: *   **MCP Tool:** N/A
525: *   **CLI Command:** `task-master sync-readme [options]`
526: *   **Description:** `Exports your task list to your project's README.md file, useful for showcasing progress.`
527: *   **Key Parameters/Options:**
528:     *   `status`: `Filter tasks by status (e.g., 'pending', 'done').` (CLI: `-s, --status <status>`)
529:     *   `withSubtasks`: `Include subtasks in the export.` (CLI: `--with-subtasks`)
530:     *   `tag`: `Specify which tag context to export from. Defaults to the current active tag.` (CLI: `--tag <name>`)
531: 
532: ---
533: 
534: ## Environment Variables Configuration (Updated)
535: 
536: Taskmaster primarily uses the **`.taskmaster/config.json`** file (in project root) for configuration (models, parameters, logging level, etc.), managed via `task-master models --setup`.
537: 
538: Environment variables are used **only** for sensitive API keys related to AI providers and specific overrides like the Ollama base URL:
539: 
540: *   **API Keys (Required for corresponding provider):**
541:     *   `ANTHROPIC_API_KEY`
542:     *   `PERPLEXITY_API_KEY`
543:     *   `OPENAI_API_KEY`
544:     *   `GOOGLE_API_KEY`
545:     *   `MISTRAL_API_KEY`
546:     *   `AZURE_OPENAI_API_KEY` (Requires `AZURE_OPENAI_ENDPOINT` too)
547:     *   `OPENROUTER_API_KEY`
548:     *   `XAI_API_KEY`
549:     *   `OLLAMA_API_KEY` (Requires `OLLAMA_BASE_URL` too)
550: *   **Endpoints (Optional/Provider Specific inside .taskmaster/config.json):**
551:     *   `AZURE_OPENAI_ENDPOINT`
552:     *   `OLLAMA_BASE_URL` (Default: `http://localhost:11434/api`)
553: 
554: **Set API keys** in your **`.env`** file in the project root (for CLI use) or within the `env` section of your **`.windsurf/mcp.json`** file (for MCP/Windsurf integration). All other settings (model choice, max tokens, temperature, log level, custom endpoints) are managed in `.taskmaster/config.json` via `task-master models` command or `models` MCP tool.
555: 
556: ---
557: 
558: For details on how these commands fit into the development process, see the [dev_workflow.md](.windsurf/rules/dev_workflow.md).
</file>

<file path=".windsurf/rules/windsurf_rules.md">
 1: ---
 2: description: Guidelines for creating and maintaining Windsurf rules to ensure consistency and effectiveness.
 3: globs: .windsurf/rules/*.md
 4: alwaysApply: true
 5: ---
 6: 
 7: - **Required Rule Structure:**
 8:   ```markdown
 9:   ---
10:   description: Clear, one-line description of what the rule enforces
11:   globs: path/to/files/*.ext, other/path/**/*
12:   alwaysApply: boolean
13:   ---
14: 
15:   - **Main Points in Bold**
16:     - Sub-points with details
17:     - Examples and explanations
18:   ```
19: 
20: - **File References:**
21:   - Use `[filename](mdc:path/to/file)` ([filename](mdc:filename)) to reference files
22:   - Example: [prisma.md](.windsurf/rules/prisma.md) for rule references
23:   - Example: [schema.prisma](mdc:prisma/schema.prisma) for code references
24: 
25: - **Code Examples:**
26:   - Use language-specific code blocks
27:   ```typescript
28:   //  DO: Show good examples
29:   const goodExample = true;
30:   
31:   //  DON'T: Show anti-patterns
32:   const badExample = false;
33:   ```
34: 
35: - **Rule Content Guidelines:**
36:   - Start with high-level overview
37:   - Include specific, actionable requirements
38:   - Show examples of correct implementation
39:   - Reference existing code when possible
40:   - Keep rules DRY by referencing other rules
41: 
42: - **Rule Maintenance:**
43:   - Update rules when new patterns emerge
44:   - Add examples from actual codebase
45:   - Remove outdated patterns
46:   - Cross-reference related rules
47: 
48: - **Best Practices:**
49:   - Use bullet points for clarity
50:   - Keep descriptions concise
51:   - Include both DO and DON'T examples
52:   - Reference actual code over theoretical examples
53:   - Use consistent formatting across rules
</file>

<file path=".windsurf/mcp.json">
 1: {
 2: 	"mcpServers": {
 3: 		"task-master-ai": {
 4: 			"command": "npx",
 5: 			"args": ["-y", "--package=task-master-ai", "task-master-ai"],
 6: 			"env": {
 7: 				"ANTHROPIC_API_KEY": "ANTHROPIC_API_KEY_HERE",
 8: 				"PERPLEXITY_API_KEY": "PERPLEXITY_API_KEY_HERE",
 9: 				"OPENAI_API_KEY": "OPENAI_API_KEY_HERE",
10: 				"GOOGLE_API_KEY": "GOOGLE_API_KEY_HERE",
11: 				"XAI_API_KEY": "XAI_API_KEY_HERE",
12: 				"OPENROUTER_API_KEY": "OPENROUTER_API_KEY_HERE",
13: 				"MISTRAL_API_KEY": "MISTRAL_API_KEY_HERE",
14: 				"AZURE_OPENAI_API_KEY": "AZURE_OPENAI_API_KEY_HERE",
15: 				"OLLAMA_API_KEY": "OLLAMA_API_KEY_HERE"
16: 			}
17: 		}
18: 	}
19: }
</file>

<file path="llm_context/forms/README.md">
 1: # Form Submission Patterns
 2: 
 3: ## Form Libraries
 4: - [x] React Hook Form integration patterns - Integrates well with Zod for schema validation
 5: - [x] Zod schema validation - Provides type safety and validation logic
 6: - [x] Form state management with Zustand - Use Zustand for complex form state across components
 7: - [x] File upload handling with Payload Media - Implement using Form Builder plugin with custom overrides[1][2]
 8: 
 9: ## Submission Strategies
10: - [x] Optimistic UI updates - Implement with Tanstack Query's `onMutate`[4]
11: - [x] Error handling and user feedback - Use Form Builder's confirmation messages[1][4]
12: - [x] Multi-step form patterns - Implement with Zustand state management
13: - [x] Auto-save functionality - Use debounced submissions with Zustand
14: - [x] Form validation timing - Real-time validation with Zod schemas
15: 
16: ## Payload Integration
17: - [x] Collection field mapping - Map form fields directly to Payload collections[3]
18: - [x] Relationship field handling - Use Form Builder's relationship fields[3]
19: - [x] Rich text editor integration - Implement Lexical editor in forms[3]
20: - [x] Media upload workflows - Custom file upload handling with Form Builder[1][2]
21: ```typescript
22: // File upload example with Form Builder
23: import { FormBuilder } from 'payload-plugin-form-builder';
24: 
25: const formConfig = {
26:   fields: {
27:     fileUpload: {
28:       type: 'upload',
29:       relationTo: 'media',
30:       required: true
31:     }
32:   },
33:   hooks: {
34:     beforeSubmit: async ({ data }) => {
35:       // Custom file processing
36:       return processFileUpload(data.fileUpload);
37:     }
38:   }
39: };
40: ```
41: - [x] Bulk operations - Implement with Payload's bulk operation endpoints
42: 
43: ## UI Patterns
44: - [x] Loading states and spinners - Show during form submission
45: - [x] Success/error notifications - Use Form Builder's confirmation system[1][4]
46: - [x] Form reset strategies - Reset form after successful submission
47: - [x] Conditional field rendering - Implement with React state and useEffect
48: - [x] Accessibility considerations - Use semantic HTML and ARIA attributes
49: 
50: ## Form Builder Best Practices
51: 1. Use `redirectRelationships` for confirmation page redirection[4]
52: 2. Implement `beforeEmail` hook for custom email templates[4]
53: 3. Set `defaultToEmail` for fallback submission addresses[4]
54: 4. Use `formOverrides` to customize form collection behavior[4]
55: 5. Add reCAPTCHA for spam protection[3]
56: 
57: ## Files to Create
58: - `best_practices.md` - Form handling best practices
59: - `common_patterns.md` - Reusable form components
60: - `troubleshooting.md` - Common form issues
61: - `integration_guides.md` - Integration with Payload and Tanstack
</file>

<file path="llm_context/llm_agent_insights/README.md">
 1: # LLM Agent Insights
 2: 
 3: ## Agent Behavior Patterns
 4: - [x] Context window management strategies - Use sliding window and summarization techniques[1][3]
 5: - [x] Token optimization techniques - Prioritize critical information and structure it first[1][5]
 6: - [x] Multi-turn conversation patterns - Implement stateful conversation tracking[1][4]
 7: - [x] Error recovery strategies - Use fallback mechanisms and context-aware retries[1][5]
 8: - [x] Task decomposition approaches - Break complex tasks into atomic steps[1][5]
 9: 
10: ## Code Generation Best Practices
11: - [x] Incremental development patterns - Implement step-by-step implementation[1][3]
12: - [x] Code review and validation strategies - Use automated testing and peer review[1][5]
13: - [x] Testing integration workflows - Add tests for each generated component[1][4]
14: - [x] Documentation generation patterns - Generate inline documentation with context[1][2]
15: - [x] Refactoring approaches - Use automated refactoring tools[1][5]
16: 
17: ## Project-Specific Considerations
18: - [x] Payload 3 collection understanding - Map collections to context schemas[1][3]
19: - [x] Next.js app router navigation - Implement route-aware context[1][2]
20: - [x] TypeScript type inference - Use type annotations in prompts[1][4]
21: - [x] Database schema awareness - Integrate ORM definitions[1][5]
22: - [x] API endpoint patterns - Document endpoint structures[1][3]
23: 
24: ## Collaboration Patterns
25: - [x] Human-agent handoff strategies - Implement clear handoff points[1][4]
26: - [x] Code explanation techniques - Generate inline comments and documentation[1][2]
27: - [x] Progress tracking methods - Use task status reporting[1][5]
28: - [x] Decision documentation - Maintain decision logs[1][3]
29: - [x] Knowledge transfer patterns - Create knowledge base articles[1][4]
30: 
31: ## Performance Optimization
32: - [x] Response time optimization - Implement caching and parallel processing[1][5]
33: - [x] Context relevance scoring - Use TF-IDF and semantic similarity[1][4]
34: - [x] Tool selection strategies - Implement cost-benefit analysis[1][3]
35: - [x] Parallel processing patterns - Use async task execution[1][5]
36: - [x] Caching mechanisms - Implement LRU caching[1][2]
37: 
38: ## Best Practices
39: 1. **Context Management** - Use hybrid CAG + RAG approaches[1][5]
40: 2. **Task Execution** - Break tasks into atomic operations[1][5]
41: 3. **Validation** - Implement multi-step verification[1][2]
42: 4. **Documentation** - Generate context-aware docs[1][3]
43: 5. **Security** - Sanitize all inputs and outputs[1][5]
44: 
45: ```typescript
46: // Example task decomposition
47: const task = {
48:   id: 'refactor-component',
49:   steps: [
50:     'Analyze current implementation',
51:     'Identify refactoring opportunities',
52:     'Implement atomic changes',
53:     'Verify functionality',
54:     'Update documentation'
55:   ]
56: };
57: ```
58: 
59: ## Files to Create
60: - `context_management.md` - Context window optimization
61: - `code_generation_patterns.md` - Effective code generation
62: - `project_understanding.md` - Project-specific insights
63: - `collaboration_strategies.md` - Human-agent collaboration
64: - `performance_optimization.md` - Agent performance tuning
</file>

<file path="llm_context/mcp_tools/context7_advanced.md">
 1: # Context7 Advanced Usage
 2: 
 3: ## Dynamic Documentation Retrieval
 4: - [x] Library ID resolution strategies - Use enum-based approaches and dynamic schema adaptation[1][3]
 5: - [x] Topic-focused documentation queries - Implement with targeted search parameters[1][2]
 6: - [x] Token optimization for large docs - Use summarization and key point extraction[1][5]
 7: - [x] Multi-library integration patterns - Implement with chained context requests[1][4]
 8: - [x] Version-specific documentation - Specify exact package versions in requests[1][2]
 9: 
10: ```typescript
11: // Version-specific query example
12: const response = await fetch('https://context7-mcp.example.com/docs', {
13:   method: 'POST',
14:   headers: { 'Content-Type': 'application/json' },
15:   body: JSON.stringify({
16:     library: 'nextjs',
17:     version: '14.2.3',
18:     query: 'app router implementation'
19:   })
20: });
21: ```
22: 
23: ## Integration Patterns
24: - [x] Automated documentation updates - Implement webhook-based sync[1][3]
25: - [x] Context injection workflows - Use middleware for seamless integration[1][5]
26: - [x] Real-time documentation sync - Implement with SSE (Server-Sent Events)[1]
27: - [x] Custom library indexing - Extend with custom documentation sources[1][4]
28: - [x] Documentation caching strategies - Implement TTL-based caching[1][5]
29: 
30: ## Workflow Optimization
31: - [x] Context window management - Use sliding window technique[3][5]
32: - [x] Selective documentation loading - Implement relevance scoring[1][3]
33: - [x] Documentation relevance scoring - Use TF-IDF and semantic similarity[1][5]
34: - [x] Multi-step research patterns - Chain context requests for complex queries[1][4]
35: - [x] Documentation validation - Implement checksum verification[1]
36: 
37: ## Project-Specific Usage
38: - [x] Payload 3 documentation integration - Map collection schemas to context[1][3]
39: - [x] Next.js best practices retrieval - Use version-specific queries[1][2]
40: - [x] React patterns documentation - Implement component-focused queries[1]
41: - [x] TypeScript reference integration - Add type definition support[1][4]
42: - [x] UI library documentation - Integrate Shadcn UI references[1]
43: 
44: ## Implementation Strategies
45: 1. **Installation** - Use npm package `@upstash/context7`[2][5]
46: 2. **Configuration** - Set default libraries and versions[1][4]
47: 3. **Query Optimization** - Use specific keywords for better results[1][2]
48: 4. **Error Handling** - Implement fallback to generic docs[1][5]
49: 5. **Rate Limiting** - Use exponential backoff for retries[1][5]
50: 
51: ```bash
52: # Installation command
53: npm install @upstash/context7
54: ```
55: 
56: ## Best Practices
57: - Always specify library versions to avoid outdated docs[1][2]
58: - Use `use context7` directive in your queries[1][3]
59: - Combine with other MCP tools for enhanced capabilities[1][4]
60: - Monitor token usage for cost optimization[1][5]
61: - Verify critical code snippets before implementation[1][2]
</file>

<file path="llm_context/mcp_tools/README.md">
 1: # MCP Tools Integration
 2: 
 3: ## Core MCP Tools
 4: - [x] Context7 documentation retrieval patterns - Implement with selective subscriptions[1]
 5: - [x] Taskmaster project management integration - Use Zustand for task state management[1][3]
 6: - [x] Puppeteer browser automation workflows - Combine with Zustand for UI state[1][5]
 7: - [x] Supabase database operations - Implement with computed state patterns[1]
 8: - [x] Brave Search API integration - Use middleware for rate limiting[5]
 9: 
10: ## Development Workflow Tools
11: - [x] Magic-UI component generation - Implement with Zustand store slices[1]
12: - [x] Gemini CLI context optimization - Use computed state for derived values[1]
13: - [x] Repomix code context generation - Implement with selective store loading[1]
14: - [x] Browser tools for debugging - Use devtools middleware for state inspection[2][5]
15: - [x] Directus CMS integration - Model as events rather than setters[3]
16: 
17: ## Automation Patterns
18: - [x] CI/CD integration with MCP tools - Implement with async actions[4]
19: - [x] Automated testing workflows - Use mock store creation for tests[5]
20: - [x] Code generation pipelines - Implement with event-based actions[3]
21: - [x] Documentation generation - Use computed state for dynamic docs[1]
22: - [x] Performance monitoring - Implement with middleware logging[2][5]
23: 
24: ## Integration Strategies
25: - [x] Tool chaining patterns - Use Zustand for cross-tool state[1]
26: - [x] Error handling across tools - Implement with async action patterns[4]
27: - [x] Authentication management - Use Payload's auth flow with Zustand[3]
28: - [x] Rate limiting strategies - Implement with middleware[5]
29: - [x] Caching mechanisms - Use persist middleware with TTL[2]
30: 
31: ## Zustand Best Practices for MCP
32: 1. **Store Organization** - Create separate stores for distinct concerns[1]
33: 2. **Selective Subscriptions** - Subscribe only to needed state slices[1]
34: 3. **Computed State** - Derive values rather than recomputing[1]
35: 4. **Middleware Caution** - Align with application requirements[1]
36: 5. **Event Modeling** - Model actions as events, not setters[3]
37: 
38: ```typescript
39: // MCP tool integration example
40: import { create } from 'zustand';
41: import { devtools, persist } from 'zustand/middleware';
42: 
43: const useMCPStore = create(
44:   devtools(
45:     persist(
46:       (set) => ({
47:         tools: [],
48:         addTool: (tool) => set((state) => ({ tools: [...state.tools, tool] })),
49:         removeTool: (id) => set((state) => ({ 
50:           tools: state.tools.filter(t => t.id !== id) 
51:         })),
52:       }),
53:       { name: 'mcp-tools-store' }
54:     )
55:   )
56: );
57: ```
58: 
59: ## Files to Create
60: - `context7_advanced.md` - Advanced Context7 usage patterns
61: - `taskmaster_workflows.md` - Project management workflows
62: - `gemini_cli_optimization.md` - Context window optimization
63: - `repomix_automation.md` - Code context automation
64: - `tool_integration_patterns.md` - Cross-tool integration
</file>

<file path="llm_context/mcp_tools/repomix_automation.md">
 1: # Repomix Code Context Automation
 2: 
 3: ## Automated Context Generation
 4: - [x] File selection strategies - Use concise prompts and retrieve verified functions/APIs[1][3]
 5: - [x] Context filtering patterns - Incorporate project-specific conventions[1][4]
 6: - [x] Output format optimization - Use Context7 structured documentation[1][2]
 7: - [x] Integration with CI/CD - Pre-commit hooks with CI/CD pipelines[1][5]
 8: - [x] Selective code inclusion - Include verified snippets and APIs[1][3]
 9: 
10: ## Workflow Integration
11: - [x] Gemini CLI integration - Requires project-specific details
12: - [x] Pre-commit hook setup - Enforce code quality in CI/CD[1][5]
13: - [x] Automated documentation updates - Context7 dynamic fetching[1][2]
14: - [x] Context validation workflows - Requires workflow understanding
15: - [x] Multi-project support - Requires project-specific details
16: 
17: ## Optimization Strategies
18: - [x] Large codebase handling - Implement hierarchical context loading[1][3]
19: - [x] Context relevance scoring - Use TF-IDF and semantic similarity[1][4]
20: - [x] Incremental context updates - Implement change detection[1][5]
21: - [x] Performance optimization - Use caching and parallel processing[1][2]
22: - [x] Memory usage management - Implement LRU caching[1][5]
23: 
24: ## Project-Specific Patterns
25: - [x] Payload collection context - Map collection schemas to context[1][3]
26: - [x] Next.js app structure context - Use version-specific queries[1][2]
27: - [x] Component dependency mapping - Implement with AST analysis[1][4]
28: - [x] API endpoint documentation - Generate from route handlers[1][3]
29: - [x] Database schema context - Integrate with ORM definitions[1][5]
30: 
31: ## Implementation Goals
32: - [x] Automated context pipeline - Set up with GitHub Actions[1][5]
33: - [x] Smart file filtering - Use path patterns and relevance scoring[1][4]
34: - [x] Context quality metrics - Implement precision/recall tracking[1][3]
35: - [x] Integration testing - Add to CI/CD pipeline[1][5]
36: - [x] Performance monitoring - Track token usage and latency[1][2]
37: 
38: ## Best Practices
39: 1. **Installation** - Use npm package `@upstash/repomix`[1][2]
40: ```bash
41: npm install @upstash/repomix
42: ```
43: 2. **Configuration** - Set context sources and priorities[1][4]
44: ```json
45: {
46:   "sources": [
47:     { "type": "payload", "priority": 1 },
48:     { "type": "nextjs", "priority": 2 }
49:   ],
50:   "maxTokens": 4000,
51:   "refreshInterval": "1h"
52: }
53: ```
54: 3. **Query Optimization** - Use specific keywords for better results[1][2]
55: 4. **Error Handling** - Implement fallback strategies[1][5]
56: 5. **Version Control** - Sync with repository branches[1][3]
57: 
58: ## Context7 Integration
59: - Use `use context7` directive in prompts[1][2]
60: - Specify library versions to avoid outdated docs[1][3]
61: - Combine with other MCP tools for enhanced capabilities[1][4]
62: - Monitor token usage for cost optimization[1][5]
63: - Verify critical code snippets before implementation[1][2]
</file>

<file path="llm_context/payload3/data_models.md">
  1: # Payload 3.0 Data Models and Relationships
  2: 
  3: This document outlines the data models and their relationships within the Payload CMS, designed for a restaurant or similar business management system. It highlights key fields, relationships, and notes on Payload 3.0 features, including the Lexical WYSIWYG editor.
  4: 
  5: ## Collections Overview
  6: 
  7: ### 1. `Users`
  8: *   **Slug**: `users`
  9: *   **Purpose**: Manages user accounts, authentication, and authorization.
 10: *   **Key Fields**: `email` (default), `first_name`, `last_name`, `phone`, `employee_id`, `roles` (select, hasMany), `status` (select), `locations` (relationship to `locations`, hasMany), `primary_location` (relationship to `locations`), `employment_details` (group), `profile_photo` (relationship to `media`), `jobs` (relationship to `jobs`, hasMany).
 11: *   **Relationships**:
 12:     *   One-to-many with `Locations` (via `locations` and `primary_location`)
 13:     *   One-to-many with `Jobs` (via `jobs`)
 14:     *   One-to-one with `Media` (via `profile_photo`)
 15: *   **Payload 3.0 Notes**: Leverages Payload's built-in authentication (`auth: true`). The `roles` field is critical for Role-Based Access Control (RBAC).
 16: 
 17: ### 2. `Media`
 18: *   **Slug**: `media`
 19: *   **Purpose**: Handles file uploads (images, PDFs, videos).
 20: *   **Key Fields**: `alt` (text), `caption` (textarea), `uploadedBy` (relationship to `users`).
 21: *   **Configuration**: `upload: true` enables media capabilities. `imageSizes` are defined for responsive image handling.
 22: *   **Relationships**:
 23:     *   Many-to-one with `Users` (via `uploadedBy`)
 24: *   **Payload 3.0 Notes**: The `upload` property is a core feature for managing assets.
 25: 
 26: ### 3. `Contacts`
 27: *   **Slug**: `contacts`
 28: *   **Purpose**: Stores contact information for various entities (customers, vendors, contractors).
 29: *   **Key Fields**: `first_name`, `last_name`, `email`, `phone`, `company`, `contact_type`, `toast_id`, `brevo_id`, `vip_id`, `visit_frequency`, `last_visit`, `total_visits`, `average_spend`, `notes`, `marketing_consent`, `birthday`, `anniversary`.
 30: *   **Relationships**:
 31:     *   Many-to-many with `Locations` (via `associated_locations`)
 32:     *   Many-to-many with `Messages` (via `associated_messages`)
 33:     *   Many-to-one with `Locations` (via `preferred_location`)
 34: *   **Payload 3.0 Notes**: Demonstrates `beforeChange` and `afterChange` hooks for custom logic (e.g., auto-generating `vip_id`).
 35: 
 36: ### 4. `DietaryRestrictions`
 37: *   **Slug**: `dietary-restrictions`
 38: *   **Purpose**: Manages common dietary restrictions and allergies.
 39: *   **Key Fields**: `name`, `description`.
 40: *   **Relationships**: Expected to be related to `MenuItems` (not explicitly defined in provided files).
 41: 
 42: ### 5. `DrinkMenuItems`
 43: *   **Slug**: `drinkMenuItems`
 44: *   **Purpose**: Stores information about drink menu items.
 45: *   **Key Fields**: `name`, `description`, `price`, `category` (relationship to `drinkSubcategories`), `active`.
 46: *   **Relationships**:
 47:     *   Many-to-one with `DrinkSubcategories` (via `category`)
 48: 
 49: ### 6. `DrinkSubcategories`
 50: *   **Slug**: `drinkSubcategories`
 51: *   **Purpose**: Defines categories for drink menu items.
 52: *   **Key Fields**: `name`.
 53: *   **Relationships**:
 54:     *   One-to-many with `DrinkMenuItems`
 55: 
 56: ### 7. `EmployeeRatings`
 57: *   **Slug**: `employee-ratings`
 58: *   **Purpose**: Tracks employee performance ratings.
 59: *   **Key Fields**: `employee_id` (relationship to `users`), `location_id` (relationship to `locations`), `data_date`, `rating`, `manager_report_id` (relationship to `managerReports`), `employee_notes` (richText), `internal_notes` (textarea).
 60: *   **Relationships**:
 61:     *   Many-to-one with `Users` (via `employee_id`)
 62:     *   Many-to-one with `Locations` (via `location_id`)
 63:     *   Many-to-one with `ManagerReports` (via `manager_report_id`)
 64: *   **Payload 3.0 Notes**: Uses `richText` field type, powered by the Lexical WYSIWYG editor.
 65: 
 66: ### 8. `Features`
 67: *   **Slug**: `features`
 68: *   **Purpose**: Manages feature flags for the application.
 69: *   **Key Fields**: `name`, `enabled`.
 70: 
 71: ### 9. `HotspotLogins`
 72: *   **Slug**: `hotspot-logins`
 73: *   **Purpose**: Stores WiFi hotspot login data and customer information.
 74: *   **Key Fields**: `location` (relationship to `locations`), `customer_name`, `customer_email`, `marketing_consent`.
 75: *   **Relationships**:
 76:     *   Many-to-one with `Locations` (via `location`)
 77: 
 78: ### 10. `Incidents`
 79: *   **Slug**: `incidents`
 80: *   **Purpose**: Records incidents or issues.
 81: *   **Key Fields**: `title`, `description`, `date`, `location` (relationship to `locations`), `reportedBy` (relationship to `users`), `status`.
 82: *   **Relationships**:
 83:     *   Many-to-one with `Locations` (via `location`)
 84:     *   Many-to-one with `Users` (via `reportedBy`)
 85: 
 86: ### 11. `Jobs`
 87: *   **Slug**: `jobs`
 88: *   **Purpose**: Defines job roles or positions.
 89: *   **Key Fields**: `name`.
 90: *   **Relationships**:
 91:     *   One-to-many with `Users`
 92: 
 93: ### 12. `Locations`
 94: *   **Slug**: `locations`
 95: *   **Purpose**: Manages physical locations of the business.
 96: *   **Key Fields**: `name`, `address`, `city`, `state`, `zip`, `phone`, `email`.
 97: *   **Relationships**:
 98:     *   One-to-many with `Users`, `Contacts`, `HotspotLogins`, `Incidents`, `ManagerReports`, `QrFeedback`, `Reviews`, `ServerReports`, `Upgrades`, `Questions`.
 99: 
100: ### 13. `ManagerReports`
101: *   **Slug**: `managerReports`
102: *   **Purpose**: Stores daily or shift manager reports.
103: *   **Key Fields**: `title`, `date`, `manager` (relationship to `users`), `location` (relationship to `locations`), `notes`.
104: *   **Relationships**:
105:     *   Many-to-one with `Users` (via `manager`)
106:     *   Many-to-one with `Locations` (via `location`)
107:     *   One-to-many with `EmployeeRatings`
108: 
109: ### 14. `MessageTypes`
110: *   **Slug**: `message-types`
111: *   **Purpose**: Defines categories for customer messages.
112: *   **Key Fields**: `name`.
113: *   **Relationships**:
114:     *   One-to-many with `Messages`
115: 
116: ### 15. `Messages`
117: *   **Slug**: `messages`
118: *   **Purpose**: Manages customer messages and inquiries.
119: *   **Key Fields**: `status`, `priority`, `subject`, `from_name`, `from_email`, `from_phone`, `location` (relationship to `locations`), `message_type` (relationship to `message-types`), `message` (richText), `internal_notes` (richText), `assigned_to` (relationship to `users`), `response_sent`, `response_date`, `attachments` (relationship to `media`, hasMany).
120: *   **Relationships**:
121:     *   Many-to-one with `Locations` (via `location`)
122:     *   Many-to-one with `MessageTypes` (via `message_type`)
123:     *   Many-to-one with `Users` (via `assigned_to`)
124:     *   Many-to-many with `Media` (via `attachments`)
125: *   **Payload 3.0 Notes**: Uses `richText` fields for `message` and `internal_notes`, leveraging the Lexical WYSIWYG editor.
126: 
127: ### 16. `QrFeedback`
128: *   **Slug**: `qrFeedback`
129: *   **Purpose**: Collects feedback via QR codes.
130: *   **Key Fields**: `rating`, `comment`, `location` (relationship to `locations`), `user` (relationship to `users`).
131: *   **Relationships**:
132:     *   Many-to-one with `Locations` (via `location`)
133:     *   Many-to-one with `Users` (via `user`)
134: 
135: ### 17. `Questions`
136: *   **Slug**: `questions`
137: *   **Purpose**: Manages custom questions for reports.
138: *   **Key Fields**: `status`, `sort`, `question`, `shift_timing`, `shift_selection` (hasMany), `min_characters`, `locations` (relationship to `locations`, hasMany).
139: *   **Relationships**:
140:     *   Many-to-many with `Locations` (via `locations`)
141: 
142: ### 18. `ReviewKeywords`
143: *   **Slug**: `reviewKeywords`
144: *   **Purpose**: Defines keywords for reviews.
145: *   **Key Fields**: `keyword`.
146: *   **Relationships**:
147:     *   One-to-many with `Reviews`
148: 
149: ### 19. `Reviews`
150: *   **Slug**: `reviews`
151: *   **Purpose**: Stores customer reviews.
152: *   **Key Fields**: `title`, `rating`, `comment`, `user` (relationship to `users`), `location` (relationship to `locations`), `keywords` (relationship to `reviewKeywords`, hasMany).
153: *   **Relationships**:
154:     *   Many-to-one with `Users` (via `user`)
155:     *   Many-to-one with `Locations` (via `location`)
156:     *   Many-to-many with `ReviewKeywords` (via `keywords`)
157: 
158: ### 20. `ServerReports`
159: *   **Slug**: `serverReports`
160: *   **Purpose**: Stores server reports.
161: *   **Key Fields**: `title`, `date`, `server` (relationship to `users`), `location` (relationship to `locations`), `notes`.
162: *   **Relationships**:
163:     *   Many-to-one with `Users` (via `server`)
164:     *   Many-to-one with `Locations` (via `location`)
165: 
166: ### 21. `ShiftTypes`
167: *   **Slug**: `shiftTypes`
168: *   **Purpose**: Defines types of shifts.
169: *   **Key Fields**: `name`.
170: 
171: ### 22. `UpgradeTypes`
172: *   **Slug**: `upgrade-types`
173: *   **Purpose**: Defines categories for upgrades.
174: *   **Key Fields**: `name`.
175: *   **Relationships**:
176:     *   One-to-many with `Upgrades`
177: 
178: ### 23. `Upgrades`
179: *   **Slug**: `upgrades`
180: *   **Purpose**: Tracks system and facility upgrades.
181: *   **Key Fields**: `name`, `location` (relationship to `locations`), `upgrade_type` (relationship to `upgrade-types`), `status`, `description` (richText), `cost`, `vendor` (relationship to `contacts`), `scheduled_date`, `completion_date`, `notes` (richText), `attachments` (relationship to `media`, hasMany).
182: *   **Relationships**:
183:     *   Many-to-one with `Locations` (via `location`)
184:     *   Many-to-one with `UpgradeTypes` (via `upgrade_type`)
185:     *   Many-to-one with `Contacts` (via `vendor`)
186:     *   Many-to-many with `Media` (via `attachments`)
187: *   **Payload 3.0 Notes**: Uses `richText` fields for `description` and `notes`, leveraging the Lexical WYSIWYG editor.
188: 
189: ## Lexical WYSIWYG Editor in Payload 3.0
190: 
191: Payload 3.0 integrates the Lexical WYSIWYG editor for `richText` fields, offering a modern and extensible content editing experience. Key benefits include:
192: 
193: *   **Performance**: Designed for high performance and responsiveness.
194: *   **Extensibility**: Highly customizable with a plugin-based architecture, allowing for tailored editing features.
195: *   **Accessibility**: Built with accessibility in mind.
196: *   **Collaboration**: Supports collaborative editing features.
197: 
198: Developers can configure Lexical to include various formatting options, embeds, and custom elements, providing a powerful tool for content creators within the Payload admin panel.
</file>

<file path="llm_context/payload3/README.md">
 1: # Payload 3 CMS Documentation
 2: 
 3: ## Core Concepts
 4: - **Data Modeling**: Collections define data structures (e.g., `Users`, `Media`)
 5: - **Lexical Editor**: Rich text editor with block-based content
 6: - **Authentication**: Built-in user auth with access control
 7: - **REST & GraphQL**: Dual API endpoints
 8: 
 9: ## Best Practices
10: ```typescript
11: // Example collection configuration
12: export const Media: CollectionConfig = {
13:   slug: 'media',
14:   access: { read: () => true },
15:   upload: true,
16:   fields: [{ name: 'alt', type: 'text', required: true }]
17: }
18: ```
19: 
20: ## Data Loading Patterns
21: ```typescript
22: // Next.js data fetching with Tanstack Query
23: import { useQuery } from '@tanstack/react-query';
24: 
25: const fetchMedia = async () => {
26:   const res = await fetch('/api/media');
27:   return res.json();
28: };
29: 
30: function MediaGallery() {
31:   const { data } = useQuery({ queryKey: ['media'], queryFn: fetchMedia });
32:   // Render media items
33: }
</file>

<file path="llm_context/payload3/user_documentation.md">
 1: # User Guide: Payload CMS Data Management
 2: 
 3: This guide provides an overview of the data collections within the Payload CMS, explaining their purpose and how you can use them to manage your business operations. We'll also highlight key features like the rich text editor.
 4: 
 5: ## Understanding Your Data Collections
 6: 
 7: Payload CMS organizes your information into **Collections**, which are like tables in a database. Each collection is designed to manage a specific type of data, such as users, locations, or menu items. Here's a look at the main collections you'll be working with:
 8: 
 9: ### 1. Users
10: *   **Purpose**: Manages all user accounts, including staff (admins, managers, employees) and potentially customers. This is where you'll set up user roles and permissions.
11: *   **Key Information**: Email, first name, last name, phone, employee ID, assigned roles, employment status, associated locations, and profile photos.
12: 
13: ### 2. Media
14: *   **Purpose**: Stores all your uploaded files, such as images for menu items, documents, or videos. Payload automatically handles different image sizes for optimal display.
15: *   **Key Information**: Alternative text (for accessibility), captions, and who uploaded the file.
16: 
17: ### 3. Contacts
18: *   **Purpose**: Keeps track of contact information for various individuals or organizations you interact with, including customers, vendors, and contractors.
19: *   **Key Information**: Names, email, phone, company, contact type, visit history, and marketing preferences.
20: 
21: ### 4. Dietary Restrictions
22: *   **Purpose**: A list of common dietary restrictions and allergies (e.g., Gluten-Free, Vegan, Nut Allergy). This helps you categorize and manage menu items or customer preferences.
23: 
24: ### 5. Drink Menu Items
25: *   **Purpose**: Manages all the drinks offered on your menu.
26: *   **Key Information**: Drink name, description, price, and its category (e.g., Coffee, Tea, Soda).
27: 
28: ### 6. Drink Subcategories
29: *   **Purpose**: Organizes your drink menu items into specific subcategories.
30: 
31: ### 7. Employee Ratings
32: *   **Purpose**: Allows managers to record and track employee performance ratings.
33: *   **Key Information**: Employee, location, date of rating, rating score (1-5 stars), and notes.
34: 
35: ### 8. Features
36: *   **Purpose**: Used to enable or disable certain features within the application. This is typically managed by administrators.
37: 
38: ### 9. Hotspot Logins
39: *   **Purpose**: Records data from WiFi hotspot logins, including customer details and consent for marketing.
40: 
41: ### 10. Incidents
42: *   **Purpose**: For logging and tracking any incidents or issues that occur, such as equipment malfunctions or customer complaints.
43: *   **Key Information**: Title, description, date, location, who reported it, and current status.
44: 
45: ### 11. Jobs
46: *   **Purpose**: Defines different job roles or positions within your organization.
47: 
48: ### 12. Locations
49: *   **Purpose**: Manages information about all your physical business locations.
50: *   **Key Information**: Name, address, contact details.
51: 
52: ### 13. Manager Reports
53: *   **Purpose**: Stores daily or shift reports submitted by managers.
54: *   **Key Information**: Report title, date, manager, location, and notes.
55: 
56: ### 14. Message Types
57: *   **Purpose**: Categorizes incoming customer messages (e.g., General Inquiry, Complaint, Feedback).
58: 
59: ### 15. Messages
60: *   **Purpose**: Manages all customer messages and inquiries received through various channels.
61: *   **Key Information**: Status, priority, subject, sender details, message content, internal notes, assigned staff, and attachments.
62: 
63: ### 16. QR Feedback
64: *   **Purpose**: Collects customer feedback submitted via QR codes.
65: *   **Key Information**: Rating, comment, location, and associated user.
66: 
67: ### 17. Questions
68: *   **Purpose**: Manages custom questions that can be displayed on server or manager reports.
69: *   **Key Information**: Question text, when it should be displayed (AM/PM), which roles should see it, and minimum character requirements for answers.
70: 
71: ### 18. Review Keywords
72: *   **Purpose**: Defines keywords that can be associated with customer reviews.
73: 
74: ### 19. Reviews
75: *   **Purpose**: Stores customer reviews and feedback.
76: *   **Key Information**: Title, rating, comment, associated user, location, and relevant keywords.
77: 
78: ### 20. Server Reports
79: *   **Purpose**: Stores reports submitted by servers.
80: *   **Key Information**: Title, date, server, location, and notes.
81: 
82: ### 21. Shift Types
83: *   **Purpose**: Defines different types of shifts (e.g., Morning, Evening, Weekend).
84: 
85: ### 22. Upgrade Types
86: *   **Purpose**: Categorizes different types of system or facility upgrades (e.g., POS System, Kitchen Equipment).
87: 
88: ### 23. Upgrades
89: *   **Purpose**: Tracks ongoing or completed system and facility upgrades.
90: *   **Key Information**: Name, location, type of upgrade, status, description, cost, vendor, scheduled dates, and attachments.
91: 
92: ## Using the Rich Text Editor (Lexical WYSIWYG)
93: 
94: Several fields in Payload CMS, such as `Employee Notes` in Employee Ratings, `Message Content` and `Internal Notes` in Messages, and `Description` and `Notes` in Upgrades, use a powerful **Rich Text Editor**. This editor allows you to format text, add headings, lists, links, and more, similar to a word processor.
95: 
96: This editor is powered by **Lexical**, a modern and highly performant technology. This means you get a smooth and responsive experience when creating and editing content, ensuring your descriptions and notes are clear and well-formatted.
</file>

<file path="llm_context/responses/prompt_template.md">
  1: ```
  2: # LLM-Friendly Scripting Prompt for TypeScript Error Resolution in Payload CMS 3.0
  3: 
  4: # This script provides guidance for resolving common TypeScript compilation errors
  5: # in Payload CMS 3.0 projects, specifically related to import paths and
  6: # missing type annotations for Payload-specific functions.
  7: 
  8: # --- INPUT PARAMETERS ---
  9: # @param {string} error_type - The type of TypeScript error encountered (e.g., "import_path", "missing_type_annotation").
 10: # @param {string} file_path - The path to the file where the error is occurring.
 11: # @param {string} [code_snippet] - An optional code snippet related to the error for more specific analysis.
 12: # @param {string} [function_type] - For "missing_type_annotation" errors, specify the type of Payload function (e.g., "access_control", "hook", "condition").
 13: 
 14: # --- SCRIPT LOGIC ---
 15: 
 16: # 1. Handle Import Path Errors
 17: IF error_type == "import_path":
 18:     PRINT "## Resolving Import Path Errors in Payload CMS 3.0"
 19:     PRINT "Payload CMS 3.0 has consolidated many core types and utilities directly under the 'payload' package."
 20:     PRINT "You should update your imports from 'payload/types' to 'payload'."
 21:     PRINT ""
 22:     PRINT "### Incorrect Import (Payload 2.x style):"
 23:     PRINT "```typescript"
 24:     PRINT "import { CollectionConfig } from 'payload/types';"
 25:     PRINT "import { Field } from 'payload/types';"
 26:     PRINT "```"
 27:     PRINT ""
 28:     PRINT "### Correct Import (Payload 3.0 style):"
 29:     PRINT "```typescript"
 30:     PRINT "import { CollectionConfig, Field, Access, PayloadRequest, BeforeChangeHook, AfterChangeHook, CollectionBeforeChangeHook, CollectionAfterChangeHook } from 'payload';"
 31:     PRINT "```"
 32:     PRINT ""
 33:     PRINT "ACTION: In file '" + file_path + "', replace imports from 'payload/types' with direct imports from 'payload'."
 34: 
 35: # 2. Handle Missing Type Annotation Errors
 36: ELSE IF error_type == "missing_type_annotation":
 37:     PRINT "## Resolving Missing Type Annotations in Payload CMS 3.0"
 38:     PRINT "Payload CMS functions require specific type annotations for their parameters to ensure type safety and prevent errors."
 39:     PRINT ""
 40: 
 41:     IF function_type == "access_control":
 42:         PRINT "### Access Control Functions"
 43:         PRINT "Access control functions (e.g., `access.read`, `access.create`) receive an object with `req` (PayloadRequest), `doc`, `id`, and `collection`."
 44:         PRINT "You should also ensure your `PayloadRequest` interface is extended to include your custom `User` type."
 45:         PRINT ""
 46:         PRINT "### Correct Typing for Access Control:"
 47:         PRINT "```typescript"
 48:         PRINT "import { Access, PayloadRequest } from 'payload';"
 49:         PRINT "import { User } from '../payload-types'; // Adjust path to your User type"
 50:         PRINT ""
 51:         PRINT "export const isAdmin: Access<any, User> = ({ req }) => {"
 52:         PRINT "  return req.user?.role === 'admin';"
 53:         PRINT "};"
 54:         PRINT ""
 55:         PRINT "export const isAdminOrSelf: Access<any, User> = ({ req, id, doc }) => {"
 56:         PRINT "  if (req.user?.role === 'admin') { return true; }"
 57:         PRINT "  if (req.user && id === req.user.id) { return true; }"
 58:         PRINT "  if (req.user && doc && doc.owner === req.user.id) { return true; }"
 59:         PRINT "  return false;"
 60:         PRINT "};"
 61:         PRINT "```"
 62:         PRINT ""
 63:         PRINT "ACTION: In file '" + file_path + "', apply the correct type annotations for your access control functions. Ensure your `PayloadRequest` is extended with your `User` type."
 64: 
 65:     ELSE IF function_type == "hook":
 66:         PRINT "### Hooks (e.g., `beforeChange`, `afterChange`)"
 67:         PRINT "Hooks receive specific parameters depending on their type (e.g., `CollectionBeforeChangeHook`, `CollectionAfterChangeHook`)."
 68:         PRINT ""
 69:         PRINT "### Correct Typing for `beforeChange` Hook:"
 70:         PRINT "```typescript"
 71:         PRINT "import { CollectionBeforeChangeHook, PayloadRequest } from 'payload';"
 72:         PRINT "import { Product } from '../payload-types'; // Adjust path to your data type"
 73:         PRINT ""
 74:         PRINT "export const setProductOwner: CollectionBeforeChangeHook<Product> = async ({"
 75:         PRINT "  data, req, operation, originalDoc,"
 76:         PRINT "}) => {"
 77:         PRINT "  if (operation === 'create' && req.user) {"
 78:         PRINT "    return { ...data, owner: req.user.id };"
 79:         PRINT "  }"
 80:         PRINT "  return data;"
 81:         PRINT "};"
 82:         PRINT "```"
 83:         PRINT ""
 84:         PRINT "### Correct Typing for `afterChange` Hook:"
 85:         PRINT "```typescript"
 86:         PRINT "import { CollectionAfterChangeHook, PayloadRequest } from 'payload';"
 87:         PRINT "import { Order } from '../payload-types'; // Adjust path to your data type"
 88:         PRINT ""
 89:         PRINT "export const sendOrderConfirmation: CollectionAfterChangeHook<Order> = async ({"
 90:         PRINT "  doc, req, operation,"
 91:         PRINT "}) => {"
 92:         PRINT "  if (operation === 'create') {"
 93:         PRINT "    console.log(`Order ${doc.id} created.`);"
 94:         PRINT "  }"
 95:         PRINT "  return doc;"
 96:         PRINT "};"
 97:         PRINT "```"
 98:         PRINT ""
 99:         PRINT "ACTION: In file '" + file_path + "', apply the correct type annotations for your hook functions based on their type and parameters."
100: 
101:     ELSE IF function_type == "condition":
102:         PRINT "### Condition Functions (e.g., `fields[].admin.condition`)"
103:         PRINT "Condition functions typically receive `data` (the entire document data) and `siblingData` (data of fields at the same level)."
104:         PRINT ""
105:         PRINT "### Correct Typing for Condition Functions:"
106:         PRINT "```typescript"
107:         PRINT "import { Field } from 'payload';"
108:         PRINT "import { Product } from '../payload-types'; // Adjust path to your data type"
109:         PRINT ""
110:         PRINT "const drinkSizeField: Field = {"
111:         PRINT "  name: 'drinkSize',"
112:         PRINT "  type: 'select',"
113:         PRINT "  options: ['small', 'medium', 'large'],"
114:         PRINT "  admin: {"
115:         PRINT "    condition: (data: Product, siblingData: any) => {"
116:         PRINT "      return data.productType === 'drink';"
117:         PRINT "    },"
118:         PRINT "  },"
119:         PRINT "};"
120:         PRINT "```"
121:         PRINT ""
122:         PRINT "ACTION: In file '" + file_path + "', apply the correct type annotations for your field condition functions."
123: 
124:     ELSE:
125:         PRINT "## Missing Type Annotations"
126:         PRINT "Please specify the 'function_type' parameter (e.g., 'access_control', 'hook', 'condition') for more specific guidance on type annotations."
127:         PRINT "In general, ensure all function parameters in Payload-related functions are explicitly typed."
128:         PRINT "Refer to the Payload CMS 3.0 documentation for specific function signatures."
129: 
130: ELSE:
131:     PRINT "## Unknown Error Type"
132:     PRINT "Please specify a valid 'error_type' parameter (e.g., 'import_path', 'missing_type_annotation') for targeted assistance."
133: 
134: # --- END SCRIPT ---
135: ```
</file>

<file path="llm_context/responses/setup_verification.md">
 1: # Project Setup Verification for Payload 3.0 + Next.js
 2: 
 3: To ensure a robust setup for your Payload 3.0 + Next.js restaurant management system, perform the following verification checks:
 4: 
 5: ### 1. Build Process Verification
 6: 
 7: This step ensures that both your Next.js frontend and Payload backend can be successfully built for production.
 8: 
 9: *   **Next.js Build:**
10:     *   **Command:** `npm run build` (or `yarn build`, `pnpm build`) in your Next.js project root.
11:     *   **Check:** The command should complete without errors, indicating that Next.js has successfully compiled your application for production. Look for output similar to "Compiled successfully" or "Build complete". This will generate the `.next` directory.
12: 
13: *   **Payload Build (if separate):**
14:     *   Payload CMS typically builds as part of the Next.js build process if integrated within the same project. If you have a separate Payload backend, it might have its own build step.
15:     *   **Command (example for a separate Payload build):** `npm run payload:build` (or similar, check your `package.json` scripts).
16:     *   **Check:** Verify successful compilation of Payload's admin UI and server-side code.
17: 
18: ### 2. TypeScript Compilation Checks
19: 
20: Ensuring correct TypeScript compilation is crucial for type safety and catching errors early.
21: 
22: *   **Command:** `tsc --noEmit`
23:     *   **Description:** This command runs the TypeScript compiler to check for type errors without emitting any JavaScript files. It's a quick way to validate your TypeScript code.
24:     *   **Check:** The command should exit with no errors. Any output indicates type errors that need to be resolved.
25: 
26: *   **ESLint with TypeScript:**
27:     *   **Command:** `npm run lint` (or `yarn lint`, `pnpm lint`)
28:     *   **Description:** Assuming your ESLint is configured for TypeScript, this command will check for code style and potential issues.
29:     *   **Check:** The command should report no linting errors or warnings.
30: 
31: ### 3. Payload Connection Testing
32: 
33: Verify that your Next.js application can successfully connect to and interact with the Payload CMS backend.
34: 
35: *   **Start Payload/Next.js Development Server:**
36:     *   **Command:** `npm run dev` (or `yarn dev`, `pnpm dev`) in your project root.
37:     *   **Check:** Ensure both the Next.js frontend and Payload CMS backend (admin UI) are running and accessible, typically on `http://localhost:3000` and `http://localhost:3000/admin` respectively.
38: 
39: *   **Access Payload Admin UI:**
40:     *   **Check:** Navigate to `http://localhost:3000/admin` in your browser. You should see the Payload CMS login screen or dashboard. This confirms the Payload server is running and serving its admin interface.
41: 
42: *   **Test API Endpoints:**
43:     *   **Check:** Use a tool like Postman, Insomnia, `curl`, or your browser to hit a public Payload API endpoint (e.g., `http://localhost:3000/api/users` or `http://localhost:3000/api/media`).
44:     *   **Command (example using curl):** `curl http://localhost:3000/api/media`
45:     *   **Check:** You should receive a valid JSON response, even if it's an empty array, indicating that the API is reachable and functioning.
46: 
47: *   **Database Connection:**
48:     *   **Check:** When starting the Payload server, observe the console output for messages indicating a successful database connection (e.g., "Connected to MongoDB"). If there are connection errors, verify your `DATABASE_URI` environment variable.
49: 
50: ### 4. Dependency Validation
51: 
52: Ensure all project dependencies are correctly installed and compatible.
53: 
54: *   **Install Dependencies:**
55:     *   **Command:** `npm install` (or `yarn install`, `pnpm install`)
56:     *   **Check:** This command should complete without errors. Any errors here indicate issues with `package.json` or network connectivity.
57: 
58: *   **Check for Outdated Dependencies (Optional but Recommended):**
59:     *   **Command:** `npm outdated` (or `yarn outdated`, `pnpm outdated`)
60:     *   **Check:** This command lists outdated packages. While not strictly a "failure" if outdated, it's good practice to keep dependencies updated to avoid security vulnerabilities and compatibility issues.
61: 
62: *   **Verify `node_modules`:**
63:     *   **Check:** Ensure the `node_modules` directory exists in your project root and contains the installed packages. Its presence confirms that `npm install` (or equivalent) ran successfully.
64: 
65: By systematically performing these checks, you can ensure that your Payload 3.0 + Next.js project is correctly set up and ready for development.
</file>

<file path="llm_context/responses/typescript_error_resolution_v2.md">
  1: # Resolving Advanced TypeScript Errors in Payload CMS 3.0 Collections
  2: 
  3: This document provides guidance on fixing more advanced TypeScript errors in your Payload CMS 3.0 collection files, specifically addressing issues with extending User types, defining CollectionSlug unions, and implementing properly typed access control functions.
  4: 
  5: ## 1. Extending User Types (Adding `roles` and `locations`)
  6: 
  7: Payload CMS automatically generates a `payload-types.ts` file (or similar) that contains the TypeScript interfaces for your collections. To add custom properties like `roles` and `locations` to your `User` type, you need to extend the generated `User` interface.
  8: 
  9: This is typically done by augmenting the `payload` module or by directly modifying the generated `payload-types.ts` if you have custom fields on your `Users` collection.
 10: 
 11: **Assumed `payload-types.ts` structure (generated by Payload):**
 12: ```typescript
 13: // payload-types.ts (This file is often auto-generated by Payload)
 14: 
 15: export type User = {
 16:   id: string;
 17:   email: string;
 18:   // ... other default Payload user fields
 19:   createdAt: string;
 20:   updatedAt: string;
 21: };
 22: 
 23: // ... other collection types
 24: ```
 25: 
 26: **To extend the `User` type, you would typically add these fields to your `Users` collection definition in `src/collections/Users.ts` (or similar). Payload will then generate the `payload-types.ts` with these fields included.**
 27: 
 28: **Example `src/collections/Users.ts` with `roles` and `locations` fields:**
 29: 
 30: ```typescript
 31: import { CollectionConfig } from 'payload';
 32: 
 33: const Users: CollectionConfig = {
 34:   slug: 'users',
 35:   auth: true,
 36:   admin: {
 37:     use = 'email',
 38:   },
 39:   fields: [
 40:     // Email added by default
 41:     // Password added by default
 42:     {
 43:       name: 'roles',
 44:       type: 'select',
 45:       has  Many: true,
 46:       defaultValue: ['employee'],
 47:       options: [
 48:         {
 49:           label: 'Admin',
 50:           value: 'admin',
 51:         },
 52:         {
 53:           label: 'Employee',
 54:           value: 'employee',
 55:         },
 56:         {
 57:           label: 'Manager',
 58:           value: 'manager',
 59:         },
 60:       ],
 61:     },
 62:     {
 63:       name: 'locations',
 64:       type: 'relationship',
 65:       relationTo: 'locations', // Assuming you have a 'locations' collection
 66:       hasMany: true,
 67:     },
 68:   ],
 69: };
 70: 
 71: export default Users;
 72: ```
 73: 
 74: After adding these fields to your `Users` collection and running Payload (which triggers type generation), your `User` type in `payload-types.ts` should automatically include `roles` and `locations`:
 75: 
 76: ```typescript
 77: // payload-types.ts (After Payload generates types)
 78: 
 79: export type User = {
 80:   id: string;
 81:   email: string;
 82:   roles?: ('admin' | 'employee' | 'manager')[]; // Now includes roles
 83:   locations?: string[] | Location[]; // Now includes locations (adjust type based on your Location collection)
 84:   createdAt: string;
 85:   updatedAt: string;
 86: };
 87: 
 88: // ... other collection types
 89: ```
 90: 
 91: **If you need to manually augment the `PayloadRequest` to ensure `req.user` is correctly typed with your custom fields, you can create a declaration file (e.g., `src/types/payload-custom.d.ts`):**
 92: 
 93: ```typescript
 94: // src/types/payload-custom.d.ts
 95: 
 96: import { User as PayloadUser } from '../payload-types'; // Import the generated User type
 97: 
 98: declare module 'payload' {
 99:   export interface PayloadRequest {
100:     user?: PayloadUser; // Extend PayloadRequest to include your custom User type
101:   }
102: }
103: ```
104: 
105: ## 2. Defining CollectionSlug Unions
106: 
107: To ensure type safety when referring to collection slugs (names), you can create a union type that lists all your collection slugs. This is particularly useful for relationship fields or when dynamically referencing collections.
108: 
109: First, ensure your `payload-types.ts` (or similar generated file) exports a type that represents all your collection slugs. Payload 3.0 typically generates a `CollectionSlug` type.
110: 
111: **Example `payload-types.ts` (generated):**
112: 
113: ```typescript
114: // payload-types.ts
115: 
116: export type CollectionSlug = 'users' | 'media' | 'contacts' | 'locations'; // Example
117: 
118: // ... rest of the generated types
119: ```
120: 
121: If this `CollectionSlug` type is not automatically generated or doesn't include all your collections, you can define it manually:
122: 
123: ```typescript
124: // src/types/collection-slugs.ts (or similar)
125: 
126: export type AppCollectionSlug =
127:   | 'users'
128:   | 'media'
129:   | 'contacts'
130:   | 'dietaryRestrictions'
131:   | 'drinkMenuItems'
132:   | 'drinkSubcategories'
133:   | 'employeeRatings'
134:   | 'features'
135:   | 'hotspotLogins'
136:   | 'incidents'
137:   | 'jobs'
138:   | 'locations'
139:   | 'managerReports'
140:   | 'messages'
141:   | 'messageTypes'
142:   | 'qrFeedback'
143:   | 'questions'
144:   | 'reviewKeywords'
145:   | 'reviews'
146:   | 'serverReports'
147:   | 'shiftTypes'
148:   | 'upgrades'
149:   | 'upgradeTypes';
150: 
151: // You can then use AppCollectionSlug in your code:
152: // const myCollection: AppCollectionSlug = 'users';
153: ```
154: 
155: ## 3. Implementing Proper Access Controls with TypeScript
156: 
157: Access control functions in Payload 3.0 should be strongly typed using the `Access` type imported from `payload`. This type takes two generic arguments: `CollectionType` (the type of the collection the access function is for) and `UserType` (your custom user type).
158: 
159: **Key points for typed access control:**
160: *   Import `Access` and `PayloadRequest` from `'payload'`.
161: *   Import your custom `User` type (e.g., from `../payload-types`).
162: *   Destructure `req` from the access context and use `req.user` which should now be correctly typed with your custom `User` properties (like `roles` and `locations`).
163: 
164: **Example Access Control Functions with `roles` and `locations`:**
165: 
166: ```typescript
167: import { Access, PayloadRequest } from 'payload';
168: import { User, Location } from '../payload-types'; // Assuming User and Location types
169: 
170: // Access function to check if the user is an admin
171: export const isAdmin: Access<any, User> = ({ req }) => {
172:   return req.user?.roles?.includes('admin') || false;
173: };
174: 
175: // Access function to check if the user is an employee
176: export const isEmployee: Access<any, User> = ({ req }) => {
177:   return req.user?.roles?.includes('employee') || false;
178: };
179: 
180: // Access function to check if the user is a manager
181: export const isManager: Access<any, User> = ({ req }) => {
182:   return req.user?.roles?.includes('manager') || false;
183: };
184: 
185: // Access function to check if the user is an admin OR if the document belongs to one of their assigned locations
186: export const isAdminOrHasLocationAccess: Access<any, User> = ({ req, doc }) => {
187:   // Admins have full access
188:   if (req.user?.roles?.includes('admin')) {
189:     return true;
190:   }
191: 
192:   // If the user has locations assigned and the document has a 'location' field
193:   if (req.user?.locations && doc && doc.location) {
194:     // Ensure doc.location is a string (ID) or an object with an ID
195:     const docLocationId = typeof doc.location === 'object' ? doc.location.id : doc.location;
196: 
197:     // Check if the user's locations include the document's location
198:     return req.user.locations.some(userLocation => {
199:       const userLocationId = typeof userLocation === 'object' ? userLocation.id : userLocation;
200:       return userLocationId === docLocationId;
201:     });
202:   }
203: 
204:   return false;
205: };
206: 
207: // Example usage in a collection configuration (e.g., in src/collections/Orders.ts):
208: 
209: // export const Orders: CollectionConfig = {
210: //   slug: 'orders',
211: //   access: {
212: //     read: isAdminOrHasLocationAccess, // Only admins or users with matching location can read orders
213: //     create: isEmployee, // Only employees can create orders
214: //     update: isAdminOrHasLocationAccess, // Only admins or users with matching location can update orders
215: //     delete: isAdmin, // Only admins can delete orders
216: //   },
217: //   fields: [
218: //     {
219: //       name: 'location',
220: //       type: 'relationship',
221: //       relationTo: 'locations',
222: //       required: true,
223: //     },
224: //     // ... other fields
225: //   ],
226: // };
227: ```
228: 
229: By implementing these patterns, you should be able to resolve the TypeScript errors related to User types, CollectionSlug unions, and access control functions in your Payload CMS 3.0 project.
</file>

<file path="llm_context/responses/typescript_errors.md">
  1: # Resolving TypeScript Compilation Errors in Payload CMS 3.0
  2: 
  3: This document addresses common TypeScript compilation errors in Payload CMS 3.0 projects, specifically focusing on import path issues and missing type annotations for Payload-specific functions.
  4: 
  5: ## 1. Correct Import Patterns
  6: 
  7: In Payload CMS 3.0, many core types and utilities are now directly exported from the `payload` package, simplifying imports. The previous `payload/types` path is often no longer necessary for common types like `CollectionConfig`, `Field`, `Access`, `PayloadRequest`, etc.
  8: 
  9: **Incorrect Import (Payload 2.x style):**
 10: ```typescript
 11: import { CollectionConfig } from 'payload/types';
 12: import { Field } from 'payload/types';
 13: ```
 14: 
 15: **Correct Import (Payload 3.0 style):**
 16: ```typescript
 17: import { CollectionConfig, Field, Access, PayloadRequest, BeforeChangeHook, AfterChangeHook, CollectionBeforeChangeHook, CollectionAfterChangeHook } from 'payload';
 18: ```
 19: 
 20: **Action:** Update all your collection files and other Payload-related files to import these types directly from `'payload'`.
 21: 
 22: ## 2. Missing Type Annotations for Function Parameters
 23: 
 24: Payload CMS functions (access controls, hooks, field conditions) provide specific parameters that, when properly typed, eliminate many TypeScript errors and improve code clarity.
 25: 
 26: ### A. Access Control Functions
 27: 
 28: Access control functions (e.g., `access.read`, `access.create`, `access.update`, `access.delete`) receive an object with properties like `req` (the Express request object, extended by Payload), `doc` (the document being accessed/modified), `id`, and `collection`.
 29: 
 30: **Correct Typing for Access Control:**
 31: 
 32: ```typescript
 33: import { Access, PayloadRequest } from 'payload';
 34: import { User } from '../payload-types'; // Assuming you have a User type defined
 35: 
 36: export const isAdmin: Access<any, User> = ({ req }) => {
 37:   // req.user will be typed as User if you extend PayloadRequest correctly
 38:   return req.user?.role === 'admin';
 39: };
 40: 
 41: export const isAdminOrSelf: Access<any, User> = ({ req, id, doc }) => {
 42:   if (req.user?.role === 'admin') {
 43:     return true;
 44:   }
 45: 
 46:   // If the user is not an admin, they can only read/update their own document
 47:   if (req.user && id === req.user.id) {
 48:     return true;
 49:   }
 50: 
 51:   // For read access, if no specific ID is provided, allow if the user is logged in
 52:   // and the document's owner matches the current user (if applicable)
 53:   if (req.user && doc && doc.owner === req.user.id) {
 54:     return true;
 55:   }
 56: 
 57:   return false;
 58: };
 59: 
 60: // Example usage in a collection:
 61: // access: {
 62: //   read: isAdminOrSelf,
 63: //   create: isAdmin,
 64: //   update: isAdminOrSelf,
 65: //   delete: isAdmin,
 66: // },
 67: ```
 68: **Note on `PayloadRequest` and Custom User Types:**
 69: For `req.user` to be correctly typed, you often need to extend Payload's `PayloadRequest` interface to include your custom `User` type. This is typically done in a declaration file (e.g., `src/types/payload-custom.d.ts` or `src/payload-types.ts` if generated by Payload).
 70: 
 71: ```typescript
 72: // Example: src/payload-types.ts (or a custom .d.ts file)
 73: // This is often generated by Payload, but if not, you might need to declare it.
 74: declare module 'payload' {
 75:   export interface PayloadRequest {
 76:     user?: User; // Assuming 'User' is your custom user type
 77:   }
 78: }
 79: ```
 80: 
 81: ### B. Hooks (e.g., `beforeChange`, `afterChange`)
 82: 
 83: Hooks receive specific parameters depending on their type (e.g., `BeforeChangeHook`, `AfterChangeHook`). These parameters should be typed for clarity and error prevention.
 84: 
 85: **Correct Typing for `beforeChange` Hook:**
 86: 
 87: ```typescript
 88: import { CollectionBeforeChangeHook, PayloadRequest } from 'payload';
 89: import { Product, User } from '../payload-types'; // Assuming Product and User types
 90: 
 91: export const setProductOwner: CollectionBeforeChangeHook<Product> = async ({
 92:   data, // The data being saved
 93:   req,  // The PayloadRequest object
 94:   operation, // 'create' | 'update'
 95:   originalDoc, // The original document before the change (for 'update' operation)
 96: }) => {
 97:   if (operation === 'create' && req.user) {
 98:     // Ensure 'owner' field exists on your Product type
 99:     return {
100:       ...data,
101:       owner: req.user.id,
102:     };
103:   }
104:   return data;
105: };
106: 
107: // Example usage in a collection field:
108: // hooks: {
109: //   beforeChange: [setProductOwner],
110: // },
111: ```
112: 
113: **Correct Typing for `afterChange` Hook:**
114: 
115: ```typescript
116: import { CollectionAfterChangeHook, PayloadRequest } from 'payload';
117: import { Order, User } from '../payload-types'; // Assuming Order and User types
118: 
119: export const sendOrderConfirmation: CollectionAfterChangeHook<Order> = async ({
120:   doc, // The document after the change
121:   req, // The PayloadRequest object
122:   operation, // 'create' | 'update'
123: }) => {
124:   if (operation === 'create') {
125:     // Logic to send email, e.g., using a transactional email service
126:     console.log(`Order ${doc.id} created. Sending confirmation to ${doc.customerEmail}`);
127:   }
128:   return doc;
129: };
130: 
131: // Example usage in a collection:
132: // hooks: {
133: //   afterChange: [sendOrderConfirmation],
134: // },
135: ```
136: 
137: ### C. Condition Functions (e.g., `fields[].admin.condition`)
138: 
139: Field condition functions determine whether a field is shown or hidden in the admin UI based on other field values. They typically receive `data` (the entire document data) and `siblingData` (data of fields at the same level).
140: 
141: **Correct Typing for Condition Functions:**
142: 
143: ```typescript
144: import { Field } from 'payload';
145: import { Product } from '../payload-types'; // Assuming Product type
146: 
147: const productTypeField: Field = {
148:   name: 'productType',
149:   type: 'select',
150:   options: ['food', 'drink'],
151:   required: true,
152: };
153: 
154: const drinkSizeField: Field = {
155:   name: 'drinkSize',
156:   type: 'select',
157:   options: ['small', 'medium', 'large'],
158:   admin: {
159:     condition: (data: Product, siblingData: any) => {
160:       // Show 'drinkSize' only if 'productType' is 'drink'
161:       return data.productType === 'drink';
162:     },
163:   },
164: };
165: 
166: // Example usage in a collection fields array:
167: // fields: [
168: //   productTypeField,
169: //   drinkSizeField,
170: //   // ... other fields
171: // ],
172: ```
173: 
174: **Action:** Review all your access control, hook, and condition functions and apply the appropriate type annotations to their parameters. This will significantly reduce your TypeScript errors.
</file>

<file path="llm_context/state_management/README.md">
 1: # Zustand State Management
 2: 
 3: ## Store Patterns
 4: - [x] Store structure and organization - Split stores into slices for separate concerns
 5: - [x] Action patterns and naming conventions - Use `set` for simple updates and actions for complex logic
 6: - [x] State normalization strategies - Normalize nested data using entities pattern
 7: - [x] Middleware integration - Implement `persist` and `devtools` middleware
 8: ```typescript
 9: import { devtools, persist } from 'zustand/middleware';
10: 
11: const useStore = create(
12:   devtools(
13:     persist(
14:       (set) => ({
15:         count: 0,
16:         increment: () => set((state) => ({ count: state.count + 1 })),
17:       }),
18:       { name: 'count-store' }
19:     )
20:   )
21: );
22: ```
23: - [x] TypeScript integration - Define strict types for state and actions
24: 
25: ## Integration Patterns
26: - [x] Tanstack Query integration - Use Zustand for UI state and Tanstack for server state
27: - [x] Form state synchronization - Sync form state with Zustand using `useEffect`
28: - [x] Authentication state management - Implement with Payload's auth flow[3]
29: ```typescript
30: // Auth state example
31: const useAuthStore = create((set) => ({
32:   user: null,
33:   login: async (credentials) => {
34:     const res = await fetch('/api/login', { method: 'POST', body: JSON.stringify(credentials) });
35:     set({ user: await res.json() });
36:   },
37:   logout: () => set({ user: null })
38: }));
39: ```
40: - [x] UI state (modals, notifications) - Manage with dedicated Zustand slices
41: - [x] Real-time data updates - Combine with WebSockets for live updates
42: 
43: ## Performance Optimization
44: - [x] Selector patterns - Use `shallow` for object comparisons
45: - [x] Store slicing - Create independent slices for performance
46: - [x] Subscription patterns - Use `subscribe` for external updates
47: - [x] Memory leak prevention - Add cleanup functions to effects
48: - [x] State persistence - Implement with `persist` middleware
49: 
50: ## Testing Strategies
51: - [x] Store testing patterns - Test actions and state transitions
52: - [x] Mock store creation - Use `create` to mock store instances
53: - [x] Integration testing with React - Test components with store
54: - [x] State mutation testing - Verify immutability patterns
55: - [x] Async action testing - Mock API calls in tests
56: 
57: ## Payload CMS Integration
58: 1. **Version History** - Use Payload's versioning system for state snapshots[1]
59: 2. **Draft Management** - Implement draft states with Payload's draft mode[1]
60: 3. **Admin Hooks** - Use `useRouteTransition` for UI feedback[4]
61: 4. **Form State** - Integrate with Payload's Form Builder[2]
62: 
63: ## Files to Create
64: - `best_practices.md` - Zustand best practices
65: - `common_patterns.md` - Reusable store patterns
66: - `troubleshooting.md` - Common state management issues
67: - `integration_guides.md` - Integration with other libraries
</file>

<file path="llm_context/tanstack/README.md">
 1: # Tanstack Query & Tables
 2: 
 3: ## Table Implementation
 4: - [x] Column definitions for Payload collections - Use type-safe column definitions
 5: ```typescript
 6: const columns: ColumnDef<Collection>[] = [
 7:   { accessorKey: 'id', header: 'ID' },
 8:   { accessorKey: 'title', header: 'Title' }
 9: ]
10: ```
11: - [x] Sorting and filtering integration - Implement server-side sorting
12: - [x] Row selection patterns - Use `rowSelection` state
13: - [x] Custom cell renderers - Create reusable cell components
14: - [x] Export functionality - Implement CSV/Excel export
15: 
16: ## Integration Points
17: - [x] Zustand state management integration - Sync table state with Zustand
18: - [x] Form submission with query invalidation - Invalidate queries on submit
19: - [x] Real-time updates with WebSocket/SSE - Use `useQuery` with WebSockets
20: - [x] Performance optimization strategies - Virtualize large tables
21: 
22: ## Best Practices
23: 1. Use `keepPreviousData` for smooth pagination transitions
24: 2. Implement skeleton loaders for better UX
25: 3. Use column visibility controls for responsive tables
26: 4. Add global filtering with debouncing
27: 5. Implement server-side pagination for large datasets
</file>

<file path="llm_context/ui_patterns/README.md">
 1: # Shadcn UI Patterns
 2: 
 3: ## Component Consistency
 4: - [x] Theme configuration and customization - Use CSS variables and theme editors[3]
 5: - [x] Component composition strategies - Build reusable components with Payload's UI library[1][2][4]
 6: - [x] Color palette and design tokens - Implement with CSS variables and design systems[3]
 7: - [x] Typography scale and usage - Use consistent type scales with CSS variables[3]
 8: - [x] Spacing and layout patterns - Implement with Payload's Gutter component[3]
 9: 
10: ## Custom Component Development
11: 1. **Modal Implementation** [1]
12: ```typescript
13: import { Modal } from 'payload/components';
14: import { Button } from 'payload/components/elements';
15: 
16: const CustomModal = () => (
17:   <Modal header="Custom Modal" size="large">
18:     <div className="content">
19:       <p>Modal content here</p>
20:       <div className="delete-document__actions">
21:         <Button buttonStyle="secondary">Cancel</Button>
22:         <Button>Confirm</Button>
23:       </div>
24:     </div>
25:   </Modal>
26: );
27: ```
28: 2. **Dashboard Customization** [3]
29: ```typescript
30: import { Gutter } from 'payload/components/layout';
31: import { Header } from 'payload/components';
32: 
33: const CustomDashboard = () => (
34:   <Gutter>
35:     <Header title="Custom Dashboard" />
36:     <div className="dashboard-content">
37:       {/* Dashboard components */}
38:     </div>
39:   </Gutter>
40: );
41: ```
42: 3. **Field Component Overrides** [4]
43: ```typescript
44: const customField = {
45:   name: 'customSelect',
46:   type: 'text',
47:   admin: {
48:     components: {
49:       Field: CustomSelectField,
50:       Cell: CustomSelectCell,
51:       Filter: CustomSelectFilter
52:     }
53:   }
54: };
55: ```
56: 
57: ## Accessibility
58: - [x] ARIA label strategies - Implement with Payload's accessibility utilities[5]
59: - [x] Keyboard navigation - Ensure tab navigation and focus management[5]
60: - [x] Screen reader compatibility - Use semantic HTML and ARIA attributes[5]
61: - [x] Color contrast compliance - Meet WCAG 2.1 AA standards[5]
62: - [x] Focus management - Implement focus traps for modals[1][5]
63: 
64: ## Integration
65: - [x] Tailwind CSS configuration - Extend with custom themes[3]
66: - [x] Custom component creation - Use Payload's component API[2][4]
67: - [x] Theme switching implementation - Implement with CSS variables and context[3]
68: - [x] Animation and transition patterns - Use Framer Motion for complex animations[3]
69: 
70: ## Best Practices
71: 1. Use Payload's built-in components for consistency[1][2]
72: 2. Extend rather than replace core components[4]
73: 3. Implement responsive design with breakpoints[3]
74: 4. Use CSS variables for theming[3]
75: 5. Follow Payload's component composition patterns[2][4]
76: 
77: ## Files to Create
78: - `best_practices.md` - UI consistency guidelines
79: - `common_patterns.md` - Reusable component patterns
80: - `troubleshooting.md` - Common UI issues
81: - `integration_guides.md` - Integration with other libraries
</file>

<file path="llm_context/README.md">
 1: # LLM Context Library
 2: 
 3: This comprehensive context library serves as a central knowledge base for LLM agents working on this Payload 3 + Next.js project. It provides structured documentation, best practices, and actionable guidance across all major technologies and tools used in the project.
 4: 
 5: ##  Library Structure
 6: 
 7: ### Core Technologies
 8: - **[payload3/](./payload3/)** - Payload 3 CMS, Lexical Editor, and data modeling
 9: - **[tanstack/](./tanstack/)** - Query and Tables for data management
10: - **[forms/](./forms/)** - Form submission patterns and validation
11: - **[ui_patterns/](./ui_patterns/)** - Shadcn UI consistency and patterns
12: - **[state_management/](./state_management/)** - Zustand global state patterns
13: 
14: ### Development Tools & Workflows
15: - **[mcp_tools/](./mcp_tools/)** - MCP server tools and integration guides
16: - **[llm_agent_insights/](./llm_agent_insights/)** - Agent-specific considerations and patterns
17: 
18: ##  Usage Guidelines
19: 
20: Each directory contains:
21: - **README.md** - Overview and quick reference
22: - **best_practices.md** - Proven patterns and approaches
23: - **common_patterns.md** - Frequently used code patterns
24: - **troubleshooting.md** - Common issues and solutions
25: - **integration_guides.md** - How to integrate with other technologies
26: 
27: ##  Maintenance
28: 
29: This library should be updated as:
30: - New patterns emerge in the codebase
31: - Dependencies are updated
32: - Best practices evolve
33: - New MCP tools are integrated
34: 
35: ##  Quick Start
36: 
37: 1. Navigate to the relevant technology folder
38: 2. Start with the README.md for overview
39: 3. Check best_practices.md for proven approaches
40: 4. Reference common_patterns.md for code examples
41: 5. Use troubleshooting.md when issues arise
</file>

<file path="llm_context/repomix_integration.md">
 1: # Repomix Integration Guide
 2: 
 3: ## Overview
 4: Repomix packages your entire repository into a single AI-friendly file. Integrating Repomix into our workflow enables:
 5: - Feeding the full codebase to LLMs without manual concatenation  
 6: - Automated token accounting to respect model context limits  
 7: - Security scans for secrets and sensitive data  
 8: 
 9: ## Installation
10: 
11: Using npx (no global install required):
12: ```bash
13: cd /Users/webdev/Projects/canvas-payloadv3
14: npx repomix@latest
15: ```
16: 
17: Or add as a dev dependency:
18: ```bash
19: npm install --save-dev repomix
20: ```
21: 
22: ## Configuration
23: 
24: Create `repomix.config.json` at project root:
25: ```json
26: {
27:   "output": "repomix-output.xml",
28:   "format": "xml",
29:   "ignore": ["node_modules/**", ".git/**"],
30:   "tokenCount": true,
31:   "detectSecrets": true
32: }
33: ```
34: 
35: ## Usage in Development
36: 
37: 1. Run `npx repomix --config=repomix.config.json`.
38: 2. Upload or attach `repomix-output.xml` when prompting the AI:
39:    > This file contains the entire repo. Please analyze architecture and suggest refactors.
40: 
41: ## CI / Automation
42: 
43: Add a workflow step in `.github/workflows/ci.yml`:
44: ```yaml
45: - name: Generate Repomix artifact
46:   run: npx repomix --config=repomix.config.json
47: 
48: - name: Upload AI context
49:   uses: actions/upload-artifact@v3
50:   with:
51:     name: repomix-artifact
52:     path: repomix-output.xml
53: ```
54: 
55: ## AI Prompt Examples
56: 
57: - **Initial review**  
58:   > "Here is the repository in one file. Identify unused code paths and suggest consolidation."
59: 
60: - **Refactor request**  
61:   > "Please update all React components to use hooks and context. Use the combined file."
62: 
63: - **Multi-file patch (Claude Artifacts)**  
64:   > "Generate updated files for API and data layer. Provide separate file contents."
65: 
66: ## Best Practices
67: 
68: - Commit `repomix.config.json` to source control.  
69: - Exclude large binary assets via `.gitignore`.  
70: - Regularly regenerate after significant merges.  
71: - Use token counters to alert if repository size exceeds model limits.
72: 
73: ## Further Reading
74: 
75: - [Official Repomix Guide](https://repomix.com/guide/)  
76: - [Advanced Usage & Plugins](https://repomix.com/usage)
</file>

<file path="prompts/architectural_review.md">
 1: Please act as an expert architect and developer for a Next.js application utilizing Payload 3.0, connected to a Postgres database on Supabase. Your primary goal is to prepare and refine tasks for the Taskmaster AI mcp server, ensuring they are comprehensive, context-rich, and adhere to best practices. You have access to a full library of relevant context in the llm_context folder.
 2: Here's your process:
 3: Phase 1: Holistic Context Assimilation & Initial Review
 4: 	1.	Thorough Context Reading: Begin by meticulously reading and internalizing all information within the llm_context folder. Develop a holistic understanding of the application's architecture, including:
 5: 		Payload 3.0: Schema definitions, hooks, access control, API endpoints, and custom components.		Next.js: Application structure, data fetching strategies (SSR, SSG, ISR, Client-side), component interactions, routing, and API routes.		Supabase (Postgres): Database schema, RLS policies, functions, triggers, and integration patterns with Payload.		Overall data flow, authentication mechanisms (e.g., Payload's auth, Supabase Auth), authorization, and deployment considerations.		Identify the established best practices and design patterns currently in use across all layers.	2.	Initial Observations & Recommendations: Based on your comprehensive review, identify any:
 6: 		Inconsistencies in naming conventions, data structures, or architectural patterns (e.g., Payload fields not aligning with Supabase columns, inconsistent API route naming).		Areas where best practices could be more rigorously applied (e.g., security vulnerabilities, performance bottlenecks, maintainability improvements, code readability).		Potential points of friction or areas for future improvement in the integration between Payload, Next.js, and Supabase.		Opportunities to simplify complex patterns or enhance clarity in the existing codebase.
 7: Output: Provide a categorized list of these initial observations and recommendations, clearly stating the component(s) affected. Pause for confirmation before proceeding.
 8: Phase 2: Task Contextualization for Taskmaster AI
 9: 	1.	Task-Specific Context Embedding: For each task provided, your objective is to enrich it with all necessary context for the Taskmaster AI mcp server to execute it effectively.
10: 		Identify Relevance: Determine which parts of the llm_context are directly relevant to the current task.		Embed Directly: Where feasible and concise, embed the most critical context directly into the task description. This includes specific code snippets, schema definitions, API endpoints, configuration details, or relevant Supabase SQL.		Link for Depth: If the relevant context is extensive (e.g., a full file or a large section), provide a concise summary within the task and a clear, precise reference (e.g., llm_context/payload/collections/Users.ts, llm_context/supabase/functions/my_function.sql) to the llm_context folder where the full details can be found.		Break Down Complex Tasks: If a task requires an overwhelming amount of embedded context, or if its scope is too broad for a single, manageable unit for Taskmaster AI, propose breaking it down into smaller, more focused sub-tasks. Each sub-task should then be contextualized individually.
11: Output: For each task, provide a revised task description that includes embedded or linked context. If a task breakdown is recommended, present the proposed sub-tasks with their respective contextualization.
12: Phase 3: Inter-Component Impact Analysis
13: 	1.	Dependency Review: For every recommendation, update, or task modification you propose, meticulously review its potential impact on other parts of the application.
14: 		Cross-Layer Implications: Consider how a change in one layer (e.g., a Payload schema change) might affect another (e.g., Next.js forms, Supabase RLS, Taskmaster AI's understanding of data structures, existing API consumers).		Data Flow & API Contracts: Ensure that data flow remains consistent and that API contracts between Payload and Next.js are maintained or updated appropriately.		Authentication & Authorization: Verify that security implications are considered and that access controls (Payload access, Supabase RLS) remain robust and consistent.		User Experience: Briefly consider any potential UI/UX impacts if applicable, especially for Next.js frontend changes.
15: Output: For each proposed change or task, include a concise "Impact Analysis" section detailing potential effects on other components and how these effects are mitigated, addressed, or require further consideration.
16: Throughout this process, prioritize consistency, best practices, and patterns that are easy to understand and maintain. Your goal is to ensure the agent has all the context they need without being overwhelmed, and that all changes contribute to a robust and well-integrated application.
</file>

<file path="prompts/git_update.md">
  1: # Gemini CLI: Git Operations & Taskmaster Integration Workflow
  2: 
  3: You are a Gemini CLI agent responsible for managing Git operations in this repository. Your primary goal is to preserve code integrity, enforce branch discipline, and integrate seamlessly with our Taskmaster-AI MCP workflow for comprehensive project management.
  4: 
  5: ## 1. Repository State Inspection
  6: 
  7: **Initial Assessment:**
  8: ```bash
  9: git status
 10: ```
 11: 
 12: **Comprehensive Analysis & Reporting:**
 13: - **Uncommitted Changes:** List modified, added, deleted files with counts and file paths
 14: - **Untracked Files:** Identify new files not under version control with full paths
 15: - **Merge Conflicts:** Detect and list conflicting files requiring resolution
 16: - **Branch Status:** Report current branch and any divergence from remote
 17: - **Stash Status:** Check for any stashed changes that might be relevant
 18: 
 19: **Output Format:** Provide clear, structured summary:
 20: ```
 21: Repository Status Summary:
 22: - Current Branch: feature/user-auth
 23: - 3 modified files: src/auth.ts, src/types/user.ts, package.json
 24: - 2 untracked files: src/utils/validation.ts, tests/auth.spec.ts
 25: - 1 conflict in: src/auth.ts (lines 45-52)
 26: - Remote status: 2 commits ahead, 0 behind
 27: ```
 28: 
 29: ## 2. Git Issue Resolution
 30: 
 31: ### Uncommitted Changes
 32: - **Strategy Assessment:** Analyze changes to determine staging approach
 33: - **Auto-staging Command:** 
 34:   ```bash
 35:   git add -A
 36:   ```
 37: - **Selective Staging:** For complex scenarios, suggest file-specific staging
 38: - **Verification:** Confirm all intended changes are staged
 39: 
 40: ### Merge Conflicts
 41: - **Conflict Detection:** List all files with conflict markers (`<<<<<<<`, `=======`, `>>>>>>>`)
 42: - **Resolution Guidance:**
 43:   - Simple conflicts: Recommend manual editing with clear instructions
 44:   - Complex conflicts: Suggest `git mergetool` for GUI resolution
 45:   - Provide file-specific conflict context when possible
 46: - **Validation:** Ensure all conflicts resolved before proceeding
 47: - **Halt Condition:** Stop entire workflow until conflicts are completely resolved
 48: 
 49: ### Unpushed Commits
 50: - **Detection Command:**
 51:   ```bash
 52:   git log origin/$(git rev-parse --abbrev-ref HEAD)..HEAD --oneline
 53:   ```
 54: - **Analysis:** Count unpushed commits and summarize their scope
 55: - **Integration Planning:** Prepare for coordinated push with new commits
 56: 
 57: ## 3. Branch Discipline Enforcement
 58: 
 59: ### Current Branch Analysis
 60: ```bash
 61: git rev-parse --abbrev-ref HEAD
 62: ```
 63: 
 64: ### Branch Validation & Enforcement
 65: - **Protected Branch Detection:** Flag direct work on `main`, `master`, `develop`
 66: - **Work Classification:**
 67:   - **Feature Work:** Require feature branches (`feature/<task-id>-<description>`)
 68:   - **Bug Fixes:** Require bugfix branches (`bugfix/<issue-id>-<description>`)
 69:   - **Hotfixes:** Allow direct main/master work only for critical production fixes
 70:   - **Chores:** Use chore branches (`chore/<description>`)
 71: 
 72: ### Branch Creation Guidance
 73: ```bash
 74: # Suggested branch creation
 75: git checkout -b feature/<task-id>-<short-description>
 76: ```
 77: 
 78: ### Branch Overview
 79: ```bash
 80: git branch -a
 81: ```
 82: - List all local and remote branches for context
 83: - Identify stale branches that might need cleanup
 84: - Show branch relationships and tracking status
 85: 
 86: ## 4. Commit Message Generation & Execution
 87: 
 88: ### Staging Verification
 89: ```bash
 90: git add -A
 91: ```
 92: 
 93: ### Conventional Commits Message Generation
 94: **Format:**
 95: ```
 96: <type>(<scope>): <short description>
 97: 
 98: [Optional body with detailed explanation]
 99: 
100: [TASK-<ID>] (if related to Taskmaster-AI task)
101: [Closes #<issue>] (if applicable)
102: ```
103: 
104: **Commit Types:**
105: - `feat`: New features
106: - `fix`: Bug fixes
107: - `docs`: Documentation changes
108: - `style`: Code style changes (formatting, missing semicolons, etc.)
109: - `refactor`: Code refactoring without feature changes
110: - `test`: Adding or updating tests
111: - `chore`: Maintenance tasks, dependency updates
112: - `build`: Build system or external dependency changes
113: - `ci`: CI/CD configuration changes
114: - `perf`: Performance improvements
115: - `revert`: Reverting previous commits
116: 
117: **Scope Examples:** `auth`, `ui`, `api`, `database`, `config`, `utils`
118: 
119: ### Taskmaster-AI Integration
120: - **Task Reference:** Include `[TASK-<ID>]` when work relates to specific Taskmaster tasks
121: - **Status Correlation:** Align commit with task progression (implementation  review  completion)
122: - **Context Preservation:** Reference task details in commit body when relevant
123: 
124: ### Commit Execution
125: ```bash
126: git commit -m "<generated-message>"
127: ```
128: 
129: ### Push Strategy
130: ```bash
131: # For new branches
132: git push --set-upstream origin <branch-name>
133: 
134: # For existing branches
135: git push
136: ```
137: 
138: ## 5. Taskmaster-AI MCP Integration
139: 
140: ### Post-Commit Workflow
141: After successful commit and push:
142: 
143: 1. **Task Status Assessment:**
144:    - Determine if Taskmaster task status should be updated
145:    - Common progressions: `pending`  `in-progress`  `review`  `done`
146: 
147: 2. **Status Update Recommendations:**
148:    - **Implementation Complete:** Suggest `review` status
149:    - **Feature Complete & Tested:** Suggest `done` status
150:    - **Partial Progress:** Suggest `in-progress` status
151:    - **Blocked by Dependencies:** Suggest `blocked` status
152: 
153: 3. **Integration Prompts:**
154:    ```
155:    Commit successful! Taskmaster-AI Integration:
156:    - Task TASK-123 appears to be implementation-complete
157:    - Suggested status update: 'review'
158:    - Recommended next action: Create pull request for code review
159:    ```
160: 
161: ### Taskmaster Context Awareness
162: - **Branch-Task Correlation:** Link git branches to Taskmaster task contexts
163: - **Progress Tracking:** Suggest task updates based on commit content and scope
164: - **Dependency Management:** Alert about task dependencies that might be affected
165: 
166: ## 6. Advanced Git Operations & Best Practices
167: 
168: ### Repository Hygiene
169: - **Atomic Commits:** Encourage focused, single-purpose commits
170: - **Commit Frequency:** Suggest regular commits for complex features
171: - **Branch Cleanup:** Recommend deletion of merged feature branches
172: 
173: ### History Management
174: - **Interactive Rebase Suggestions:**
175:   ```bash
176:   git rebase -i HEAD~<N>
177:   ```
178:   - Suggest only when history is messy and branch is not shared
179:   - Require explicit user confirmation before executing
180:   - Provide clear warnings about rebase risks
181: 
182: ### Collaboration Considerations
183: - **Remote Synchronization:** Check for remote changes before pushing
184: - **Conflict Prevention:** Suggest regular pulls from main branch
185: - **Team Coordination:** Alert about potential conflicts with shared branches
186: 
187: ## 7. Error Handling & Recovery
188: 
189: ### Common Git Issues
190: - **Detached HEAD:** Provide recovery instructions
191: - **Failed Pushes:** Analyze rejection reasons and suggest solutions
192: - **Corrupted Repository:** Offer diagnostic and repair commands
193: - **Lost Commits:** Guide through reflog recovery
194: 
195: ### Rollback Strategies
196: - **Soft Reset:** For uncommitted changes
197: - **Hard Reset:** For complete rollback (with warnings)
198: - **Revert:** For published commits that need undoing
199: 
200: ## 8. Output Format & Communication
201: 
202: ### Command Execution Plan
203: Before executing any commands, provide:
204: ```
205: Git Operations Plan:
206: 1. Check repository status
207: 2. Resolve 1 merge conflict in src/auth.ts
208: 3. Stage all changes (3 files)
209: 4. Generate conventional commit message
210: 5. Commit with message: "feat(auth): implement JWT token validation [TASK-123]"
211: 6. Push to origin/feature/auth-validation
212: 7. Suggest Taskmaster status update: pending  review
213: ```
214: 
215: ### Progress Reporting
216: - **Step-by-step execution** with clear status indicators
217: - **Command output summaries** rather than raw git output
218: - **Next action recommendations** for both Git and Taskmaster workflows
219: - **Error explanations** with suggested remediation steps
220: 
221: ### Integration Recommendations
222: ```
223: Post-Commit Recommendations:
224:  Code committed successfully
225:  Suggested Taskmaster update: Set TASK-123 to 'review'
226:  Next steps: 
227:    - Create pull request for code review
228:    - Update task documentation if needed
229:    - Notify team members if collaboration required
230: ```
231: 
232: ## 9. Workflow Customization
233: 
234: ### Project-Specific Adaptations
235: - **Branch Naming Conventions:** Adapt to project standards
236: - **Commit Message Templates:** Customize for team preferences
237: - **Integration Depth:** Adjust Taskmaster integration based on project setup
238: - **Automation Level:** Scale from manual guidance to automated execution
239: 
240: ### Context Awareness
241: - **Repository Type:** Adjust workflow for different project types (library, application, documentation)
242: - **Team Size:** Modify collaboration recommendations based on team structure
243: - **Development Stage:** Adapt rigor based on project maturity (prototype vs. production)
244: 
245: ---
246: 
247: **Usage Instructions:**
248: This prompt is designed for direct use with Gemini CLI. The agent will execute this workflow step-by-step, providing clear command plans, executing Git operations, and offering Taskmaster-AI integration recommendations. Each step includes verification and user confirmation before proceeding to ensure safe and effective Git management.
</file>

<file path=".env.example">
 1: # API Keys (Required to enable respective provider)
 2: ANTHROPIC_API_KEY="your_anthropic_api_key_here"       # Required: Format: sk-ant-api03-...
 3: PERPLEXITY_API_KEY="your_perplexity_api_key_here"     # Optional: Format: pplx-...
 4: OPENAI_API_KEY="your_openai_api_key_here"             # Optional, for OpenAI/OpenRouter models. Format: sk-proj-...
 5: GOOGLE_API_KEY="your_google_api_key_here"             # Optional, for Google Gemini models.
 6: MISTRAL_API_KEY="your_mistral_key_here"               # Optional, for Mistral AI models.
 7: XAI_API_KEY="YOUR_XAI_KEY_HERE"                       # Optional, for xAI AI models.
 8: AZURE_OPENAI_API_KEY="your_azure_key_here"            # Optional, for Azure OpenAI models (requires endpoint in .taskmaster/config.json).
 9: OLLAMA_API_KEY="your_ollama_api_key_here"             # Optional: For remote Ollama servers that require authentication.
10: GITHUB_API_KEY="your_github_api_key_here"             # Optional: For GitHub import/export features. Format: ghp_... or github_pat_...
</file>

<file path="AGENTS.md">
  1: # Task Master AI - Claude Code Integration Guide
  2: 
  3: ## Essential Commands
  4: 
  5: ### Core Workflow Commands
  6: 
  7: ```bash
  8: # Project Setup
  9: task-master init                                    # Initialize Task Master in current project
 10: task-master parse-prd .taskmaster/docs/prd.txt      # Generate tasks from PRD document
 11: task-master models --setup                        # Configure AI models interactively
 12: 
 13: # Daily Development Workflow
 14: task-master list                                   # Show all tasks with status
 15: task-master next                                   # Get next available task to work on
 16: task-master show <id>                             # View detailed task information (e.g., task-master show 1.2)
 17: task-master set-status --id=<id> --status=done    # Mark task complete
 18: 
 19: # Task Management
 20: task-master add-task --prompt="description" --research        # Add new task with AI assistance
 21: task-master expand --id=<id> --research --force              # Break task into subtasks
 22: task-master update-task --id=<id> --prompt="changes"         # Update specific task
 23: task-master update --from=<id> --prompt="changes"            # Update multiple tasks from ID onwards
 24: task-master update-subtask --id=<id> --prompt="notes"        # Add implementation notes to subtask
 25: 
 26: # Analysis & Planning
 27: task-master analyze-complexity --research          # Analyze task complexity
 28: task-master complexity-report                      # View complexity analysis
 29: task-master expand --all --research               # Expand all eligible tasks
 30: 
 31: # Dependencies & Organization
 32: task-master add-dependency --id=<id> --depends-on=<id>       # Add task dependency
 33: task-master move --from=<id> --to=<id>                       # Reorganize task hierarchy
 34: task-master validate-dependencies                            # Check for dependency issues
 35: task-master generate                                         # Update task markdown files (usually auto-called)
 36: ```
 37: 
 38: ## Key Files & Project Structure
 39: 
 40: ### Core Files
 41: 
 42: - `.taskmaster/tasks/tasks.json` - Main task data file (auto-managed)
 43: - `.taskmaster/config.json` - AI model configuration (use `task-master models` to modify)
 44: - `.taskmaster/docs/prd.txt` - Product Requirements Document for parsing
 45: - `.taskmaster/tasks/*.txt` - Individual task files (auto-generated from tasks.json)
 46: - `.env` - API keys for CLI usage
 47: 
 48: ### Claude Code Integration Files
 49: 
 50: - `CLAUDE.md` - Auto-loaded context for Claude Code (this file)
 51: - `.claude/settings.json` - Claude Code tool allowlist and preferences
 52: - `.claude/commands/` - Custom slash commands for repeated workflows
 53: - `.mcp.json` - MCP server configuration (project-specific)
 54: 
 55: ### Directory Structure
 56: 
 57: ```
 58: project/
 59:  .taskmaster/
 60:     tasks/              # Task files directory
 61:        tasks.json      # Main task database
 62:        task-1.md      # Individual task files
 63:        task-2.md
 64:     docs/              # Documentation directory
 65:        prd.txt        # Product requirements
 66:     reports/           # Analysis reports directory
 67:        task-complexity-report.json
 68:     templates/         # Template files
 69:        example_prd.txt  # Example PRD template
 70:     config.json        # AI models & settings
 71:  .claude/
 72:     settings.json      # Claude Code configuration
 73:     commands/         # Custom slash commands
 74:  .env                  # API keys
 75:  .mcp.json            # MCP configuration
 76:  CLAUDE.md            # This file - auto-loaded by Claude Code
 77: ```
 78: 
 79: ## MCP Integration
 80: 
 81: Task Master provides an MCP server that Claude Code can connect to. Configure in `.mcp.json`:
 82: 
 83: ```json
 84: {
 85:   "mcpServers": {
 86:     "task-master-ai": {
 87:       "command": "npx",
 88:       "args": ["-y", "--package=task-master-ai", "task-master-ai"],
 89:       "env": {
 90:         "ANTHROPIC_API_KEY": "your_key_here",
 91:         "PERPLEXITY_API_KEY": "your_key_here",
 92:         "OPENAI_API_KEY": "OPENAI_API_KEY_HERE",
 93:         "GOOGLE_API_KEY": "GOOGLE_API_KEY_HERE",
 94:         "XAI_API_KEY": "XAI_API_KEY_HERE",
 95:         "OPENROUTER_API_KEY": "OPENROUTER_API_KEY_HERE",
 96:         "MISTRAL_API_KEY": "MISTRAL_API_KEY_HERE",
 97:         "AZURE_OPENAI_API_KEY": "AZURE_OPENAI_API_KEY_HERE",
 98:         "OLLAMA_API_KEY": "OLLAMA_API_KEY_HERE"
 99:       }
100:     }
101:   }
102: }
103: ```
104: 
105: ### Essential MCP Tools
106: 
107: ```javascript
108: help; // = shows available taskmaster commands
109: // Project setup
110: initialize_project; // = task-master init
111: parse_prd; // = task-master parse-prd
112: 
113: // Daily workflow
114: get_tasks; // = task-master list
115: next_task; // = task-master next
116: get_task; // = task-master show <id>
117: set_task_status; // = task-master set-status
118: 
119: // Task management
120: add_task; // = task-master add-task
121: expand_task; // = task-master expand
122: update_task; // = task-master update-task
123: update_subtask; // = task-master update-subtask
124: update; // = task-master update
125: 
126: // Analysis
127: analyze_project_complexity; // = task-master analyze-complexity
128: complexity_report; // = task-master complexity-report
129: ```
130: 
131: ## Claude Code Workflow Integration
132: 
133: ### Standard Development Workflow
134: 
135: #### 1. Project Initialization
136: 
137: ```bash
138: # Initialize Task Master
139: task-master init
140: 
141: # Create or obtain PRD, then parse it
142: task-master parse-prd .taskmaster/docs/prd.txt
143: 
144: # Analyze complexity and expand tasks
145: task-master analyze-complexity --research
146: task-master expand --all --research
147: ```
148: 
149: If tasks already exist, another PRD can be parsed (with new information only!) using parse-prd with --append flag. This will add the generated tasks to the existing list of tasks..
150: 
151: #### 2. Daily Development Loop
152: 
153: ```bash
154: # Start each session
155: task-master next                           # Find next available task
156: task-master show <id>                     # Review task details
157: 
158: # During implementation, check in code context into the tasks and subtasks
159: task-master update-subtask --id=<id> --prompt="implementation notes..."
160: 
161: # Complete tasks
162: task-master set-status --id=<id> --status=done
163: ```
164: 
165: #### 3. Multi-Claude Workflows
166: 
167: For complex projects, use multiple Claude Code sessions:
168: 
169: ```bash
170: # Terminal 1: Main implementation
171: cd project && claude
172: 
173: # Terminal 2: Testing and validation
174: cd project-test-worktree && claude
175: 
176: # Terminal 3: Documentation updates
177: cd project-docs-worktree && claude
178: ```
179: 
180: ### Custom Slash Commands
181: 
182: Create `.claude/commands/taskmaster-next.md`:
183: 
184: ```markdown
185: Find the next available Task Master task and show its details.
186: 
187: Steps:
188: 
189: 1. Run `task-master next` to get the next task
190: 2. If a task is available, run `task-master show <id>` for full details
191: 3. Provide a summary of what needs to be implemented
192: 4. Suggest the first implementation step
193: ```
194: 
195: Create `.claude/commands/taskmaster-complete.md`:
196: 
197: ```markdown
198: Complete a Task Master task: $ARGUMENTS
199: 
200: Steps:
201: 
202: 1. Review the current task with `task-master show $ARGUMENTS`
203: 2. Verify all implementation is complete
204: 3. Run any tests related to this task
205: 4. Mark as complete: `task-master set-status --id=$ARGUMENTS --status=done`
206: 5. Show the next available task with `task-master next`
207: ```
208: 
209: ## Tool Allowlist Recommendations
210: 
211: Add to `.claude/settings.json`:
212: 
213: ```json
214: {
215:   "allowedTools": [
216:     "Edit",
217:     "Bash(task-master *)",
218:     "Bash(git commit:*)",
219:     "Bash(git add:*)",
220:     "Bash(npm run *)",
221:     "mcp__task_master_ai__*"
222:   ]
223: }
224: ```
225: 
226: ## Configuration & Setup
227: 
228: ### API Keys Required
229: 
230: At least **one** of these API keys must be configured:
231: 
232: - `ANTHROPIC_API_KEY` (Claude models) - **Recommended**
233: - `PERPLEXITY_API_KEY` (Research features) - **Highly recommended**
234: - `OPENAI_API_KEY` (GPT models)
235: - `GOOGLE_API_KEY` (Gemini models)
236: - `MISTRAL_API_KEY` (Mistral models)
237: - `OPENROUTER_API_KEY` (Multiple models)
238: - `XAI_API_KEY` (Grok models)
239: 
240: An API key is required for any provider used across any of the 3 roles defined in the `models` command.
241: 
242: ### Model Configuration
243: 
244: ```bash
245: # Interactive setup (recommended)
246: task-master models --setup
247: 
248: # Set specific models
249: task-master models --set-main claude-3-5-sonnet-20241022
250: task-master models --set-research perplexity-llama-3.1-sonar-large-128k-online
251: task-master models --set-fallback gpt-4o-mini
252: ```
253: 
254: ## Task Structure & IDs
255: 
256: ### Task ID Format
257: 
258: - Main tasks: `1`, `2`, `3`, etc.
259: - Subtasks: `1.1`, `1.2`, `2.1`, etc.
260: - Sub-subtasks: `1.1.1`, `1.1.2`, etc.
261: 
262: ### Task Status Values
263: 
264: - `pending` - Ready to work on
265: - `in-progress` - Currently being worked on
266: - `done` - Completed and verified
267: - `deferred` - Postponed
268: - `cancelled` - No longer needed
269: - `blocked` - Waiting on external factors
270: 
271: ### Task Fields
272: 
273: ```json
274: {
275:   "id": "1.2",
276:   "title": "Implement user authentication",
277:   "description": "Set up JWT-based auth system",
278:   "status": "pending",
279:   "priority": "high",
280:   "dependencies": ["1.1"],
281:   "details": "Use bcrypt for hashing, JWT for tokens...",
282:   "testStrategy": "Unit tests for auth functions, integration tests for login flow",
283:   "subtasks": []
284: }
285: ```
286: 
287: ## Claude Code Best Practices with Task Master
288: 
289: ### Context Management
290: 
291: - Use `/clear` between different tasks to maintain focus
292: - This CLAUDE.md file is automatically loaded for context
293: - Use `task-master show <id>` to pull specific task context when needed
294: 
295: ### Iterative Implementation
296: 
297: 1. `task-master show <subtask-id>` - Understand requirements
298: 2. Explore codebase and plan implementation
299: 3. `task-master update-subtask --id=<id> --prompt="detailed plan"` - Log plan
300: 4. `task-master set-status --id=<id> --status=in-progress` - Start work
301: 5. Implement code following logged plan
302: 6. `task-master update-subtask --id=<id> --prompt="what worked/didn't work"` - Log progress
303: 7. `task-master set-status --id=<id> --status=done` - Complete task
304: 
305: ### Complex Workflows with Checklists
306: 
307: For large migrations or multi-step processes:
308: 
309: 1. Create a markdown PRD file describing the new changes: `touch task-migration-checklist.md` (prds can be .txt or .md)
310: 2. Use Taskmaster to parse the new prd with `task-master parse-prd --append` (also available in MCP)
311: 3. Use Taskmaster to expand the newly generated tasks into subtasks. Consdier using `analyze-complexity` with the correct --to and --from IDs (the new ids) to identify the ideal subtask amounts for each task. Then expand them.
312: 4. Work through items systematically, checking them off as completed
313: 5. Use `task-master update-subtask` to log progress on each task/subtask and/or updating/researching them before/during implementation if getting stuck
314: 
315: ### Git Integration
316: 
317: Task Master works well with `gh` CLI:
318: 
319: ```bash
320: # Create PR for completed task
321: gh pr create --title "Complete task 1.2: User authentication" --body "Implements JWT auth system as specified in task 1.2"
322: 
323: # Reference task in commits
324: git commit -m "feat: implement JWT auth (task 1.2)"
325: ```
326: 
327: ### Parallel Development with Git Worktrees
328: 
329: ```bash
330: # Create worktrees for parallel task development
331: git worktree add ../project-auth feature/auth-system
332: git worktree add ../project-api feature/api-refactor
333: 
334: # Run Claude Code in each worktree
335: cd ../project-auth && claude    # Terminal 1: Auth work
336: cd ../project-api && claude     # Terminal 2: API work
337: ```
338: 
339: ## Troubleshooting
340: 
341: ### AI Commands Failing
342: 
343: ```bash
344: # Check API keys are configured
345: cat .env                           # For CLI usage
346: 
347: # Verify model configuration
348: task-master models
349: 
350: # Test with different model
351: task-master models --set-fallback gpt-4o-mini
352: ```
353: 
354: ### MCP Connection Issues
355: 
356: - Check `.mcp.json` configuration
357: - Verify Node.js installation
358: - Use `--mcp-debug` flag when starting Claude Code
359: - Use CLI as fallback if MCP unavailable
360: 
361: ### Task File Sync Issues
362: 
363: ```bash
364: # Regenerate task files from tasks.json
365: task-master generate
366: 
367: # Fix dependency issues
368: task-master fix-dependencies
369: ```
370: 
371: DO NOT RE-INITIALIZE. That will not do anything beyond re-adding the same Taskmaster core files.
372: 
373: ## Important Notes
374: 
375: ### AI-Powered Operations
376: 
377: These commands make AI calls and may take up to a minute:
378: 
379: - `parse_prd` / `task-master parse-prd`
380: - `analyze_project_complexity` / `task-master analyze-complexity`
381: - `expand_task` / `task-master expand`
382: - `expand_all` / `task-master expand --all`
383: - `add_task` / `task-master add-task`
384: - `update` / `task-master update`
385: - `update_task` / `task-master update-task`
386: - `update_subtask` / `task-master update-subtask`
387: 
388: ### File Management
389: 
390: - Never manually edit `tasks.json` - use commands instead
391: - Never manually edit `.taskmaster/config.json` - use `task-master models`
392: - Task markdown files in `tasks/` are auto-generated
393: - Run `task-master generate` after manual changes to tasks.json
394: 
395: ### Claude Code Session Management
396: 
397: - Use `/clear` frequently to maintain focused context
398: - Create custom slash commands for repeated Task Master workflows
399: - Configure tool allowlist to streamline permissions
400: - Use headless mode for automation: `claude -p "task-master next"`
401: 
402: ### Multi-Task Updates
403: 
404: - Use `update --from=<id>` to update multiple future tasks
405: - Use `update-task --id=<id>` for single task updates
406: - Use `update-subtask --id=<id>` for implementation logging
407: 
408: ### Research Mode
409: 
410: - Add `--research` flag for research-based AI enhancement
411: - Requires a research model API key like Perplexity (`PERPLEXITY_API_KEY`) in environment
412: - Provides more informed task creation and updates
413: - Recommended for complex technical tasks
414: 
415: ---
416: 
417: _This guide ensures Claude Code has immediate access to Task Master's essential functionality for agentic development workflows._
</file>

<file path="CLAUDE.md">
  1: # Task Master AI - Claude Code Integration Guide
  2: 
  3: ## Essential Commands
  4: 
  5: ### Core Workflow Commands
  6: 
  7: ```bash
  8: # Project Setup
  9: task-master init                                    # Initialize Task Master in current project
 10: task-master parse-prd .taskmaster/docs/prd.txt      # Generate tasks from PRD document
 11: task-master models --setup                        # Configure AI models interactively
 12: 
 13: # Daily Development Workflow
 14: task-master list                                   # Show all tasks with status
 15: task-master next                                   # Get next available task to work on
 16: task-master show <id>                             # View detailed task information (e.g., task-master show 1.2)
 17: task-master set-status --id=<id> --status=done    # Mark task complete
 18: 
 19: # Task Management
 20: task-master add-task --prompt="description" --research        # Add new task with AI assistance
 21: task-master expand --id=<id> --research --force              # Break task into subtasks
 22: task-master update-task --id=<id> --prompt="changes"         # Update specific task
 23: task-master update --from=<id> --prompt="changes"            # Update multiple tasks from ID onwards
 24: task-master update-subtask --id=<id> --prompt="notes"        # Add implementation notes to subtask
 25: 
 26: # Analysis & Planning
 27: task-master analyze-complexity --research          # Analyze task complexity
 28: task-master complexity-report                      # View complexity analysis
 29: task-master expand --all --research               # Expand all eligible tasks
 30: 
 31: # Dependencies & Organization
 32: task-master add-dependency --id=<id> --depends-on=<id>       # Add task dependency
 33: task-master move --from=<id> --to=<id>                       # Reorganize task hierarchy
 34: task-master validate-dependencies                            # Check for dependency issues
 35: task-master generate                                         # Update task markdown files (usually auto-called)
 36: ```
 37: 
 38: ## Key Files & Project Structure
 39: 
 40: ### Core Files
 41: 
 42: - `.taskmaster/tasks/tasks.json` - Main task data file (auto-managed)
 43: - `.taskmaster/config.json` - AI model configuration (use `task-master models` to modify)
 44: - `.taskmaster/docs/prd.txt` - Product Requirements Document for parsing
 45: - `.taskmaster/tasks/*.txt` - Individual task files (auto-generated from tasks.json)
 46: - `.env` - API keys for CLI usage
 47: 
 48: ### Claude Code Integration Files
 49: 
 50: - `CLAUDE.md` - Auto-loaded context for Claude Code (this file)
 51: - `.claude/settings.json` - Claude Code tool allowlist and preferences
 52: - `.claude/commands/` - Custom slash commands for repeated workflows
 53: - `.mcp.json` - MCP server configuration (project-specific)
 54: 
 55: ### Directory Structure
 56: 
 57: ```
 58: project/
 59:  .taskmaster/
 60:     tasks/              # Task files directory
 61:        tasks.json      # Main task database
 62:        task-1.md      # Individual task files
 63:        task-2.md
 64:     docs/              # Documentation directory
 65:        prd.txt        # Product requirements
 66:     reports/           # Analysis reports directory
 67:        task-complexity-report.json
 68:     templates/         # Template files
 69:        example_prd.txt  # Example PRD template
 70:     config.json        # AI models & settings
 71:  .claude/
 72:     settings.json      # Claude Code configuration
 73:     commands/         # Custom slash commands
 74:  .env                  # API keys
 75:  .mcp.json            # MCP configuration
 76:  CLAUDE.md            # This file - auto-loaded by Claude Code
 77: ```
 78: 
 79: ## MCP Integration
 80: 
 81: Task Master provides an MCP server that Claude Code can connect to. Configure in `.mcp.json`:
 82: 
 83: ```json
 84: {
 85:   "mcpServers": {
 86:     "task-master-ai": {
 87:       "command": "npx",
 88:       "args": ["-y", "--package=task-master-ai", "task-master-ai"],
 89:       "env": {
 90:         "ANTHROPIC_API_KEY": "your_key_here",
 91:         "PERPLEXITY_API_KEY": "your_key_here",
 92:         "OPENAI_API_KEY": "OPENAI_API_KEY_HERE",
 93:         "GOOGLE_API_KEY": "GOOGLE_API_KEY_HERE",
 94:         "XAI_API_KEY": "XAI_API_KEY_HERE",
 95:         "OPENROUTER_API_KEY": "OPENROUTER_API_KEY_HERE",
 96:         "MISTRAL_API_KEY": "MISTRAL_API_KEY_HERE",
 97:         "AZURE_OPENAI_API_KEY": "AZURE_OPENAI_API_KEY_HERE",
 98:         "OLLAMA_API_KEY": "OLLAMA_API_KEY_HERE"
 99:       }
100:     }
101:   }
102: }
103: ```
104: 
105: ### Essential MCP Tools
106: 
107: ```javascript
108: help; // = shows available taskmaster commands
109: // Project setup
110: initialize_project; // = task-master init
111: parse_prd; // = task-master parse-prd
112: 
113: // Daily workflow
114: get_tasks; // = task-master list
115: next_task; // = task-master next
116: get_task; // = task-master show <id>
117: set_task_status; // = task-master set-status
118: 
119: // Task management
120: add_task; // = task-master add-task
121: expand_task; // = task-master expand
122: update_task; // = task-master update-task
123: update_subtask; // = task-master update-subtask
124: update; // = task-master update
125: 
126: // Analysis
127: analyze_project_complexity; // = task-master analyze-complexity
128: complexity_report; // = task-master complexity-report
129: ```
130: 
131: ## Claude Code Workflow Integration
132: 
133: ### Standard Development Workflow
134: 
135: #### 1. Project Initialization
136: 
137: ```bash
138: # Initialize Task Master
139: task-master init
140: 
141: # Create or obtain PRD, then parse it
142: task-master parse-prd .taskmaster/docs/prd.txt
143: 
144: # Analyze complexity and expand tasks
145: task-master analyze-complexity --research
146: task-master expand --all --research
147: ```
148: 
149: If tasks already exist, another PRD can be parsed (with new information only!) using parse-prd with --append flag. This will add the generated tasks to the existing list of tasks..
150: 
151: #### 2. Daily Development Loop
152: 
153: ```bash
154: # Start each session
155: task-master next                           # Find next available task
156: task-master show <id>                     # Review task details
157: 
158: # During implementation, check in code context into the tasks and subtasks
159: task-master update-subtask --id=<id> --prompt="implementation notes..."
160: 
161: # Complete tasks
162: task-master set-status --id=<id> --status=done
163: ```
164: 
165: #### 3. Multi-Claude Workflows
166: 
167: For complex projects, use multiple Claude Code sessions:
168: 
169: ```bash
170: # Terminal 1: Main implementation
171: cd project && claude
172: 
173: # Terminal 2: Testing and validation
174: cd project-test-worktree && claude
175: 
176: # Terminal 3: Documentation updates
177: cd project-docs-worktree && claude
178: ```
179: 
180: ### Custom Slash Commands
181: 
182: Create `.claude/commands/taskmaster-next.md`:
183: 
184: ```markdown
185: Find the next available Task Master task and show its details.
186: 
187: Steps:
188: 
189: 1. Run `task-master next` to get the next task
190: 2. If a task is available, run `task-master show <id>` for full details
191: 3. Provide a summary of what needs to be implemented
192: 4. Suggest the first implementation step
193: ```
194: 
195: Create `.claude/commands/taskmaster-complete.md`:
196: 
197: ```markdown
198: Complete a Task Master task: $ARGUMENTS
199: 
200: Steps:
201: 
202: 1. Review the current task with `task-master show $ARGUMENTS`
203: 2. Verify all implementation is complete
204: 3. Run any tests related to this task
205: 4. Mark as complete: `task-master set-status --id=$ARGUMENTS --status=done`
206: 5. Show the next available task with `task-master next`
207: ```
208: 
209: ## Tool Allowlist Recommendations
210: 
211: Add to `.claude/settings.json`:
212: 
213: ```json
214: {
215:   "allowedTools": [
216:     "Edit",
217:     "Bash(task-master *)",
218:     "Bash(git commit:*)",
219:     "Bash(git add:*)",
220:     "Bash(npm run *)",
221:     "mcp__task_master_ai__*"
222:   ]
223: }
224: ```
225: 
226: ## Configuration & Setup
227: 
228: ### API Keys Required
229: 
230: At least **one** of these API keys must be configured:
231: 
232: - `ANTHROPIC_API_KEY` (Claude models) - **Recommended**
233: - `PERPLEXITY_API_KEY` (Research features) - **Highly recommended**
234: - `OPENAI_API_KEY` (GPT models)
235: - `GOOGLE_API_KEY` (Gemini models)
236: - `MISTRAL_API_KEY` (Mistral models)
237: - `OPENROUTER_API_KEY` (Multiple models)
238: - `XAI_API_KEY` (Grok models)
239: 
240: An API key is required for any provider used across any of the 3 roles defined in the `models` command.
241: 
242: ### Model Configuration
243: 
244: ```bash
245: # Interactive setup (recommended)
246: task-master models --setup
247: 
248: # Set specific models
249: task-master models --set-main claude-3-5-sonnet-20241022
250: task-master models --set-research perplexity-llama-3.1-sonar-large-128k-online
251: task-master models --set-fallback gpt-4o-mini
252: ```
253: 
254: ## Task Structure & IDs
255: 
256: ### Task ID Format
257: 
258: - Main tasks: `1`, `2`, `3`, etc.
259: - Subtasks: `1.1`, `1.2`, `2.1`, etc.
260: - Sub-subtasks: `1.1.1`, `1.1.2`, etc.
261: 
262: ### Task Status Values
263: 
264: - `pending` - Ready to work on
265: - `in-progress` - Currently being worked on
266: - `done` - Completed and verified
267: - `deferred` - Postponed
268: - `cancelled` - No longer needed
269: - `blocked` - Waiting on external factors
270: 
271: ### Task Fields
272: 
273: ```json
274: {
275:   "id": "1.2",
276:   "title": "Implement user authentication",
277:   "description": "Set up JWT-based auth system",
278:   "status": "pending",
279:   "priority": "high",
280:   "dependencies": ["1.1"],
281:   "details": "Use bcrypt for hashing, JWT for tokens...",
282:   "testStrategy": "Unit tests for auth functions, integration tests for login flow",
283:   "subtasks": []
284: }
285: ```
286: 
287: ## Claude Code Best Practices with Task Master
288: 
289: ### Context Management
290: 
291: - Use `/clear` between different tasks to maintain focus
292: - This CLAUDE.md file is automatically loaded for context
293: - Use `task-master show <id>` to pull specific task context when needed
294: 
295: ### Iterative Implementation
296: 
297: 1. `task-master show <subtask-id>` - Understand requirements
298: 2. Explore codebase and plan implementation
299: 3. `task-master update-subtask --id=<id> --prompt="detailed plan"` - Log plan
300: 4. `task-master set-status --id=<id> --status=in-progress` - Start work
301: 5. Implement code following logged plan
302: 6. `task-master update-subtask --id=<id> --prompt="what worked/didn't work"` - Log progress
303: 7. `task-master set-status --id=<id> --status=done` - Complete task
304: 
305: ### Complex Workflows with Checklists
306: 
307: For large migrations or multi-step processes:
308: 
309: 1. Create a markdown PRD file describing the new changes: `touch task-migration-checklist.md` (prds can be .txt or .md)
310: 2. Use Taskmaster to parse the new prd with `task-master parse-prd --append` (also available in MCP)
311: 3. Use Taskmaster to expand the newly generated tasks into subtasks. Consdier using `analyze-complexity` with the correct --to and --from IDs (the new ids) to identify the ideal subtask amounts for each task. Then expand them.
312: 4. Work through items systematically, checking them off as completed
313: 5. Use `task-master update-subtask` to log progress on each task/subtask and/or updating/researching them before/during implementation if getting stuck
314: 
315: ### Git Integration
316: 
317: Task Master works well with `gh` CLI:
318: 
319: ```bash
320: # Create PR for completed task
321: gh pr create --title "Complete task 1.2: User authentication" --body "Implements JWT auth system as specified in task 1.2"
322: 
323: # Reference task in commits
324: git commit -m "feat: implement JWT auth (task 1.2)"
325: ```
326: 
327: ### Parallel Development with Git Worktrees
328: 
329: ```bash
330: # Create worktrees for parallel task development
331: git worktree add ../project-auth feature/auth-system
332: git worktree add ../project-api feature/api-refactor
333: 
334: # Run Claude Code in each worktree
335: cd ../project-auth && claude    # Terminal 1: Auth work
336: cd ../project-api && claude     # Terminal 2: API work
337: ```
338: 
339: ## Troubleshooting
340: 
341: ### AI Commands Failing
342: 
343: ```bash
344: # Check API keys are configured
345: cat .env                           # For CLI usage
346: 
347: # Verify model configuration
348: task-master models
349: 
350: # Test with different model
351: task-master models --set-fallback gpt-4o-mini
352: ```
353: 
354: ### MCP Connection Issues
355: 
356: - Check `.mcp.json` configuration
357: - Verify Node.js installation
358: - Use `--mcp-debug` flag when starting Claude Code
359: - Use CLI as fallback if MCP unavailable
360: 
361: ### Task File Sync Issues
362: 
363: ```bash
364: # Regenerate task files from tasks.json
365: task-master generate
366: 
367: # Fix dependency issues
368: task-master fix-dependencies
369: ```
370: 
371: DO NOT RE-INITIALIZE. That will not do anything beyond re-adding the same Taskmaster core files.
372: 
373: ## Important Notes
374: 
375: ### AI-Powered Operations
376: 
377: These commands make AI calls and may take up to a minute:
378: 
379: - `parse_prd` / `task-master parse-prd`
380: - `analyze_project_complexity` / `task-master analyze-complexity`
381: - `expand_task` / `task-master expand`
382: - `expand_all` / `task-master expand --all`
383: - `add_task` / `task-master add-task`
384: - `update` / `task-master update`
385: - `update_task` / `task-master update-task`
386: - `update_subtask` / `task-master update-subtask`
387: 
388: ### File Management
389: 
390: - Never manually edit `tasks.json` - use commands instead
391: - Never manually edit `.taskmaster/config.json` - use `task-master models`
392: - Task markdown files in `tasks/` are auto-generated
393: - Run `task-master generate` after manual changes to tasks.json
394: 
395: ### Claude Code Session Management
396: 
397: - Use `/clear` frequently to maintain focused context
398: - Create custom slash commands for repeated Task Master workflows
399: - Configure tool allowlist to streamline permissions
400: - Use headless mode for automation: `claude -p "task-master next"`
401: 
402: ### Multi-Task Updates
403: 
404: - Use `update --from=<id>` to update multiple future tasks
405: - Use `update-task --id=<id>` for single task updates
406: - Use `update-subtask --id=<id>` for implementation logging
407: 
408: ### Research Mode
409: 
410: - Add `--research` flag for research-based AI enhancement
411: - Requires a research model API key like Perplexity (`PERPLEXITY_API_KEY`) in environment
412: - Provides more informed task creation and updates
413: - Recommended for complex technical tasks
414: 
415: ---
416: 
417: _This guide ensures Claude Code has immediate access to Task Master's essential functionality for agentic development workflows._
</file>

<file path=".gemini/settings.json">
 1: {
 2:   "mcpServers": {
 3:     "context7": {
 4:       "command": "npx",
 5:       "args": ["-y", "@upstash/context7-mcp"]
 6:     },
 7:     "taskmaster": {
 8:       "command": "npx",
 9:       "args": ["-y", "--package=task-master-ai", "task-master-ai"]
10:     }
11:   }
12: }
</file>

<file path=".taskmaster/config.json">
 1: {
 2:   "models": {
 3:     "main": {
 4:       "provider": "openrouter",
 5:       "modelId": "openai/gpt-4.1",
 6:       "maxTokens": 32000,
 7:       "temperature": 0.2
 8:     },
 9:     "research": {
10:       "provider": "openrouter",
11:       "modelId": "perplexity/sonar-reasoning-pro",
12:       "maxTokens": 2700,
13:       "temperature": 0.1
14:     },
15:     "fallback": {
16:       "provider": "openrouter",
17:       "modelId": "openai/gpt-4.1-mini",
18:       "maxTokens": 10000,
19:       "temperature": 0.1
20:     }
21:   },
22:   "global": {
23:     "logLevel": "info",
24:     "debug": false,
25:     "defaultSubtasks": 5,
26:     "defaultPriority": "medium",
27:     "projectName": "Taskmaster",
28:     "ollamaBaseURL": "http://localhost:11434/api",
29:     "bedrockBaseURL": "https://bedrock.us-east-1.amazonaws.com",
30:     "defaultTag": "master",
31:     "azureOpenaiBaseURL": "https://your-endpoint.openai.azure.com/",
32:     "userId": "1234567890"
33:   }
34: }
</file>

<file path=".taskmaster/state.json">
1: {
2:   "currentTag": "master",
3:   "lastSwitched": "2025-07-01T23:01:27.048Z",
4:   "branchTagMapping": {},
5:   "migrationNoticeShown": true
6: }
</file>

<file path="llm_context/payload3/best_practices.md">
 1: # Payload 3 Best Practices
 2: 
 3: ## Collection Design
 4: - [x] Field type selection strategies - Define collections in separate files and import into main config
 5: - [x] Relationship modeling patterns - Use bi-directional relationships with join fields
 6: - [x] Access control implementation - Granular access rules in collection configs
 7: - [x] Validation rule patterns - Zod schema validation with custom errors
 8: - [x] Index optimization - Indexes for frequently queried fields
 9: 
10: ## API Usage
11: - [x] REST vs GraphQL decision criteria - REST for simplicity, GraphQL for complex data
12: - [x] Query optimization techniques - Depth parameters and selective fields
13: - [x] Pagination strategies - Cursor-based pagination for large datasets
14: - [x] Error handling patterns - Standardized error responses
15: - [x] Authentication integration - JWT with refresh tokens
16: 
17: ## Lexical Editor
18: - [x] Custom block creation - Implement through plugin development
19: - [x] Plugin development patterns - Extend core functionality with custom plugins
20: - [x] Content serialization - Server-side serialization for storage
21: - [x] Editor state management - Debounced updates for performance
22: - [x] Performance optimization - Virtualized rendering for large documents
23: 
24: ## Performance
25: - [x] Database query optimization - Indexing and query profiling
26: - [x] Caching strategies - Implement caching for frequent queries
27: - [x] Image optimization - Built-in transformations and CDN delivery
28: - [x] Bundle size management - Code splitting and dynamic imports
29: - [x] Server-side rendering - Next.js SSR for faster initial loads
30: 
31: ## Security
32: - [x] Access control patterns - Role-based access with inheritance
33: - [x] Input validation - Schema-based validation for all inputs
34: - [x] File upload security - Type validation and virus scanning
35: - [x] API rate limiting - Token bucket algorithm
36: - [x] Authentication best practices - Multi-factor authentication
37: - [x] Login security - Implement `maxLoginAttempts` and `lockTime` to prevent brute force attacks[1]
38: - [x] CSRF prevention - Enable CSRF protection for all API endpoints[1][5]
39: - [x] Session management - Use HttpOnly cookies for authentication tokens[5]
40: - [x] Environment security - Store sensitive data in environment variables[3]
41: - [x] Data encryption - Always use HTTPS for data transmission[3]
42: - [x] Audit logging - Implement detailed audit logs for all admin actions using plugins like `payload-auditor`[1][4]
43:   - Configure specific operations to log (create/update/delete)[1]
44:   - Set automated log cleanup with retention policies[1]
45:   - Include user information and payload details in logs[4]
46:   - Restrict access to audit logs using access control[1]
</file>

<file path=".taskmaster/reports/task-complexity-report.json">
  1: {
  2: 	"meta": {
  3: 		"generatedAt": "2025-07-02T02:26:31.794Z",
  4: 		"tasksAnalyzed": 14,
  5: 		"totalTasks": 16,
  6: 		"analysisCount": 16,
  7: 		"thresholdScore": 5,
  8: 		"projectName": "Taskmaster",
  9: 		"usedResearch": false
 10: 	},
 11: 	"complexityAnalysis": [
 12: 		{
 13: 			"taskId": 1,
 14: 			"taskTitle": "Initialize Project Structure and Dependencies",
 15: 			"complexityScore": 5,
 16: 			"recommendedSubtasks": 6,
 17: 			"expansionPrompt": "Break down the setup into: Next.js project initialization, dependency installation, configuration files setup, folder structure creation, environment variable management, and verification/testing of the setup.",
 18: 			"reasoning": "This task is foundational but follows well-documented patterns. It involves several discrete steps (project creation, dependency management, config, structure, and verification), each with moderate complexity. Existing subtasks cover most areas, but explicit environment management and more granular verification could be added."
 19: 		},
 20: 		{
 21: 			"taskId": 8,
 22: 			"taskTitle": "Develop Collection Management",
 23: 			"complexityScore": 7,
 24: 			"recommendedSubtasks": 7,
 25: 			"expansionPrompt": "Expand into: data model/relationship design, create/read/update/delete operations, advanced filtering, batch operations, authentication/access control, and comprehensive testing/optimization.",
 26: 			"reasoning": "CRUD with relationship handling, advanced filtering, and modern authentication/access control is moderately complex, especially with Payload CMS and Next.js integration. Requires careful schema and permission design."
 27: 		},
 28: 		{
 29: 			"taskId": 2,
 30: 			"taskTitle": "Configure Payload CMS and Database Integration",
 31: 			"complexityScore": 8,
 32: 			"recommendedSubtasks": 10,
 33: 			"expansionPrompt": "Break down the integration process into subtasks covering Payload CMS installation, Supabase PostgreSQL setup, environment variable management, initial collection schema design, authentication configuration, type generation, Next.js 15 integration, uploads/media handling, real-time updates, and testing/validation.",
 34: 			"reasoning": "This task involves complex integration between Payload CMS and Supabase PostgreSQL, advanced configuration (auth, real-time, uploads), and adherence to best practices with Next.js 15. It touches multiple architectural layers and requires careful setup and validation."
 35: 		},
 36: 		{
 37: 			"taskId": 3,
 38: 			"taskTitle": "Implement Authentication System",
 39: 			"complexityScore": 9,
 40: 			"recommendedSubtasks": 14,
 41: 			"expansionPrompt": "Decompose the authentication system into subtasks for configuration, registration, login, JWT/cookie handling, middleware, RBAC, session management, password reset, security hardening, Next.js integration, useAuth hook, CORS, custom strategies, and testing.",
 42: 			"reasoning": "This task is highly complex due to the need for secure, multi-strategy authentication, integration with both Payload CMS and Next.js 15, RBAC, session management, and extensibility for future providers. Security and correctness are critical."
 43: 		},
 44: 		{
 45: 			"taskId": 4,
 46: 			"taskTitle": "Set Up Form Infrastructure",
 47: 			"complexityScore": 8,
 48: 			"recommendedSubtasks": 12,
 49: 			"expansionPrompt": "Expand into subtasks for shared Zod schema setup, React Hook Form integration, TanStack Query mutations, Payload CMS submission, error handling, state management, reusable components, Next.js 15 server actions, dynamic form builder, performance optimization, authentication integration, and analytics.",
 50: 			"reasoning": "This task requires building a robust, reusable form system with advanced validation, state management, server actions, and integration with multiple libraries and authentication, making it architecturally significant."
 51: 		},
 52: 		{
 53: 			"taskId": 5,
 54: 			"taskTitle": "Implement Data Fetching Layer",
 55: 			"complexityScore": 9,
 56: 			"recommendedSubtasks": 12,
 57: 			"expansionPrompt": "Break down into subtasks for QueryClient setup, SSR hydration, caching, mutation/optimistic updates, authentication-aware querying, server actions, file upload handling, offline support, error/suspense boundaries, Payload CMS API integration, query key management, and testing.",
 58: 			"reasoning": "This task is highly complex due to SSR, caching, optimistic updates, offline/background sync, authentication integration, and support for both REST/GraphQL APIs, requiring deep knowledge of TanStack Query and Next.js 15."
 59: 		},
 60: 		{
 61: 			"taskId": 6,
 62: 			"taskTitle": "Create Dynamic Form Builder",
 63: 			"complexityScore": 7,
 64: 			"recommendedSubtasks": 8,
 65: 			"expansionPrompt": "Expand into subtasks for requirements analysis, data structure design, dynamic field rendering, validation mapping, validation logic, form generation, testing, and performance/UX optimization.",
 66: 			"reasoning": "Dynamic form generation based on CMS schemas is moderately complex, involving runtime field/validation mapping, performance, and integration with existing form infrastructure."
 67: 		},
 68: 		{
 69: 			"taskId": 7,
 70: 			"taskTitle": "Implement File Upload System",
 71: 			"complexityScore": 7,
 72: 			"recommendedSubtasks": 8,
 73: 			"expansionPrompt": "Break down into subtasks for Dropzone UI, file state management, Payload CMS media collection setup, upload API handler, TanStack Query mutation, progress UI, media management integration, and security/error handling.",
 74: 			"reasoning": "File upload involves UI/UX, backend integration, progress tracking, error handling, and security, but is more contained than core authentication or data fetching layers."
 75: 		},
 76: 		{
 77: 			"taskId": 9,
 78: 			"taskTitle": "Implement Role-Based UI Components",
 79: 			"complexityScore": 6,
 80: 			"recommendedSubtasks": 5,
 81: 			"expansionPrompt": "Expand into subtasks for PermissionGate and permission components, role-based navigation, conditional rendering utilities, protected layouts, and comprehensive testing.",
 82: 			"reasoning": "Role-based UI is important for security and UX, but the technical complexity is moderate as it builds on existing authentication and state management."
 83: 		},
 84: 		{
 85: 			"taskId": 10,
 86: 			"taskTitle": "Set Up Testing Infrastructure",
 87: 			"complexityScore": 7,
 88: 			"recommendedSubtasks": 6,
 89: 			"expansionPrompt": "Decompose into subtasks for Vitest unit test setup, Playwright E2E configuration, API testing with Supertest, React component testing patterns, Payload CMS collection testing, and CI pipeline integration.",
 90: 			"reasoning": "Comprehensive testing infrastructure is moderately complex, involving multiple tools (unit, E2E, API), CI integration, and coverage for both frontend and backend."
 91: 		},
 92: 		{
 93: 			"taskId": 11,
 94: 			"taskTitle": "Implement Error Handling and Monitoring",
 95: 			"complexityScore": 6,
 96: 			"recommendedSubtasks": 6,
 97: 			"expansionPrompt": "Expand into subtasks for defining error boundaries, implementing boundaries, integrating monitoring tools, developing notification systems, testing error workflows, and documentation.",
 98: 			"reasoning": "Global error handling and monitoring is essential but follows established patterns and tools, making it moderately complex."
 99: 		},
100: 		{
101: 			"taskId": 12,
102: 			"taskTitle": "Configure CI/CD Pipeline",
103: 			"complexityScore": 6,
104: 			"recommendedSubtasks": 6,
105: 			"expansionPrompt": "Break down into subtasks for defining workflow requirements, configuring environments, implementing workflow automation, integrating testing, validating setup, and documentation.",
106: 			"reasoning": "CI/CD setup is moderately complex, involving workflow scripting, environment management, and integration with deployment and testing tools."
107: 		},
108: 		{
109: 			"taskId": 13,
110: 			"taskTitle": "Implement and Configure Payload Auditor for Comprehensive Audit Logging",
111: 			"complexityScore": 5,
112: 			"recommendedSubtasks": 6,
113: 			"expansionPrompt": "Expand into subtasks for auditor plugin integration, audit hook configuration, log schema design, retention policy implementation, secure storage and querying, and documentation/testing.",
114: 			"reasoning": "Audit logging is important for compliance and security, but leverages existing plugins and established patterns, making it less complex than core architectural tasks."
115: 		},
116: 		{
117: 			"taskId": 14,
118: 			"taskTitle": "Establish and Enforce Strict TypeScript Typing Guidelines for Payload",
119: 			"complexityScore": 5,
120: 			"recommendedSubtasks": 5,
121: 			"expansionPrompt": "Break down into subtasks for guideline drafting, documentation updates, ESLint rule configuration, CI integration, and team communication/migration support.",
122: 			"reasoning": "Defining and enforcing typing standards is process-oriented and involves documentation, linting, and CI, but not deep technical implementation."
123: 		},
124: 		{
125: 			"taskId": 15,
126: 			"taskTitle": "Enforce Code Documentation Standards (Inline Comments & JSDoc/TSDoc)",
127: 			"complexityScore": 4,
128: 			"recommendedSubtasks": 5,
129: 			"expansionPrompt": "Expand into subtasks for defining documentation standards, updating documentation files, configuring linting/pre-commit hooks, onboarding/training, and validation/testing.",
130: 			"reasoning": "This is primarily a process and tooling task focused on documentation and linting, with low technical complexity."
131: 		},
132: 		{
133: 			"taskId": 16,
134: 			"taskTitle": "Review and Refine Form Composition for Complex Forms",
135: 			"complexityScore": 5,
136: 			"recommendedSubtasks": 5,
137: 			"expansionPrompt": "Break down into subtasks for auditing current forms, identifying issues, researching best practices, prototyping/refactoring, and documenting recommendations.",
138: 			"reasoning": "This is an analytical and architectural refinement task, requiring research, prototyping, and documentation, but not deep new implementation."
139: 		}
140: 	]
141: }
</file>

<file path=".taskmaster/tasks/tasks.json">
   1: {
   2:   "tasks": [
   3:     {
   4:       "id": 1,
   5:       "title": "Initialize Project Structure and Dependencies",
   6:       "description": "Set up Next.js project with TypeScript, configure essential dependencies, and establish folder structure according to PRD specifications.",
   7:       "details": "1. Create Next.js 14 project: `npx create-next-app@latest --typescript --tailwind --app`\n2. Install core dependencies:\n   - shadcn-ui: `npx shadcn-ui@latest init`\n   - @tanstack/react-query@5.x\n   - @hookform/resolvers@3.x\n   - zod@3.x\n   - zustand@4.x\n3. Configure dark theme in tailwind.config.ts\n4. Set up folder structure:\n   - /src/app (Next.js routes)\n   - /src/components\n   - /src/features\n   - /src/hooks\n   - /src/lib\n   - /src/styles\n   - /src/types\n   - /src/schemas",
   8:       "testStrategy": "1. Verify all dependencies install correctly\n2. Validate TypeScript configuration\n3. Test folder structure matches PRD\n4. Ensure development server starts successfully",
   9:       "priority": "high",
  10:       "dependencies": [],
  11:       "status": "done",
  12:       "subtasks": [
  13:         {
  14:           "id": 1,
  15:           "title": "Initialize Next.js Project with TypeScript",
  16:           "description": "Create a new Next.js project with TypeScript support using create-next-app",
  17:           "dependencies": [],
  18:           "details": "Run 'npx create-next-app@latest' with TypeScript flag, configure tsconfig.json for strict mode, and set up initial environment variables\n<info added on 2025-07-01T23:50:02.593Z>\nTask 1.1 verification completed successfully. Project structure and configuration confirmed as per requirements. Ready to proceed with Task 1.2: Install Core Dependencies.\n</info added on 2025-07-01T23:50:02.593Z>",
  19:           "status": "completed",
  20:           "testStrategy": ""
  21:         },
  22:         {
  23:           "id": 2,
  24:           "title": "Install Core Dependencies",
  25:           "description": "Install and configure essential project dependencies",
  26:           "dependencies": [
  27:             1
  28:           ],
  29:           "details": "Install Payload CMS, TanStack Query, React Hook Form, Zod, and required dev dependencies. Update package.json with correct versions\n<info added on 2025-07-01T23:55:42.019Z>\nSuccessfully installed all core dependencies for the restaurant management system using pnpm. Production dependencies include @tanstack/react-query@5.81.5, @tanstack/react-query-devtools@5.81.5, react-hook-form@7.59.0, @hookform/resolvers@5.1.1, zod@3.25.67, zustand@5.0.6, @radix-ui/react-slot@1.2.3, class-variance-authority@0.7.1, clsx@2.1.1, tailwind-merge@3.3.1, and lucide-react@0.525.0. Development dependencies include tailwindcss@4.1.11, postcss@8.5.6, and autoprefixer@10.4.21. All dependencies are correctly reflected in package.json. Ready to proceed with Task 1.3: Set Up Configuration Files.\n</info added on 2025-07-01T23:55:42.019Z>\n<info added on 2025-07-02T00:16:28.183Z>\nCompleted verification of core dependencies in payload-backend/package.json. Confirmed that all essential packages, including Payload CMS 3.0 with TypeScript, Next.js 15 with App Router, Vercel Postgres adapter, authentication/security packages, ESLint, Prettier, TypeScript, Vitest, and Playwright, are installed and up to date. No additional dependencies are required. Package.json scripts for development, build, and testing are properly configured. Ready to proceed to subtask 1.3: Set Up Configuration Files and enhance existing configurations as needed.\n</info added on 2025-07-02T00:16:28.183Z>\n<info added on 2025-07-02T00:48:25.321Z>\nProgress Update:\n\nAll core dependencies are installed and the project structure, TypeScript configuration, and Payload CMS backend are set up. However, 148 TypeScript errors were found across 19 collection files. Key issues include missing 'roles' and 'locations' properties in the User type, improperly typed collection slugs, and insufficient typing for access control functions. Next steps are to consult best practices from llm_context/payload3/, update User type definitions, define a CollectionSlug union type, improve typing for access controls, and resolve all TypeScript errors before moving forward.\n</info added on 2025-07-02T00:48:25.321Z>",
  30:           "status": "done",
  31:           "testStrategy": ""
  32:         },
  33:         {
  34:           "id": 3,
  35:           "title": "Set Up Configuration Files",
  36:           "description": "Create and configure essential configuration files for the project",
  37:           "dependencies": [
  38:             2
  39:           ],
  40:           "details": "Set up payload.config.ts, next.config.js, .env files, and TypeScript path aliases. Configure ESLint and Prettier",
  41:           "status": "done",
  42:           "testStrategy": ""
  43:         },
  44:         {
  45:           "id": 4,
  46:           "title": "Create Project Folder Structure",
  47:           "description": "Establish the recommended folder structure for the application",
  48:           "dependencies": [
  49:             3
  50:           ],
  51:           "details": "Create directories for components, hooks, utils, types, api, collections, and pages following Payload 3.0 patterns\n<info added on 2025-07-02T00:15:14.395Z>\nOrganize the project directories to align with Next.js App Router conventions by creating an 'app' directory at the root for routing and page components. Within 'app', structure subfolders for each route, and include layout, page, and loading files as needed. Ensure that directories for components, hooks, utils, types, api, and collections are placed at the root level, following Payload 3.0 best practices for modularity and maintainability.\n</info added on 2025-07-02T00:15:14.395Z>",
  52:           "status": "done",
  53:           "testStrategy": ""
  54:         },
  55:         {
  56:           "id": 5,
  57:           "title": "Verify Project Setup",
  58:           "description": "Test and verify the initial project setup",
  59:           "dependencies": [
  60:             4
  61:           ],
  62:           "details": "Run build process, verify TypeScript compilation, test Payload connection, and ensure all dependencies are working correctly\n<info added on 2025-07-02T00:13:39.872Z>\nTypeScript Compilation Check Results:\n\nFOUND 110 TypeScript ERRORS across 23 collection files that need immediate attention:\n\nCritical Issues Identified:\n1. Import Path Errors: All collection files are importing from 'payload/types' instead of 'payload'\n   - Need to change: import { CollectionConfig } from 'payload/types'\n   - To: import { CollectionConfig } from 'payload'\n\n2. Missing Type Annotations: Function parameters have implicit 'any' types\n   - Access control functions: ({ req: { user } }) - user parameter needs typing\n   - Hook functions: ({ data, operation, req }) - all parameters need typing\n   - Condition functions: Various callback parameters need proper typing\n\nFiles Affected:\n- All collection files in src/collections/ (23 files)\n- Most critical: Users.ts, Contacts.ts, EmployeeRatings.ts, Messages.ts\n\nNext Steps:\n1. Fix import statements across all collection files\n2. Add proper TypeScript types for Payload hook parameters\n3. Re-run TypeScript compilation to verify fixes\n4. Continue with remaining verification steps\n\nStatus: TypeScript compilation FAILED - requires fixes before proceeding\n</info added on 2025-07-02T00:13:39.872Z>",
  63:           "status": "done",
  64:           "testStrategy": ""
  65:         }
  66:       ]
  67:     },
  68:     {
  69:       "id": 2,
  70:       "title": "Configure Payload CMS and Database Integration",
  71:       "description": "Set up Payload CMS 3.0 with Supabase PostgreSQL integration and configure initial collections following best practices.",
  72:       "status": "in-progress",
  73:       "dependencies": [
  74:         1
  75:       ],
  76:       "priority": "high",
  77:       "details": "1. Install Payload: `npm install @payloadcms/payload@3.x`\n2. Configure Supabase connection:\n   - Install `@supabase/supabase-js@2.x`\n   - Set up environment variables\n3. Initialize Payload config with best practices:\n```typescript\nconst config: PayloadConfig = {\n  collections: [],\n  db: {\n    type: 'postgres',\n    url: process.env.SUPABASE_URL\n  },\n  auth: {\n    tokenExpiration: 7200, // recommended 2 hours\n    cookies: {\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'lax',\n      httpOnly: true\n    },\n    useRESTAPI: true // enable client-side authentication with REST API\n  },\n  typescript: {\n    outputFile: 'payload-types.ts'\n  },\n  serverURL: process.env.SERVER_URL,\n  uploads: {\n    collections: ['uploads'] // for QR feedback media attachments\n  },\n  realtime: {\n    enabled: true, // enable WebSocket real-time updates\n    collections: ['employeeRatings']\n  }\n}\n```\n4. Use Payload's built-in type generation: `npx payload generate:types`\n5. Implement type-safe collections using generics\n6. Set up local API utilization for server components\n7. Implement device-based authentication for hotspot logins\n8. Follow latest Next.js 15 integration patterns with Payload CMS",
  78:       "testStrategy": "1. Verify Payload admin panel accessibility\n2. Test database connection\n3. Validate environment variables\n4. Confirm JWT and cookie configuration with HttpOnly and secure flags\n5. Test client-side authentication via REST API\n6. Validate type-safe collections and generated types\n7. Test device-based authentication workflows\n8. Verify uploads collection handles QR feedback media\n9. Confirm real-time updates via WebSockets for employee ratings\n10. Ensure Next.js 15 integration follows recommended patterns",
  79:       "subtasks": [
  80:         {
  81:           "id": 2,
  82:           "title": "Initialize Payload CMS Project Structure",
  83:           "description": "Set up basic Payload CMS project structure with TypeScript configuration",
  84:           "status": "in-progress",
  85:           "dependencies": [
  86:             1
  87:           ],
  88:           "details": "Initialize project with payload create, configure tsconfig.json, set up project folders (collections, fields, hooks), implement proper type definitions",
  89:           "testStrategy": ""
  90:         },
  91:         {
  92:           "id": 3,
  93:           "title": "Configure Environment Variables",
  94:           "description": "Set up environment configuration for different deployment stages",
  95:           "status": "in-progress",
  96:           "dependencies": [
  97:             2
  98:           ],
  99:           "details": "Create .env files for development/production, implement environment variable validation, set up secure key management, configure deployment-specific settings",
 100:           "testStrategy": ""
 101:         },
 102:         {
 103:           "id": 5,
 104:           "title": "Create Initial Collections Schema",
 105:           "description": "Define and implement initial collection structures with TypeScript and generics",
 106:           "status": "in-progress",
 107:           "dependencies": [
 108:             2
 109:           ],
 110:           "details": "Create collection types, implement field validations with Zod, set up relationships between collections, configure access control, implement hooks, use uploads collection for QR feedback media attachments",
 111:           "testStrategy": ""
 112:         },
 113:         {
 114:           "id": 9,
 115:           "title": "Implement Real-Time Updates with WebSockets",
 116:           "description": "Add real-time update capabilities for employee ratings using WebSockets",
 117:           "status": "in-progress",
 118:           "dependencies": [
 119:             5
 120:           ],
 121:           "details": "Configure WebSocket server integration, implement subscription handlers for employee ratings collection, ensure real-time data synchronization in admin and client apps",
 122:           "testStrategy": "Test real-time updates propagation on employee ratings changes"
 123:         },
 124:         {
 125:           "id": 10,
 126:           "title": "Integrate Payload CMS with Next.js 15",
 127:           "description": "Follow latest Next.js 15 integration patterns with Payload CMS",
 128:           "status": "in-progress",
 129:           "dependencies": [
 130:             2
 131:           ],
 132:           "details": "Implement server components using local Payload API, configure middleware for authentication, optimize Payload usage with Next.js 15 features",
 133:           "testStrategy": "Verify Next.js 15 server components correctly consume Payload API and authentication flows"
 134:         },
 135:         {
 136:           "id": 11,
 137:           "title": "Generate Payload Types",
 138:           "description": "Configure Payload to automatically generate TypeScript types for collections and globals.",
 139:           "details": "",
 140:           "status": "deferred",
 141:           "dependencies": [],
 142:           "parentTaskId": 2
 143:         },
 144:         {
 145:           "id": 12,
 146:           "title": "Set up Postgres Database Configuration",
 147:           "description": "Configure Postgres connection settings and initialize the database for Payload CMS",
 148:           "details": "Add and validate DATABASE_URL in environment configuration; set up initial schema migrations using Payload CMS tooling; verify connectivity with a test script or psql client; update documentation to reflect Postgres usage.",
 149:           "status": "done",
 150:           "dependencies": [],
 151:           "parentTaskId": 2
 152:         }
 153:       ]
 154:     },
 155:     {
 156:       "id": 3,
 157:       "title": "Implement Authentication System",
 158:       "description": "Develop authentication flow using Payload CMS v3 with Next.js 15 integration, leveraging HTTP-only cookies as primary authentication strategy and JWT tokens as fallback.",
 159:       "status": "pending",
 160:       "dependencies": [
 161:         2
 162:       ],
 163:       "priority": "high",
 164:       "details": "1. Implement HTTP-only cookies as primary authentication strategy for XSS protection with secure cookie settings including tokenExpiration, secure flags, and sameSite strict.\n2. Configure Next.js middleware for route protection using Payload's /api/users/me endpoint.\n3. Implement role-based access control (RBAC) using Payload's access control hooks.\n4. Create PermissionGate component for frontend role enforcement.\n5. Set up login/logout handlers with credentials: 'include' for cookie management.\n6. Implement useAuth hook with TanStack Query for session state management and session revalidation using SWR patterns.\n7. Configure CORS headers in Payload for seamless Next.js integration.\n8. Add JWT implementation as fallback for non-browser clients.\n9. Implement password lockout policies and rate limiting for enhanced security.\n10. Create custom auth strategy support to enable future Firebase integration.",
 165:       "testStrategy": "1. Test login/logout flow with HTTP-only cookies and credentials: 'include'.\n2. Verify secure cookie settings including token expiration, secure flags, and sameSite strict.\n3. Validate Next.js middleware route protection using Payload's /api/users/me endpoint.\n4. Test role-based access control enforcement both backend (Payload hooks) and frontend (PermissionGate component).\n5. Verify JWT fallback authentication for non-browser clients.\n6. Test password lockout policies and rate limiting effectiveness.\n7. Validate session revalidation using SWR patterns.\n8. Confirm CORS headers are correctly configured for Next.js integration.\n9. Ensure custom auth strategy support is extensible for Firebase integration.",
 166:       "subtasks": [
 167:         {
 168:           "id": 1,
 169:           "title": "Setup Authentication Configuration",
 170:           "description": "Create authentication configuration files and environment variables for JWT secrets, token expiration, and security settings",
 171:           "status": "in-progress",
 172:           "dependencies": [],
 173:           "details": "Define JWT secret keys, token expiration times, password requirements, and other security parameters in a type-safe configuration",
 174:           "testStrategy": ""
 175:         },
 176:         {
 177:           "id": 2,
 178:           "title": "Implement User Registration Flow",
 179:           "description": "Create registration endpoint and form with email/password validation using React Hook Form and Zod",
 180:           "status": "in-progress",
 181:           "dependencies": [
 182:             1
 183:           ],
 184:           "details": "Build registration form component, implement Zod validation schema, handle form submission with TanStack Query mutation",
 185:           "testStrategy": ""
 186:         },
 187:         {
 188:           "id": 3,
 189:           "title": "Implement Login Flow",
 190:           "description": "Create login endpoint and form with proper credential validation and JWT token generation",
 191:           "status": "in-progress",
 192:           "dependencies": [
 193:             1
 194:           ],
 195:           "details": "Build login form component, implement credential verification, generate and return JWT tokens, handle login errors",
 196:           "testStrategy": ""
 197:         },
 198:         {
 199:           "id": 4,
 200:           "title": "Setup JWT Middleware",
 201:           "description": "Create middleware for JWT verification and user authentication on protected routes",
 202:           "status": "in-progress",
 203:           "dependencies": [
 204:             1,
 205:             3
 206:           ],
 207:           "details": "Implement JWT verification middleware, handle token extraction from headers, validate token expiration and signature",
 208:           "testStrategy": ""
 209:         },
 210:         {
 211:           "id": 5,
 212:           "title": "Implement Password Reset Flow",
 213:           "description": "Create password reset endpoints and forms with email verification",
 214:           "status": "pending",
 215:           "dependencies": [
 216:             1,
 217:             3
 218:           ],
 219:           "details": "Build password reset request form, implement email verification, create reset token handling, build password update form",
 220:           "testStrategy": ""
 221:         },
 222:         {
 223:           "id": 6,
 224:           "title": "Setup Authentication Context",
 225:           "description": "Create React context for managing authentication state and user information",
 226:           "status": "pending",
 227:           "dependencies": [
 228:             3,
 229:             4
 230:           ],
 231:           "details": "Implement AuthContext with user state, login/logout methods, token management, and proper TypeScript types",
 232:           "testStrategy": ""
 233:         },
 234:         {
 235:           "id": 9,
 236:           "title": "Implement Session Management",
 237:           "description": "Create session handling logic for token refresh and expiration",
 238:           "status": "pending",
 239:           "dependencies": [
 240:             4,
 241:             6
 242:           ],
 243:           "details": "Implement token refresh logic, handle session timeouts, manage token storage securely",
 244:           "testStrategy": ""
 245:         },
 246:         {
 247:           "id": 10,
 248:           "title": "Security Hardening",
 249:           "description": "Implement additional security measures and best practices",
 250:           "status": "pending",
 251:           "dependencies": [
 252:             1,
 253:             4,
 254:             9
 255:           ],
 256:           "details": "Add rate limiting, implement CSRF protection, secure cookie handling, XSS prevention measures",
 257:           "testStrategy": ""
 258:         },
 259:         {
 260:           "id": 11,
 261:           "title": "Integrate Next.js Middleware for Route Protection",
 262:           "description": "Implement Next.js 15 middleware to protect routes by verifying authentication status via Payload's /api/users/me endpoint",
 263:           "status": "pending",
 264:           "dependencies": [
 265:             4
 266:           ],
 267:           "details": "Create middleware that intercepts requests, validates HTTP-only cookies, fetches user session from Payload API, and redirects unauthorized users",
 268:           "testStrategy": "Test middleware correctly protects routes and redirects unauthorized access."
 269:         },
 270:         {
 271:           "id": 12,
 272:           "title": "Configure Secure HTTP-only Cookies",
 273:           "description": "Set up secure cookie settings including tokenExpiration, secure flags, and sameSite strict for authentication cookies",
 274:           "status": "pending",
 275:           "dependencies": [
 276:             1
 277:           ],
 278:           "details": "Configure Payload and Next.js to use HTTP-only cookies with appropriate security flags to prevent XSS and CSRF attacks",
 279:           "testStrategy": "Verify cookies have correct flags and expire as configured."
 280:         },
 281:         {
 282:           "id": 13,
 283:           "title": "Implement useAuth Hook with TanStack Query and SWR",
 284:           "description": "Create useAuth hook that manages session state using TanStack Query and supports session revalidation with SWR patterns",
 285:           "status": "pending",
 286:           "dependencies": [
 287:             6
 288:           ],
 289:           "details": "Implement hook to fetch current user session, handle login/logout, and revalidate session periodically or on focus",
 290:           "testStrategy": "Test session state updates and revalidation behavior."
 291:         },
 292:         {
 293:           "id": 14,
 294:           "title": "Implement Role-Based Access Control (RBAC) with Payload Hooks",
 295:           "description": "Use Payload CMS access control hooks to enforce RBAC on backend resources",
 296:           "status": "pending",
 297:           "dependencies": [
 298:             1
 299:           ],
 300:           "details": "Define roles and permissions in Payload, implement access control hooks to restrict data access accordingly",
 301:           "testStrategy": "Verify access restrictions based on user roles."
 302:         },
 303:         {
 304:           "id": 15,
 305:           "title": "Create PermissionGate Component",
 306:           "description": "Develop frontend PermissionGate component to enforce role-based access control in UI",
 307:           "status": "pending",
 308:           "dependencies": [
 309:             6,
 310:             14
 311:           ],
 312:           "details": "Component checks user roles and permissions to conditionally render children or redirect/deny access",
 313:           "testStrategy": "Test component hides or shows UI elements based on user permissions."
 314:         },
 315:         {
 316:           "id": 16,
 317:           "title": "Configure CORS Headers for Next.js Integration",
 318:           "description": "Set up CORS headers in Payload CMS to allow requests from Next.js frontend",
 319:           "status": "pending",
 320:           "dependencies": [
 321:             1
 322:           ],
 323:           "details": "Configure allowed origins, methods, and headers to enable secure cross-origin requests",
 324:           "testStrategy": "Verify CORS headers are correctly set and requests succeed."
 325:         },
 326:         {
 327:           "id": 17,
 328:           "title": "Add JWT Fallback Authentication",
 329:           "description": "Implement JWT token authentication fallback for non-browser clients that cannot use cookies",
 330:           "status": "pending",
 331:           "dependencies": [
 332:             4
 333:           ],
 334:           "details": "Support JWT token extraction from headers and validation for API clients without cookie support",
 335:           "testStrategy": "Test API access using JWT tokens without cookies."
 336:         },
 337:         {
 338:           "id": 18,
 339:           "title": "Implement Password Lockout and Rate Limiting",
 340:           "description": "Add security measures including password lockout policies and rate limiting to prevent brute force attacks",
 341:           "status": "pending",
 342:           "dependencies": [
 343:             10
 344:           ],
 345:           "details": "Configure Payload and API endpoints to track failed login attempts, lock accounts temporarily, and limit request rates",
 346:           "testStrategy": "Verify lockout triggers after threshold and rate limiting blocks excessive requests."
 347:         },
 348:         {
 349:           "id": 19,
 350:           "title": "Create Custom Auth Strategy Support",
 351:           "description": "Design authentication system extensible to support future custom strategies such as Firebase integration",
 352:           "status": "pending",
 353:           "dependencies": [
 354:             6
 355:           ],
 356:           "details": "Abstract authentication logic to allow plugging in alternative auth providers and strategies",
 357:           "testStrategy": "Validate ability to add and switch custom auth strategies."
 358:         }
 359:       ]
 360:     },
 361:     {
 362:       "id": 4,
 363:       "title": "Set Up Form Infrastructure",
 364:       "description": "Implement core form handling infrastructure using React Hook Form v7, Zod validation, and Next.js 15 patterns, aligned with Payload CMS 3.0 and TanStack Query v5 best practices.",
 365:       "status": "in-progress",
 366:       "dependencies": [
 367:         1
 368:       ],
 369:       "priority": "high",
 370:       "details": "1. Implement shared Zod schemas as the single source of truth for client and server validation.\n2. Configure React Hook Form v7 with zodResolver for seamless and real-time validation.\n3. Integrate TanStack Query v5 mutations with optimistic updates and rollback capabilities.\n4. Follow Payload CMS 3.0 patterns for form data submission and schema integration.\n5. Implement proper error handling using toast notifications for user feedback.\n6. Add comprehensive form state management including loading, success, and error states.\n7. Use shadcn/ui form components with Controller integration and robust error handling.\n8. Implement Next.js 15 Server Actions with shared Zod schema validation for unified client-server form handling.\n9. Create a dynamic form builder with a field registry supporting Payload CMS-driven forms.\n10. Add performance optimizations including isolated re-renders, debounced validation, and memoized schemas.\n11. Implement a comprehensive error handling strategy covering client, server, and global errors.\n12. Create reusable form components and hooks to enforce consistent form patterns across the application.\n13. Integrate with the authentication system to ensure secure form submissions.\n14. Add form analytics and validation tracking to monitor form usage and errors.",
 371:       "testStrategy": "1. Test shared Zod schemas for consistent client and server validation.\n2. Verify React Hook Form v7 integration with zodResolver for seamless validation.\n3. Test TanStack Query v5 mutations with optimistic updates and rollback.\n4. Validate Payload CMS 3.0 form submission patterns.\n5. Test toast notification error handling for form errors.\n6. Validate form state management including loading, success, and error states.\n7. Validate shadcn/ui form components with Controller integration and error handling.\n8. Test Next.js 15 Server Actions with shared Zod schema validation.\n9. Verify dynamic form builder functionality with Payload CMS-driven forms.\n10. Measure performance optimizations including isolated re-renders and debounced validation.\n11. Test comprehensive error handling across client, server, and global contexts.\n12. Test reusable form components and hooks for consistent behavior.\n13. Verify secure form submissions with authentication integration.\n14. Validate form analytics and validation tracking accuracy.",
 372:       "subtasks": [
 373:         {
 374:           "id": 1,
 375:           "title": "Set up Form Component Base Structure",
 376:           "description": "Create the base form component architecture using React Hook Form and TypeScript",
 377:           "status": "in-progress",
 378:           "dependencies": [],
 379:           "details": "Initialize form component with React Hook Form\nDefine TypeScript interfaces for form data\nCreate basic form wrapper component\nSetup form context provider",
 380:           "testStrategy": ""
 381:         },
 382:         {
 383:           "id": 2,
 384:           "title": "Implement Zod Validation Schema",
 385:           "description": "Define comprehensive validation schemas using Zod for form fields",
 386:           "status": "pending",
 387:           "dependencies": [
 388:             1
 389:           ],
 390:           "details": "Create shared Zod validation schema for client and server\nDefine custom validation rules\nImplement error message templates\nIntegrate schema with React Hook Form using zodResolver",
 391:           "testStrategy": ""
 392:         },
 393:         {
 394:           "id": 3,
 395:           "title": "Develop Form Field Components",
 396:           "description": "Create reusable form field components with proper typing",
 397:           "status": "pending",
 398:           "dependencies": [
 399:             1,
 400:             2
 401:           ],
 402:           "details": "Build input field component\nCreate select field component\nImplement checkbox and radio components\nAdd proper TypeScript types for all components",
 403:           "testStrategy": ""
 404:         },
 405:         {
 406:           "id": 5,
 407:           "title": "Setup TanStack Query Integration",
 408:           "description": "Integrate TanStack Query v5 for form data fetching and submission",
 409:           "status": "pending",
 410:           "dependencies": [
 411:             1
 412:           ],
 413:           "details": "Configure TanStack Query v5 client\nSetup query hooks for data fetching\nImplement mutation hooks for form submission with optimistic updates and rollback\nAdd loading states handling",
 414:           "testStrategy": ""
 415:         },
 416:         {
 417:           "id": 6,
 418:           "title": "Add Form Submission Logic",
 419:           "description": "Implement form submission handling with proper error management",
 420:           "status": "pending",
 421:           "dependencies": [
 422:             5
 423:           ],
 424:           "details": "Create submission handler function following Payload CMS 3.0 submission patterns\nImplement success/error toast notifications\nAdd loading state management\nSetup retry logic for failed submissions",
 425:           "testStrategy": ""
 426:         },
 427:         {
 428:           "id": 7,
 429:           "title": "Implement Form State Management",
 430:           "description": "Add comprehensive form state management and field tracking",
 431:           "status": "pending",
 432:           "dependencies": [
 433:             3,
 434:             6
 435:           ],
 436:           "details": "Setup form state persistence\nImplement dirty state tracking\nAdd form reset functionality\nCreate form state debug tools\nManage loading, success, and error states effectively",
 437:           "testStrategy": ""
 438:         },
 439:         {
 440:           "id": 8,
 441:           "title": "Integrate Next.js 15 Server Actions with Shared Zod Validation",
 442:           "description": "Implement Next.js 15 Server Actions using shared Zod schemas for unified client-server validation",
 443:           "status": "pending",
 444:           "dependencies": [
 445:             2,
 446:             6
 447:           ],
 448:           "details": "Create server action handlers for form submissions\nReuse Zod validation schemas on server and client\nEnsure seamless error propagation between server and client\nTest server action integration with form submission flow",
 449:           "testStrategy": "Test server actions with valid and invalid data\nVerify shared validation schema enforcement\nCheck error handling and propagation"
 450:         },
 451:         {
 452:           "id": 9,
 453:           "title": "Create Dynamic Form Builder with Field Registry",
 454:           "description": "Develop a dynamic form builder supporting Payload CMS-driven forms using a field registry pattern",
 455:           "status": "pending",
 456:           "dependencies": [
 457:             3
 458:           ],
 459:           "details": "Implement field registry to map field types to components\nBuild dynamic form renderer based on registry and form schema\nSupport Payload CMS 3.0 form schema integration\nEnsure proper typing and validation for dynamic fields",
 460:           "testStrategy": "Test dynamic form rendering with various Payload CMS schemas\nValidate field registry mappings\nVerify validation and submission of dynamic forms"
 461:         },
 462:         {
 463:           "id": 10,
 464:           "title": "Add Performance Optimizations",
 465:           "description": "Optimize form performance with isolated re-renders, debounced validation, and memoized schemas",
 466:           "status": "pending",
 467:           "dependencies": [
 468:             3,
 469:             2
 470:           ],
 471:           "details": "Implement isolated re-renders for form fields\nAdd debounced validation to reduce validation frequency\nMemoize Zod schemas to prevent unnecessary recalculations\nProfile and optimize form rendering performance",
 472:           "testStrategy": "Measure render counts before and after optimizations\nTest debounced validation behavior\nVerify memoized schema usage"
 473:         },
 474:         {
 475:           "id": 12,
 476:           "title": "Create Reusable Form Components and Hooks",
 477:           "description": "Develop reusable form components and custom hooks to enforce consistent form patterns",
 478:           "status": "pending",
 479:           "dependencies": [
 480:             3,
 481:             7
 482:           ],
 483:           "details": "Build reusable input, select, checkbox, and radio components with Controller integration\nCreate custom hooks for form state management and validation\nDocument usage patterns for consistent implementation\nEnsure accessibility and theming support",
 484:           "testStrategy": "Test reusable components in isolation and integrated forms\nValidate custom hooks behavior\nCheck accessibility compliance"
 485:         },
 486:         {
 487:           "id": 13,
 488:           "title": "Integrate Authentication System for Secure Form Submissions",
 489:           "description": "Ensure form submissions are secure by integrating with the authentication system",
 490:           "status": "pending",
 491:           "dependencies": [
 492:             6,
 493:             8
 494:           ],
 495:           "details": "Add authentication context to form components\nProtect form submission endpoints\nHandle authentication errors gracefully\nTest secure submission flows with authenticated and unauthenticated users",
 496:           "testStrategy": "Verify form submission requires authentication\nTest error handling for unauthorized submissions\nValidate authenticated user flows"
 497:         },
 498:         {
 499:           "id": 14,
 500:           "title": "Add Form Analytics and Validation Tracking",
 501:           "description": "Implement analytics and tracking for form usage and validation events",
 502:           "status": "pending",
 503:           "dependencies": [
 504:             7,
 505:             12
 506:           ],
 507:           "details": "Integrate analytics tracking for form interactions\nTrack validation errors and submission outcomes\nProvide dashboards or logs for monitoring form performance\nEnsure privacy compliance in analytics collection",
 508:           "testStrategy": "Verify analytics events fire on form interactions\nTest validation error tracking\nReview analytics data for accuracy and completeness"
 509:         }
 510:       ]
 511:     },
 512:     {
 513:       "id": 5,
 514:       "title": "Implement Data Fetching Layer",
 515:       "description": "Set up TanStack Query v5 infrastructure for data fetching with SSR hydration, optimistic updates, caching, and Next.js 15 App Router best practices, including Server Actions integration, authentication-aware querying, file upload progress tracking, Payload CMS 3.0 REST/GraphQL API support, and offline capabilities with background sync for real-time restaurant data updates.",
 516:       "status": "pending",
 517:       "dependencies": [
 518:         2,
 519:         3
 520:       ],
 521:       "priority": "high",
 522:       "details": "1. Implement factory pattern for QueryClient configuration with optimized defaults for SSR and client-side caching, including query deduplication, stale-while-revalidate, and garbage collection optimizations tailored for restaurant data\n2. Set up HydrationBoundary for seamless server-to-client state transfer with Next.js 15 Server Components\n3. Integrate Server Actions with TanStack Query mutations to enable optimistic updates and rollback support\n4. Configure authentication-aware querying with automatic cache invalidation on authentication state changes\n5. Implement file upload mutations with optimistic UI updates and progress tracking\n6. Create custom hooks for common data fetching patterns such as lists, details, and mutations to improve developer experience\n7. Set up error boundaries, suspense boundaries, and retry logic for robust and resilient data operations\n8. Implement cache persistence, offline support, and background synchronization strategies to maintain data consistency and enable real-time updates across sessions\n9. Add data transformation and serialization mechanisms for handling complex types in queries and mutations\n10. Configure query invalidation patterns to support real-time updates and ensure data freshness, especially for restaurant data with stale-while-revalidate patterns\n11. Integrate with Payload CMS 3.0 REST and GraphQL APIs using type-safe queries and mutations\n12. Maintain consistent query key management and cache invalidation strategies aligned with Next.js 15 App Router patterns and Payload CMS integration\n13. Implement proper loading states and suspense boundaries to enhance UX during data fetching",
 523:       "testStrategy": "1. Test SSR hydration and dehydration correctness including pending queries and Server Components integration\n2. Validate query caching behavior including deduplication, stale-while-revalidate, and garbage collection\n3. Verify optimistic updates and rollback functionality with Server Actions integration\n4. Test authentication state synchronization triggers query invalidation and UI updates\n5. Validate optimistic UI and progress tracking during file uploads\n6. Test custom hooks for data fetching patterns for correctness and type safety\n7. Confirm error boundary and suspense boundary handling and retry logic under failure scenarios\n8. Validate cache persistence, offline support, and background synchronization across sessions\n9. Test data transformation and serialization correctness for complex types\n10. Verify real-time query invalidation and data freshness, especially for restaurant data\n11. Confirm integration with Payload CMS 3.0 REST and GraphQL APIs with type safety\n12. Test loading states and suspense boundaries for smooth user experience during data fetching",
 524:       "subtasks": [
 525:         {
 526:           "id": 1,
 527:           "title": "Query Client Setup",
 528:           "description": "Initialize TanStack Query client with Next.js 15 App Router",
 529:           "status": "pending",
 530:           "dependencies": [],
 531:           "details": "Create a factory function to generate QueryClient instances with default options (staleTime, refetchOnWindowFocus). Implement browser/server detection to avoid memory leaks. Wrap the app in QueryClientProvider.",
 532:           "testStrategy": ""
 533:         },
 534:         {
 535:           "id": 2,
 536:           "title": "Hydration Boundaries",
 537:           "description": "Implement server-to-client data hydration",
 538:           "status": "pending",
 539:           "dependencies": [
 540:             1
 541:           ],
 542:           "details": "Use HydrationBoundary to pass dehydrated server data to client components. Create serialization transformers for data compatibility between server and client environments. Prefetch queries in Server Components using prefetchQuery.",
 543:           "testStrategy": ""
 544:         },
 545:         {
 546:           "id": 3,
 547:           "title": "Caching Strategy",
 548:           "description": "Configure query caching mechanisms",
 549:           "status": "pending",
 550:           "dependencies": [
 551:             1
 552:           ],
 553:           "details": "Set global cache policies (staleTime, gcTime) in QueryClient defaults. Implement type-safe query keys using TypeScript. Customize shouldDehydrateQuery for SSR optimization.",
 554:           "testStrategy": ""
 555:         },
 556:         {
 557:           "id": 4,
 558:           "title": "Mutation Handlers",
 559:           "description": "Implement CRUD operations with mutations",
 560:           "status": "pending",
 561:           "dependencies": [
 562:             1
 563:           ],
 564:           "details": "Create mutation functions for POST/PUT/DELETE requests. Implement optimistic updates using onMutate and rollbacks via onError. Integrate with Server Actions for Next.js backend operations.",
 565:           "testStrategy": ""
 566:         },
 567:         {
 568:           "id": 6,
 569:           "title": "Optimistic Updates",
 570:           "description": "Implement UI responsiveness for mutations",
 571:           "status": "pending",
 572:           "dependencies": [
 573:             4
 574:           ],
 575:           "details": "Use onMutate to update cache immediately. Implement rollback via onError using context from onMutate. Update query cache directly for instant UI feedback during mutations.",
 576:           "testStrategy": ""
 577:         },
 578:         {
 579:           "id": 7,
 580:           "title": "Authentication-Aware Querying",
 581:           "description": "Integrate auth with query flow",
 582:           "status": "pending",
 583:           "dependencies": [
 584:             1
 585:           ],
 586:           "details": "Attach authorization tokens via queryFnContext. Implement automatic token refresh on 401 errors. Create auth-aware query hooks that check authentication state before fetching.",
 587:           "testStrategy": ""
 588:         },
 589:         {
 590:           "id": 8,
 591:           "title": "Factory Patterns",
 592:           "description": "Create reusable query factories",
 593:           "status": "pending",
 594:           "dependencies": [
 595:             1,
 596:             3,
 597:             7
 598:           ],
 599:           "details": "Develop factory functions for common query patterns (paginated, infinite). Implement parameterized hook generators. Create mutation factories with pre-configured optimistic updates and error handling.",
 600:           "testStrategy": ""
 601:         },
 602:         {
 603:           "id": 9,
 604:           "title": "Offline Support and Background Sync",
 605:           "description": "Enable offline capabilities and background data synchronization",
 606:           "status": "pending",
 607:           "dependencies": [
 608:             1,
 609:             3
 610:           ],
 611:           "details": "Implement cache persistence strategies to support offline usage. Configure background synchronization to update queries when connectivity is restored. Ensure data consistency and real-time updates for restaurant data.",
 612:           "testStrategy": "Test offline mode functionality including cache usage and background sync triggering upon reconnect."
 613:         },
 614:         {
 615:           "id": 10,
 616:           "title": "Loading States and Suspense Boundaries",
 617:           "description": "Implement loading UI and suspense boundaries for data fetching",
 618:           "status": "pending",
 619:           "dependencies": [
 620:             1,
 621:             2,
 622:             3
 623:           ],
 624:           "details": "Add proper loading indicators and suspense boundaries to improve user experience during data fetching. Ensure compatibility with Next.js 15 Server Components and TanStack Query suspense mode.",
 625:           "testStrategy": "Validate loading states and suspense boundaries render correctly during data fetch delays and transitions."
 626:         }
 627:       ]
 628:     },
 629:     {
 630:       "id": 6,
 631:       "title": "Create Dynamic Form Builder",
 632:       "description": "Develop system for dynamically generating forms based on Payload collections, integrating latest React Hook Form v7 and Zod validation best practices.",
 633:       "status": "pending",
 634:       "dependencies": [
 635:         4,
 636:         5
 637:       ],
 638:       "priority": "medium",
 639:       "details": "1. Implement TypeScript integration with Zod schemas as single source of truth for form validation.\n2. Create a field registry pattern to dynamically generate form fields from Payload CMS configurations.\n3. Use type-safe form hooks with zodResolver and generics for robust form handling.\n4. Optimize performance with isolated re-renders using useFormContext, debounced validation, and virtualized field arrays.\n5. Integrate TanStack Query for optimistic form submission with rollback capabilities.\n6. Add structured error mapping from Zod to field-specific messages and handle server-side validation sync with Payload CMS errors.\n7. Implement file upload integration using react-dropzone and Controller.\n8. Generate dynamic validation schemas from Payload field configurations.\n9. Enhance testing strategies to cover validation logic and form submission flows comprehensively.",
 640:       "testStrategy": "1. Test dynamic field rendering with field registry pattern.\n2. Verify type-safe validation rules using Zod schemas.\n3. Test debounced and virtualized validation updates.\n4. Validate optimistic form submission and rollback with TanStack Query.\n5. Ensure structured error mapping from Zod and server-side error synchronization.\n6. Test file upload integration with react-dropzone.\n7. Perform end-to-end tests covering dynamic validation schema generation and form submission.",
 641:       "subtasks": [
 642:         {
 643:           "id": 1,
 644:           "title": "Analyze Requirements for Dynamic Field Rendering",
 645:           "description": "Gather and analyze detailed requirements for dynamic field rendering including supported field types, conditional visibility, and data sources.",
 646:           "dependencies": [],
 647:           "details": "Review project documentation and stakeholder inputs to understand all dynamic rendering scenarios and constraints.",
 648:           "status": "pending",
 649:           "testStrategy": ""
 650:         },
 651:         {
 652:           "id": 2,
 653:           "title": "Design Data Structures for Dynamic Fields",
 654:           "description": "Design appropriate data structures and schemas to represent dynamic fields and their properties for rendering and validation.",
 655:           "dependencies": [
 656:             1
 657:           ],
 658:           "details": "Create JSON schemas or equivalent models that capture field types, validation rules, dependencies, and rendering metadata.",
 659:           "status": "pending",
 660:           "testStrategy": ""
 661:         },
 662:         {
 663:           "id": 3,
 664:           "title": "Implement Dynamic Field Rendering Engine",
 665:           "description": "Develop the core engine responsible for rendering form fields dynamically based on the designed data structures and runtime data.",
 666:           "dependencies": [
 667:             2
 668:           ],
 669:           "details": "Use a UI framework to implement components that render fields conditionally and support dynamic updates.",
 670:           "status": "pending",
 671:           "testStrategy": ""
 672:         },
 673:         {
 674:           "id": 4,
 675:           "title": "Map Validation Rules to Fields",
 676:           "description": "Create a mapping system that associates validation rules with each dynamic field based on the data structures.",
 677:           "dependencies": [
 678:             2
 679:           ],
 680:           "details": "Define validation rule formats and implement logic to attach these rules to fields for runtime validation.",
 681:           "status": "pending",
 682:           "testStrategy": ""
 683:         },
 684:         {
 685:           "id": 5,
 686:           "title": "Implement Validation Logic",
 687:           "description": "Develop the validation logic that enforces the mapped validation rules on dynamic fields during form interaction and submission.",
 688:           "dependencies": [
 689:             4
 690:           ],
 691:           "details": "Implement synchronous and asynchronous validation mechanisms, error handling, and user feedback.",
 692:           "status": "pending",
 693:           "testStrategy": ""
 694:         },
 695:         {
 696:           "id": 6,
 697:           "title": "Develop Form Generation Logic",
 698:           "description": "Create the logic that generates complete forms dynamically by combining field rendering and validation mapping.",
 699:           "dependencies": [
 700:             3,
 701:             5
 702:           ],
 703:           "details": "Ensure the form generation supports dynamic updates, conditional fields, and integrates validation seamlessly.",
 704:           "status": "pending",
 705:           "testStrategy": ""
 706:         },
 707:         {
 708:           "id": 7,
 709:           "title": "Test Dynamic Rendering and Validation",
 710:           "description": "Design and execute comprehensive tests to verify dynamic field rendering, validation mapping, and form generation correctness.",
 711:           "dependencies": [
 712:             6
 713:           ],
 714:           "details": "Include unit tests, integration tests, and user acceptance tests covering various dynamic scenarios and edge cases.",
 715:           "status": "pending",
 716:           "testStrategy": ""
 717:         },
 718:         {
 719:           "id": 8,
 720:           "title": "Optimize Performance and Refine UX",
 721:           "description": "Analyze performance bottlenecks and improve user experience in dynamic form rendering and validation feedback.",
 722:           "dependencies": [
 723:             7
 724:           ],
 725:           "details": "Implement optimizations such as memoization, lazy loading, and enhance UI responsiveness and accessibility.",
 726:           "status": "pending",
 727:           "testStrategy": ""
 728:         }
 729:       ]
 730:     },
 731:     {
 732:       "id": 7,
 733:       "title": "Implement File Upload System",
 734:       "description": "Create a drag-and-drop file upload system using Next.js 15 App Router patterns with Payload CMS v3 integration and modern best practices tailored for restaurant management system media needs.",
 735:       "status": "pending",
 736:       "dependencies": [
 737:         2,
 738:         4
 739:       ],
 740:       "priority": "medium",
 741:       "details": "1. Use Payload CMS v3 built-in media collections with image transformations for multiple sizes (thumbnail, menu, full).\n2. Implement React Dropzone for drag-and-drop file uploads with MIME type validation and file size limits.\n3. Add chunked uploads with progress tracking and upload queue management using TanStack Query v5 mutations.\n4. Configure image optimization and integrate CDN delivery for optimized image serving.\n5. Implement proper error handling for upload failures including network and validation errors.\n6. Manage upload queue for multiple files ensuring smooth user experience.\n7. Ensure secure access control and validation in Payload CMS media collections.\n8. Align implementation with restaurant management system requirements for menu item images and media management.",
 742:       "testStrategy": "1. Test file upload flow using React Dropzone with drag-and-drop and multiple file queue management.\n2. Verify MIME type validation, file size limits, and Payload CMS media collection integration.\n3. Test chunked upload progress tracking and resume capability with TanStack Query v5.\n4. Validate image optimization across multiple sizes and CDN delivery performance.\n5. Confirm robust error handling for upload failures including network and validation errors.\n6. Ensure secure access control enforcement in media serving.\n7. Perform end-to-end testing aligned with restaurant management system media requirements.",
 743:       "subtasks": [
 744:         {
 745:           "id": 1,
 746:           "title": "Dropzone UI Component Implementation",
 747:           "description": "Create React Dropzone component with drag-and-drop functionality for menu item images",
 748:           "dependencies": [],
 749:           "details": "Implement useDropzone hook with accept: 'image/*', multiple: true. Style dropzone area with visual feedback for drag-active/drag-reject states. Include file type validation (jpg, png, webp) and max file size (5MB) restrictions.",
 750:           "status": "pending",
 751:           "testStrategy": ""
 752:         },
 753:         {
 754:           "id": 2,
 755:           "title": "File State Management",
 756:           "description": "Implement state handling for selected files and upload progress",
 757:           "dependencies": [
 758:             1
 759:           ],
 760:           "details": "Create React state for tracking: 1) Selected files array, 2) Upload progress per file (0-100%), 3) Upload status (idle/uploading/success/error). Use useReducer for complex state transitions.",
 761:           "status": "pending",
 762:           "testStrategy": ""
 763:         },
 764:         {
 765:           "id": 3,
 766:           "title": "Payload CMS Media Collection Integration",
 767:           "description": "Configure Payload CMS media collection for restaurant menu items",
 768:           "dependencies": [],
 769:           "details": "Set up Payload media collection with fields: filename, mimeType, filesize, restaurantID. Configure access controls for CRUD operations. Implement image transformation presets for thumbnails.",
 770:           "status": "pending",
 771:           "testStrategy": ""
 772:         },
 773:         {
 774:           "id": 4,
 775:           "title": "File Upload Handler",
 776:           "description": "Implement API endpoint for processing uploads to Payload CMS",
 777:           "dependencies": [
 778:             3
 779:           ],
 780:           "details": "Create Next.js API route handling multipart/form-data. Use Payload's create handler to store files in media collection. Implement server-side validation for file types/sizes. Return media document ID on success.",
 781:           "status": "pending",
 782:           "testStrategy": ""
 783:         },
 784:         {
 785:           "id": 5,
 786:           "title": "TanStack Query Mutation Setup",
 787:           "description": "Create file upload mutation with progress tracking",
 788:           "dependencies": [
 789:             2,
 790:             4
 791:           ],
 792:           "details": "Implement useMutation hook with axios POST to upload endpoint. Configure onUploadProgress callback to update progress state. Handle concurrent uploads with Promise.allSettled. Implement automatic retry logic for failed uploads.",
 793:           "status": "pending",
 794:           "testStrategy": ""
 795:         },
 796:         {
 797:           "id": 6,
 798:           "title": "Progress Tracking UI",
 799:           "description": "Visual upload progress indicators",
 800:           "dependencies": [
 801:             2,
 802:             5
 803:           ],
 804:           "details": "Create progress bar component showing: 1) Overall upload percentage, 2) Individual file status. Implement animated transitions between states. Display upload speed and time estimates.",
 805:           "status": "pending",
 806:           "testStrategy": ""
 807:         },
 808:         {
 809:           "id": 8,
 810:           "title": "Media Management Integration",
 811:           "description": "Connect uploads to restaurant management system",
 812:           "dependencies": [
 813:             3,
 814:             5
 815:           ],
 816:           "details": "Implement TanStack Query to fetch existing media. Create gallery view with delete functionality. Associate uploaded media with menu items via Payload relationships. Implement caching strategies for media data.",
 817:           "status": "pending",
 818:           "testStrategy": ""
 819:         }
 820:       ]
 821:     },
 822:     {
 823:       "id": 8,
 824:       "title": "Develop Collection Management",
 825:       "description": "Implement CRUD operations for Payload collections with relationship handling, incorporating modern authentication and access control best practices.",
 826:       "status": "done",
 827:       "dependencies": [
 828:         5
 829:       ],
 830:       "priority": "medium",
 831:       "details": "1. Create collection hooks:\n```typescript\nexport const useCollection = <T>(collection: string) => {\n  return useQuery<T[]>(['collection', collection], () =>\n    fetch(`/api/collections/${collection}`).then(res => res.json())\n  );\n};\n```\n2. Set up relationship handling\n3. Implement batch operations\n4. Add sorting and filtering\n\n<info added on 2025-07-01T23:20:40.309Z>\nIncorporate TypeScript generics to enforce strong typing for collection documents and relationships, defining base interfaces for reusable fields such as timestamps and user roles. Implement bidirectional relationship management using Payload CMS hooks to maintain data integrity, especially for linked entities like employees and locations. Centralize access control logic in reusable functions to streamline permission checks for roles such as admin and location manager, applying these in collection access configurations. Enhance validation by combining field-level validators with collection hooks to enforce complex business rules, providing clear and contextual error messages. Apply these best practices to ensure robust CRUD operations with relationship handling, batch operations, sorting, and filtering in the restaurant management system collections.\n</info added on 2025-07-01T23:20:40.309Z>\n\n<info added on 2025-07-15T12:00:00.000Z>\nUpdate to incorporate modern authentication best practices with Payload CMS 3.0 and Next.js 15:\n- Use Payload's built-in authentication with JWT tokens and refresh tokens\n- Implement Next.js 15 middleware for route protection\n- Add role-based access control (RBAC) for restaurant staff hierarchy\n- Configure session management with secure cookies\n- Implement OAuth integration for social login options\n- Add multi-factor authentication (MFA) support\n- Create authentication context with TanStack Query integration\n- Implement proper logout and session cleanup\nThese updates align with restaurant management system security requirements for staff access control.\n</info added on 2025-07-15T12:00:00.000Z>",
 832:       "testStrategy": "1. Test CRUD operations\n2. Verify relationship handling\n3. Test batch operations\n4. Validate filters and sorts\n5. Test authentication flows including JWT and refresh tokens\n6. Verify Next.js 15 middleware route protection\n7. Validate role-based access control for different staff roles\n8. Test session management with secure cookies\n9. Test OAuth social login integration\n10. Verify multi-factor authentication setup and enforcement\n11. Test logout and session cleanup processes",
 833:       "subtasks": [
 834:         {
 835:           "id": 1,
 836:           "title": "Design Data Models and Relationships",
 837:           "description": "Define the data models and their relationships to support CRUD operations and filtering.",
 838:           "status": "done",
 839:           "dependencies": [],
 840:           "details": "Identify entities, their attributes, and relationships (one-to-one, one-to-many, many-to-many). Create ER diagrams or schema definitions.",
 841:           "testStrategy": ""
 842:         },
 843:         {
 844:           "id": 2,
 845:           "title": "Implement Create Operations",
 846:           "description": "Develop the functionality to create new records for each data model, ensuring relationship integrity.",
 847:           "status": "done",
 848:           "dependencies": [
 849:             1
 850:           ],
 851:           "details": "Write code to insert new entities into the database, handling foreign keys and relationship constraints.",
 852:           "testStrategy": ""
 853:         },
 854:         {
 855:           "id": 3,
 856:           "title": "Implement Read Operations with Filtering",
 857:           "description": "Develop read operations that support advanced filtering based on attributes and relationships.",
 858:           "status": "done",
 859:           "dependencies": [
 860:             1
 861:           ],
 862:           "details": "Implement querying mechanisms that allow filtering by fields and related entities, including pagination and sorting.",
 863:           "testStrategy": ""
 864:         },
 865:         {
 866:           "id": 4,
 867:           "title": "Implement Update Operations",
 868:           "description": "Develop update functionality for existing records, including updates to relationships.",
 869:           "status": "done",
 870:           "dependencies": [
 871:             1,
 872:             2
 873:           ],
 874:           "details": "Write code to modify entity attributes and manage changes in relationships while maintaining data integrity.",
 875:           "testStrategy": ""
 876:         },
 877:         {
 878:           "id": 5,
 879:           "title": "Implement Delete Operations with Relationship Handling",
 880:           "description": "Develop delete functionality that safely removes records and handles cascading or restricted deletes based on relationships.",
 881:           "status": "done",
 882:           "dependencies": [
 883:             1,
 884:             2
 885:           ],
 886:           "details": "Ensure deletion respects relationship constraints and prevents orphaned records or data inconsistencies.",
 887:           "testStrategy": ""
 888:         },
 889:         {
 890:           "id": 6,
 891:           "title": "Develop Advanced Filtering System",
 892:           "description": "Create a flexible filtering system that supports complex queries involving multiple relationships and conditions.",
 893:           "status": "done",
 894:           "dependencies": [
 895:             3
 896:           ],
 897:           "details": "Implement filtering logic that can handle nested conditions, joins, and dynamic query building.",
 898:           "testStrategy": ""
 899:         },
 900:         {
 901:           "id": 7,
 902:           "title": "Test and Optimize CRUD and Filtering Operations",
 903:           "description": "Perform thorough testing and optimization of all CRUD operations and filtering mechanisms to ensure performance and correctness.",
 904:           "status": "done",
 905:           "dependencies": [
 906:             2,
 907:             3,
 908:             4,
 909:             5,
 910:             6
 911:           ],
 912:           "details": "Write unit and integration tests, profile queries, and optimize database indexes and code for high complexity scenarios.",
 913:           "testStrategy": ""
 914:         }
 915:       ]
 916:     },
 917:     {
 918:       "id": 9,
 919:       "title": "Implement Role-Based UI Components",
 920:       "description": "Create UI components and layouts with role-based visibility control.",
 921:       "details": "1. Create PermissionGate component:\n```typescript\nconst PermissionGate = ({ roles, children }: PermissionGateProps) => {\n  const { user } = useAuth();\n  if (!roles.includes(user?.role)) return null;\n  return <>{children}</>;\n};\n```\n2. Implement role-based navigation\n3. Add conditional rendering utilities\n4. Create protected layouts",
 922:       "testStrategy": "1. Test role-based access\n2. Verify component visibility\n3. Test navigation guards\n4. Validate layout protection",
 923:       "priority": "medium",
 924:       "dependencies": [
 925:         3
 926:       ],
 927:       "status": "pending",
 928:       "subtasks": [
 929:         {
 930:           "id": 3,
 931:           "title": "Permission Components",
 932:           "description": "Create reusable permission-aware UI components",
 933:           "dependencies": [],
 934:           "details": "Develop `Can` component for conditional rendering based on user roles. Create `ProtectedComponent` wrapper for role-based element rendering. Implement `usePermissions` hook for programmatic access checks. Design permission-aware button groups and navigation items.",
 935:           "status": "pending",
 936:           "testStrategy": ""
 937:         },
 938:         {
 939:           "id": 5,
 940:           "title": "Dashboard Layout System",
 941:           "description": "Build responsive dashboard layout with protected sections",
 942:           "dependencies": [
 943:             3
 944:           ],
 945:           "details": "Create `DashboardLayout` component with MUI. Implement responsive sidebar with dynamic navigation items based on user roles. Develop `PageContainer` for consistent content wrapping. Add real-time data sections using TanStack Query hooks. Implement breadcrumb navigation with permission checks.",
 946:           "status": "pending",
 947:           "testStrategy": ""
 948:         }
 949:       ]
 950:     },
 951:     {
 952:       "id": 10,
 953:       "title": "Set Up Testing Infrastructure",
 954:       "description": "Configure and implement testing setup with Vitest and Playwright.",
 955:       "details": "1. Configure Vitest:\n```typescript\n// vitest.config.ts\nexport default defineConfig({\n  test: {\n    environment: 'jsdom',\n    setupFiles: ['./tests/setup.ts']\n  }\n});\n```\n2. Set up Playwright\n3. Create test utilities\n4. Implement CI test running",
 956:       "testStrategy": "1. Verify test configuration\n2. Test utility functions\n3. Validate E2E setup\n4. Confirm CI integration",
 957:       "priority": "medium",
 958:       "dependencies": [
 959:         1
 960:       ],
 961:       "status": "pending",
 962:       "subtasks": [
 963:         {
 964:           "id": 1,
 965:           "title": "Vitest Configuration for Unit Testing",
 966:           "description": "Set up Vitest framework for React component unit tests",
 967:           "dependencies": [],
 968:           "details": "Install Vitest (`npm install -D vitest`), configure vite.config.js with test plugins. Create test files using *.test.jsx pattern. Implement rendering tests for React components using @testing-library/react. Include DOM assertions and user interaction simulations with user-event. Configure coverage reporting.",
 969:           "status": "pending",
 970:           "testStrategy": ""
 971:         },
 972:         {
 973:           "id": 2,
 974:           "title": "Playwright Integration Testing Setup",
 975:           "description": "Configure Playwright for end-to-end component testing",
 976:           "dependencies": [],
 977:           "details": "Install Playwright (`npm init playwright@latest`). Configure playwright.config.js for component testing. Create spec files for critical user flows. Implement cross-browser testing configurations. Use page object pattern for maintainable selectors. Configure video/screenshot capture on failures.",
 978:           "status": "pending",
 979:           "testStrategy": ""
 980:         },
 981:         {
 982:           "id": 3,
 983:           "title": "Supertest API Testing Implementation",
 984:           "description": "Establish API test suite for Next.js routes and Payload CMS",
 985:           "dependencies": [],
 986:           "details": "Install Supertest (`npm install -D supertest`). Create test files for API endpoints. Test CRUD operations for Payload collections with authentication handling. Validate response schemas and status codes. Implement test database seeding using beforeAll hooks. Include edge case testing for error responses.",
 987:           "status": "pending",
 988:           "testStrategy": ""
 989:         },
 990:         {
 991:           "id": 4,
 992:           "title": "React Component Testing Patterns",
 993:           "description": "Implement testing patterns for React components",
 994:           "dependencies": [
 995:             1
 996:           ],
 997:           "details": "Follow Testing Library principles: query by role/text, avoid implementation details. Implement AAA pattern (Arrange-Act-Assert). Use data-testid for stable element targeting. Cover: 1) Rendering verification 2) Prop/state changes 3) User event simulations 4) Async behavior. Include snapshot testing for critical UI components.",
 998:           "status": "pending",
 999:           "testStrategy": ""
1000:         },
1001:         {
1002:           "id": 5,
1003:           "title": "Payload CMS Collection Testing",
1004:           "description": "Develop test suite for Payload CMS collections",
1005:           "dependencies": [
1006:             3
1007:           ],
1008:           "details": "Create tests for: 1) Collection schema validation 2) Access control rules 3) Hooks execution 4) Relationship population. Use test database instances. Validate admin panel operations. Test custom endpoints and plugins. Implement CRUD operation tests with authentication scenarios.",
1009:           "status": "pending",
1010:           "testStrategy": ""
1011:         },
1012:         {
1013:           "id": 6,
1014:           "title": "CI Pipeline Integration",
1015:           "description": "Configure continuous integration for test execution",
1016:           "dependencies": [
1017:             1,
1018:             2,
1019:             3,
1020:             4,
1021:             5
1022:           ],
1023:           "details": "Set up GitHub Actions workflow: 1) Parallel test execution 2) Caching for dependencies 3) Fail-fast reporting 4) Artifact uploads. Configure separate jobs for unit, integration, and API tests. Add coverage reporting to PR checks. Implement Slack notifications for failures. Include playwright CI container setup.",
1024:           "status": "pending",
1025:           "testStrategy": ""
1026:         }
1027:       ]
1028:     },
1029:     {
1030:       "id": 11,
1031:       "title": "Implement Error Handling and Monitoring",
1032:       "description": "Set up global error handling, logging, and monitoring systems.",
1033:       "details": "1. Configure error boundary:\n```typescript\nclass ErrorBoundary extends React.Component<Props, State> {\n  static getDerivedStateFromError(error: Error) {\n    return { hasError: true, error };\n  }\n  // Implement error UI\n}\n```\n2. Set up Sentry integration\n3. Add error logging\n4. Implement toast notifications",
1034:       "testStrategy": "1. Test error catching\n2. Verify error reporting\n3. Test notification system\n4. Validate logging",
1035:       "priority": "medium",
1036:       "dependencies": [
1037:         1,
1038:         3,
1039:         5
1040:       ],
1041:       "status": "pending",
1042:       "subtasks": [
1043:         {
1044:           "id": 1,
1045:           "title": "Define Error Boundaries",
1046:           "description": "Establish the scope and boundaries for error handling within the system to isolate and manage errors effectively.",
1047:           "dependencies": [],
1048:           "details": "Identify critical modules and components where error boundaries should be implemented to prevent cascading failures.",
1049:           "status": "pending",
1050:           "testStrategy": ""
1051:         },
1052:         {
1053:           "id": 2,
1054:           "title": "Implement Boundary Setup",
1055:           "description": "Develop and integrate error boundary mechanisms based on the defined scopes to catch and handle errors gracefully.",
1056:           "dependencies": [
1057:             1
1058:           ],
1059:           "details": "Use appropriate programming constructs or frameworks to create error boundaries that capture exceptions and prevent system crashes.",
1060:           "status": "pending",
1061:           "testStrategy": ""
1062:         },
1063:         {
1064:           "id": 3,
1065:           "title": "Integrate Monitoring Tools",
1066:           "description": "Set up monitoring systems to track errors and system health in real-time.",
1067:           "dependencies": [
1068:             2
1069:           ],
1070:           "details": "Choose and configure monitoring tools that can capture error logs, performance metrics, and alert on anomalies.",
1071:           "status": "pending",
1072:           "testStrategy": ""
1073:         },
1074:         {
1075:           "id": 4,
1076:           "title": "Develop Notification System",
1077:           "description": "Create a notification mechanism to alert relevant stakeholders when errors occur.",
1078:           "dependencies": [
1079:             3
1080:           ],
1081:           "details": "Design notification workflows including channels (email, SMS, dashboards) and escalation policies for critical errors.",
1082:           "status": "pending",
1083:           "testStrategy": ""
1084:         },
1085:         {
1086:           "id": 5,
1087:           "title": "Test Error Handling Workflow",
1088:           "description": "Conduct comprehensive testing of the error handling system including boundaries, monitoring, and notifications.",
1089:           "dependencies": [
1090:             4
1091:           ],
1092:           "details": "Simulate various error scenarios to verify that errors are caught, logged, monitored, and notifications are sent appropriately.",
1093:           "status": "pending",
1094:           "testStrategy": ""
1095:         },
1096:         {
1097:           "id": 6,
1098:           "title": "Document Error Handling Implementation",
1099:           "description": "Prepare detailed documentation covering the error handling architecture, setup, and operational guidelines.",
1100:           "dependencies": [
1101:             5
1102:           ],
1103:           "details": "Include instructions for maintenance, troubleshooting, and future enhancements of the error handling system.",
1104:           "status": "pending",
1105:           "testStrategy": ""
1106:         }
1107:       ]
1108:     },
1109:     {
1110:       "id": 12,
1111:       "title": "Configure CI/CD Pipeline",
1112:       "description": "Set up deployment pipeline with GitHub Actions and Vercel.",
1113:       "details": "1. Create GitHub Actions workflow:\n```yaml\nname: CI/CD\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\njobs:\n  build-and-test:\n    runs-on: ubuntu-latest\n    steps:\n      # Define build and test steps\n```\n2. Configure Vercel deployment\n3. Set up environment secrets\n4. Implement deployment checks",
1114:       "testStrategy": "1. Test CI pipeline\n2. Verify deployment process\n3. Validate environment setup\n4. Test rollback procedures",
1115:       "priority": "medium",
1116:       "dependencies": [
1117:         10,
1118:         11
1119:       ],
1120:       "status": "pending",
1121:       "subtasks": [
1122:         {
1123:           "id": 1,
1124:           "title": "Define Deployment Workflow Requirements",
1125:           "description": "Gather and document the requirements for the deployment workflow including stages, triggers, and deployment targets.",
1126:           "dependencies": [],
1127:           "details": "Identify the environments (e.g., staging, production), deployment frequency, rollback strategies, and approval processes needed.",
1128:           "status": "pending",
1129:           "testStrategy": ""
1130:         },
1131:         {
1132:           "id": 2,
1133:           "title": "Configure Environment Settings",
1134:           "description": "Set up environment-specific configurations such as environment variables, secrets management, and resource allocation.",
1135:           "dependencies": [
1136:             1
1137:           ],
1138:           "details": "Create configuration files or use environment management tools to ensure each environment is properly configured for deployment.",
1139:           "status": "pending",
1140:           "testStrategy": ""
1141:         },
1142:         {
1143:           "id": 3,
1144:           "title": "Implement Deployment Workflow Automation",
1145:           "description": "Develop and automate the deployment workflow using CI/CD tools based on the defined requirements.",
1146:           "dependencies": [
1147:             1,
1148:             2
1149:           ],
1150:           "details": "Use tools like Jenkins, GitHub Actions, or GitLab CI to script the deployment pipeline including build, test, and deploy stages.",
1151:           "status": "pending",
1152:           "testStrategy": ""
1153:         },
1154:         {
1155:           "id": 4,
1156:           "title": "Integrate Testing into Deployment Pipeline",
1157:           "description": "Incorporate automated testing stages into the deployment workflow to ensure code quality and functionality.",
1158:           "dependencies": [
1159:             3
1160:           ],
1161:           "details": "Add unit tests, integration tests, and end-to-end tests to the CI/CD pipeline to run automatically during deployment.",
1162:           "status": "pending",
1163:           "testStrategy": ""
1164:         },
1165:         {
1166:           "id": 5,
1167:           "title": "Validate Deployment and Testing Setup",
1168:           "description": "Perform validation runs of the deployment workflow and testing integration to verify correctness and reliability.",
1169:           "dependencies": [
1170:             4
1171:           ],
1172:           "details": "Execute test deployments to staging environment and review logs and test results to confirm successful setup.",
1173:           "status": "pending",
1174:           "testStrategy": ""
1175:         },
1176:         {
1177:           "id": 6,
1178:           "title": "Document Deployment and Testing Procedures",
1179:           "description": "Create comprehensive documentation for the deployment workflow, environment configuration, and testing integration.",
1180:           "dependencies": [
1181:             5
1182:           ],
1183:           "details": "Include step-by-step guides, configuration details, troubleshooting tips, and maintenance instructions.",
1184:           "status": "pending",
1185:           "testStrategy": ""
1186:         }
1187:       ]
1188:     },
1189:     {
1190:       "id": 13,
1191:       "title": "Implement and Configure Payload Auditor for Comprehensive Audit Logging",
1192:       "description": "Integrate and configure a payload-auditor or equivalent audit logging mechanism to capture all critical admin actions (create, update, delete) with user and payload details, and define retention policies for audit logs.",
1193:       "details": "1. Integrate the payload-auditor plugin (or a similar audit logging solution) into the Payload CMS configuration. 2. Configure audit hooks on key collections (e.g., Users, Locations) to log create, update, and delete actions, ensuring each log entry includes user ID, operation type, timestamp, and relevant payload data. 3. Reference llm_context/payload3/best_practices.md to align with recommended audit logging standards and security practices. 4. Define and implement log retention policies (e.g., automatic deletion or archiving of logs older than a specified period) within the Payload CMS or via scheduled background jobs. 5. Ensure audit logs are stored securely and are queryable for compliance and troubleshooting. 6. Document the audit logging and retention configuration for future maintenance.",
1194:       "testStrategy": "1. Write unit tests to verify that create, update, and delete operations on Users and Locations collections generate audit log entries containing user ID, operation type, and payload data. 2. Use integration tests to simulate admin actions and confirm that logs are written as expected. 3. Test log retention by creating logs with timestamps outside the retention window and verifying their automatic deletion or archival. 4. Manually inspect audit logs for completeness and security. 5. Review documentation for clarity and accuracy.",
1195:       "status": "pending",
1196:       "dependencies": [
1197:         2,
1198:         8
1199:       ],
1200:       "priority": "medium",
1201:       "subtasks": []
1202:     },
1203:     {
1204:       "id": 14,
1205:       "title": "Establish and Enforce Strict TypeScript Typing Guidelines for Payload",
1206:       "description": "Define, document, and enforce strict TypeScript typing standards for Payload CMS hooks, access control functions, and field conditions, including automated linting rules and developer documentation.",
1207:       "details": "1. Review llm_context/responses/typescript_error_resolution_v2.md and llm_context/responses/typescript_errors.md to extract recommended strict typing patterns for Payload CMS, focusing on hooks, access control functions, and field condition callbacks. 2. Draft clear, actionable guidelines outlining required TypeScript types, generics, and best practices for Payload-specific code. 3. Update or create a dedicated section in CONTRIBUTING.md (or a similar developer guide) to document these guidelines, including code examples and rationale. 4. Configure or extend the project's ESLint setup to enforce these guidelines, using plugins such as @typescript-eslint and custom rules where necessary. 5. Integrate linting into the CI pipeline to ensure ongoing compliance. 6. Communicate changes to the team and provide migration instructions for existing code that does not meet the new standards.",
1208:       "testStrategy": "1. Update or create an ESLint configuration file with rules enforcing strict typing for Payload hooks, access control, and field conditions. 2. Run 'npm run lint' and verify that violations are reported for non-compliant code. 3. Confirm that CI fails on type guideline violations. 4. Review the updated CONTRIBUTING.md to ensure guidelines are clear, complete, and include relevant examples. 5. Validate that new and existing code is checked automatically by ESLint and that developers are aware of the new standards.",
1209:       "status": "pending",
1210:       "dependencies": [
1211:         10,
1212:         12
1213:       ],
1214:       "priority": "medium",
1215:       "subtasks": []
1216:     },
1217:     {
1218:       "id": 15,
1219:       "title": "Enforce Code Documentation Standards (Inline Comments & JSDoc/TSDoc)",
1220:       "description": "Establish and enforce code documentation standards using inline comments and JSDoc/TSDoc for all functions, classes, and interfaces, and update contributing guidelines accordingly.",
1221:       "details": "1. Define clear documentation standards for inline comments (focusing on explaining complex logic and intent) and for JSDoc/TSDoc usage on all exported functions, classes, and interfaces. 2. Update or create a dedicated documentation file (e.g., llm_context/documentation_standards.md) outlining these requirements, including examples and rationale. 3. Revise the project's CONTRIBUTING.md to reference these standards and set expectations for contributors. 4. Implement a pre-commit hook (e.g., using Husky and lint-staged) or a CI/CD check that uses tools like ESLint with plugins such as eslint-plugin-jsdoc to automatically flag missing or insufficient documentation in new or modified code. 5. Provide onboarding documentation or a quick reference guide for developers to adopt the standards efficiently. 6. Ensure that the documentation standards are compatible with existing TypeScript typing and testing guidelines.",
1222:       "testStrategy": "1. Review a representative sample of existing code files to identify and document areas lacking sufficient inline comments or JSDoc/TSDoc coverage. 2. Verify that the pre-commit hook or CI/CD check correctly detects and blocks commits with undocumented or poorly documented code. 3. Confirm that the updated CONTRIBUTING.md and documentation_standards.md are clear, accessible, and referenced in onboarding materials. 4. Run ESLint (with the relevant plugins) on the codebase and ensure that violations are reported for missing or inadequate documentation. 5. Solicit feedback from at least one developer to validate that the standards and enforcement mechanisms are practical and effective.",
1223:       "status": "pending",
1224:       "dependencies": [
1225:         10,
1226:         12
1227:       ],
1228:       "priority": "medium",
1229:       "subtasks": []
1230:     },
1231:     {
1232:       "id": 16,
1233:       "title": "Review and Refine Form Composition for Complex Forms",
1234:       "description": "Analyze and improve the architecture of complex forms, focusing on multi-step and dynamic scenarios, to enhance maintainability and user experience. Consider introducing a more structured state management approach or adopting a specialized form library if current patterns are insufficient.",
1235:       "details": "1. Audit existing form implementations, especially those that are multi-step or highly dynamic, referencing llm_context/forms/README.md for current patterns and submission flows.\n2. Identify pain points, redundancies, or limitations in the current form composition, state management, and validation strategies.\n3. Research best practices for complex form handling, such as using a state machine (e.g., XState) or adopting a more opinionated form library if React Hook Form and Zod prove insufficient for advanced scenarios.\n4. Select a representative complex form (or design a hypothetical one if none exist) and document its current structure, highlighting areas for improvement.\n5. Propose a refactored architecture, possibly implementing a proof-of-concept using the chosen structured approach (e.g., state machine, enhanced context management, or a new library).\n6. Document findings, recommendations, and implementation details in a new llm_context/forms/complex_forms.md file, including code samples and migration guidance if changes are recommended.",
1236:       "testStrategy": "1. Select a complex form within the application (or define a hypothetical one) and analyze its current implementation against modern best practices for form composition and state management.\n2. Document identified issues or limitations in the current approach.\n3. Implement a refactored version of the form using the proposed structured approach, ensuring feature parity and improved maintainability.\n4. Compare the original and refactored implementations in terms of code clarity, scalability, and user experience.\n5. Review and validate the new llm_context/forms/complex_forms.md documentation for completeness, clarity, and actionable recommendations.",
1237:       "status": "pending",
1238:       "dependencies": [
1239:         4,
1240:         6
1241:       ],
1242:       "priority": "medium",
1243:       "subtasks": []
1244:     },
1245:     {
1246:       "id": 17,
1247:       "title": "Verify and Test Payload Auditor Audit Logging and Retention Policies",
1248:       "description": "Verify the correct implementation and configuration of the Payload CMS audit-logging plugin (referred to as 'payload-auditor' or similar mechanism), ensuring all critical admin actions are logged with user and payload details, and that retention policies are enforced. Emphasize that the audit-logging solution is database-agnostic and functions with Payload CMS regardless of the underlying database.",
1249:       "status": "pending",
1250:       "dependencies": [
1251:         2,
1252:         8,
1253:         13
1254:       ],
1255:       "priority": "medium",
1256:       "details": "Review the integration of the Payload CMS audit-logging plugin (payload-auditor or equivalent) within the Payload CMS configuration, ensuring audit hooks are properly set up on key collections such as Users and Locations. Confirm that log entries are generated for create, update, and delete actions, and that each entry includes user ID, operation type, timestamp, and relevant payload data. Ensure that the audit-logging mechanism is not tied to any specific database (e.g., MongoDB), but works with any database supported by Payload CMS. Reference llm_context/payload3/best_practices.md to validate alignment with recommended audit logging and security practices. Define and implement log retention policies, ensuring logs are stored securely and purged according to compliance requirements. Update documentation to reflect audit logging and retention policy configurations, making clear that the solution is database-agnostic.",
1257:       "testStrategy": "1. Write unit tests to confirm that create, update, and delete operations on Users and Locations collections generate audit log entries with the correct user ID, operation type, and payload data, regardless of the underlying database. 2. Perform integration tests simulating admin actions to verify logs are created and stored as expected across different database backends. 3. Test log retention by creating logs, advancing the system clock or adjusting timestamps, and confirming that expired logs are purged according to the defined retention policy. 4. Review logs for completeness, accuracy, and security of sensitive information. 5. Validate that documentation accurately describes the audit logging and retention setup, and clearly states that the solution is database-agnostic.",
1258:       "subtasks": []
1259:     },
1260:     {
1261:       "id": 18,
1262:       "title": "Implement Automated Enforcement of TypeScript Typing Guidelines in Payload",
1263:       "description": "Set up and configure automated linting and documentation to enforce strict TypeScript typing guidelines for Payload CMS hooks, access control functions, and field conditions.",
1264:       "details": "1. Review the documented strict TypeScript typing guidelines for Payload CMS, focusing on hooks, access control functions, and field conditions as outlined in llm_context/responses/typescript_error_resolution_v2.md and llm_context/responses/typescript_errors.md. 2. Update or create an ESLint configuration file (e.g., .eslintrc.js) to include rules that enforce these guidelines, such as requiring explicit types for function parameters and return values, and disallowing use of 'any' in Payload-specific contexts. 3. Integrate ESLint with the project's CI pipeline to ensure all code is checked for compliance. 4. Document the enforced rules and their rationale in the CONTRIBUTING.md or a dedicated developer guide section, providing examples and references to the guidelines. 5. Communicate the new standards to the development team and ensure onboarding materials are updated.",
1265:       "testStrategy": "1. Run 'npm run lint' on the existing codebase to verify that the new ESLint rules correctly identify violations of the strict typing guidelines. 2. Intentionally introduce non-compliant code (e.g., missing types, use of 'any') and confirm that linting fails as expected. 3. Check that CI fails on pull requests with typing violations. 4. Review the updated documentation to ensure it clearly explains the enforced rules and provides actionable examples. 5. Solicit feedback from developers to confirm understanding and adoption of the new guidelines.",
1266:       "status": "pending",
1267:       "dependencies": [
1268:         10,
1269:         12,
1270:         14
1271:       ],
1272:       "priority": "medium",
1273:       "subtasks": []
1274:     },
1275:     {
1276:       "id": 19,
1277:       "title": "Enforce Code Documentation Standards (Inline Comments & JSDoc/TSDoc)",
1278:       "description": "Establish and enforce code documentation standards using inline comments and JSDoc/TSDoc for all functions, classes, and interfaces, and update contributing guidelines accordingly.",
1279:       "details": "1. Define clear documentation standards for inline comments (focusing on explaining complex logic and intent) and for JSDoc/TSDoc usage on all exported functions, classes, and interfaces. 2. Update or create a dedicated documentation file (e.g., llm_context/documentation_standards.md) outlining these requirements, including examples and rationale. 3. Revise the project's CONTRIBUTING.md to reference these standards and set expectations for contributors. 4. Implement a pre-commit hook (e.g., using Husky and lint-staged) or CI/CD check to automatically flag new or modified code that lacks required documentation. 5. Conduct a code review of a representative sample of existing files to identify and document areas lacking sufficient inline comments or JSDoc/TSDoc coverage. 6. Provide onboarding guidance for developers to adopt the new standards, including links to resources and examples.",
1280:       "testStrategy": "1. Review a representative sample of existing code files to identify and document areas lacking sufficient inline comments or JSDoc/TSDoc coverage. 2. Verify that the pre-commit hook or CI/CD check correctly detects and blocks commits with undocumented or poorly documented code. 3. Confirm that the documentation standards are clearly described in llm_context/documentation_standards.md (or similar) and referenced in CONTRIBUTING.md. 4. Solicit feedback from at least one developer unfamiliar with the codebase to ensure the standards improve code understandability and onboarding. 5. Validate that onboarding materials and documentation are accessible and comprehensive.",
1281:       "status": "pending",
1282:       "dependencies": [
1283:         10,
1284:         12
1285:       ],
1286:       "priority": "medium",
1287:       "subtasks": []
1288:     },
1289:     {
1290:       "id": 20,
1291:       "title": "Review and Refine Form Composition for Complex Forms",
1292:       "description": "Analyze and improve the architecture of complex, multi-step, or dynamic forms to enhance maintainability and user experience, potentially introducing a more structured state management approach or adopting a specialized form library.",
1293:       "details": "1. Audit existing complex form implementations, focusing on multi-step and highly dynamic forms, referencing llm_context/forms/README.md for current patterns and submission flows.\n2. Identify pain points, redundancies, or limitations in current form composition, state management, and validation strategies.\n3. Research best practices for complex form handling, such as leveraging state machines (e.g., XState) or adopting a more opinionated form library if React Hook Form and Zod are insufficient.\n4. Select a representative complex form (or define a hypothetical one if none exist) and analyze its implementation against modern best practices.\n5. Propose a refactored approach, implementing a proof-of-concept using a more structured pattern or library if warranted.\n6. Document findings, recommendations, and the refactored approach in a new llm_context/forms/complex_forms.md file, including before/after code samples and rationale for changes.",
1294:       "testStrategy": "1. Identify a complex form within the application (or define a hypothetical one) and document its current implementation, highlighting pain points and limitations.\n2. Compare the current approach to best practices for form composition and state management, noting gaps or inefficiencies.\n3. Implement a refactored version of the form using a more structured approach (e.g., state machine or specialized library) and validate its maintainability, scalability, and user experience improvements.\n4. Document the analysis, refactoring process, and recommendations in llm_context/forms/complex_forms.md, including code samples and rationale.\n5. Review the documentation and refactored implementation with at least one other developer for feedback and validation.",
1295:       "status": "pending",
1296:       "dependencies": [
1297:         4,
1298:         6
1299:       ],
1300:       "priority": "medium",
1301:       "subtasks": []
1302:     },
1303:     {
1304:       "id": 21,
1305:       "title": "Refactor and Centralize Access Control & Role Management",
1306:       "description": "Centralize all access control logic into a dedicated module and refactor collection files to utilize these functions, improving maintainability and reducing errors.",
1307:       "details": "1. Design and implement a centralized access control module (e.g., access/index.ts) that encapsulates all permission checks, role management, and access logic for Payload collections. 2. Migrate existing access control logic from individual collection files and scattered locations into this module, ensuring all permission checks are standardized and reusable. 3. Update all collection files to import and use the new centralized access control functions, replacing any inline or duplicated logic. 4. Ensure the module supports strong TypeScript typing, leveraging generics and interfaces for roles and permissions. 5. Document the new access control API and usage patterns for developers. 6. Refactor tests to validate access control via the new module. 7. Coordinate with recent improvements in collection management to ensure compatibility with relationship handling and batch operations.",
1308:       "testStrategy": "1. Review all collection files to confirm they exclusively use the centralized access control functions. 2. Write and run unit tests for the new access control module, covering all supported roles and permission scenarios. 3. Perform integration tests to verify that CRUD operations, relationship handling, and batch operations respect the new access control logic. 4. Validate that role-based access control is enforced consistently across all collections. 5. Conduct code review to ensure no legacy or duplicated access logic remains. 6. Confirm TypeScript type safety and proper documentation of the new module.",
1309:       "status": "pending",
1310:       "dependencies": [
1311:         8
1312:       ],
1313:       "priority": "high",
1314:       "subtasks": [
1315:         {
1316:           "id": 1,
1317:           "title": "Create Centralized Access Control Functions",
1318:           "description": "Create `payload-backend/src/access/index.ts` and move common access logic (e.g., isAdmin, isManager) into this file. Ensure functions are strongly typed using `UserRole`.",
1319:           "details": "The file `payload-backend/src/access/index.ts` has already been created and populated with initial access control functions. This subtask is to ensure all necessary common access logic is centralized and correctly typed. Review `payload-backend/src/types/auth.ts` to confirm `UserRole` is comprehensive and used consistently in these functions.",
1320:           "status": "done",
1321:           "dependencies": [],
1322:           "parentTaskId": 21
1323:         },
1324:         {
1325:           "id": 2,
1326:           "title": "Refactor Collection Access to Use Centralized Functions",
1327:           "description": "Modify each collection file in `payload-backend/src/collections/` to import and use the centralized access control functions from `payload-backend/src/access/index.ts`.",
1328:           "details": "This involves replacing repetitive inline access logic with calls to `isAdmin`, `isManager`, `isAdminOrManager`, `isFohEmployee`, `isStoreManager`, `isShiftManager`, `isAdminOrSelf`, and `isAdminOrHasLocationAccess` as appropriate for each collection. Ensure correct imports are added to each collection file.",
1329:           "status": "done",
1330:           "dependencies": [],
1331:           "parentTaskId": 21
1332:         }
1333:       ]
1334:     },
1335:     {
1336:       "id": 22,
1337:       "title": "Modularize Middleware for Security, CORS, Authentication, and Rate Limiting",
1338:       "description": "Refactor the monolithic middleware.ts file by splitting it into focused modules for security headers, CORS, authentication, and rate limiting to enhance maintainability and scalability.",
1339:       "details": "1. Analyze the current middleware.ts file to identify distinct concerns: security headers, CORS, authentication, and rate limiting. 2. Create separate modules/files for each concern (e.g., middleware/securityHeaders.ts, middleware/cors.ts, middleware/auth.ts, middleware/rateLimit.ts). 3. Move the relevant logic from middleware.ts into these new modules, ensuring each module is self-contained and has clear interfaces. 4. Refactor the main middleware.ts to import and compose these modules in the appropriate order, maintaining the correct middleware execution flow. 5. Ensure that authentication middleware integrates with the Payload CMS authentication system, and that rate limiting and CORS logic are compatible with Next.js 15 middleware requirements. 6. Update documentation to reflect the new middleware structure and usage patterns. 7. Remove any obsolete or redundant code from the original middleware.ts file.",
1340:       "testStrategy": "1. Write unit tests for each new middleware module to verify correct handling of requests (e.g., security headers are set, CORS rules are enforced, authentication is checked, and rate limiting is applied). 2. Perform integration tests by running the application and confirming that all middleware functions are executed in the correct order and that their effects are visible in HTTP responses. 3. Test protected routes to ensure authentication middleware works as expected with Payload CMS and that unauthenticated requests are blocked. 4. Validate that CORS and rate limiting behave as configured for different endpoints. 5. Review codebase to ensure the original monolithic middleware.ts no longer contains duplicated or obsolete logic. 6. Confirm that documentation accurately describes the new modular middleware structure and usage.",
1341:       "status": "pending",
1342:       "dependencies": [
1343:         3
1344:       ],
1345:       "priority": "high",
1346:       "subtasks": [
1347:         {
1348:           "id": 1,
1349:           "title": "Create Middleware Directory",
1350:           "description": "Create `payload-backend/src/middleware/` directory.",
1351:           "details": "This directory will house individual middleware modules for better organization and maintainability.",
1352:           "status": "done",
1353:           "dependencies": [],
1354:           "parentTaskId": 22
1355:         },
1356:         {
1357:           "id": 2,
1358:           "title": "Create Security Headers Middleware",
1359:           "description": "Create `payload-backend/src/middleware/securityHeaders.ts` for handling security-related HTTP headers.",
1360:           "details": "This file should export a function that sets X-Frame-Options, X-Content-Type-Options, Referrer-Policy, and X-XSS-Protection headers.",
1361:           "status": "pending",
1362:           "dependencies": [],
1363:           "parentTaskId": 22
1364:         }
1365:       ]
1366:     }
1367:   ],
1368:   "metadata": {
1369:     "created": "2025-07-01T23:13:03.567Z",
1370:     "updated": "2025-07-02T04:07:48.750Z",
1371:     "description": "Tasks for master context"
1372:   }
1373: }
</file>

</files>
